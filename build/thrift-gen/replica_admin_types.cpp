/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "replica_admin_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace dsn { namespace replication {

int _kdisk_migration_statusValues[] = {
  disk_migration_status::IDLE,
  disk_migration_status::MOVING,
  disk_migration_status::MOVED,
  disk_migration_status::CLOSED
};
const char* _kdisk_migration_statusNames[] = {
  "IDLE",
  "MOVING",
  "MOVED",
  "CLOSED"
};
const std::map<int, const char*> _disk_migration_status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kdisk_migration_statusValues, _kdisk_migration_statusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _khotkey_typeValues[] = {
  hotkey_type::READ,
  hotkey_type::WRITE
};
const char* _khotkey_typeNames[] = {
  "READ",
  "WRITE"
};
const std::map<int, const char*> _hotkey_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _khotkey_typeValues, _khotkey_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kdetect_actionValues[] = {
  detect_action::START,
  detect_action::STOP,
  detect_action::QUERY
};
const char* _kdetect_actionNames[] = {
  "START",
  "STOP",
  "QUERY"
};
const std::map<int, const char*> _detect_action_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kdetect_actionValues, _kdetect_actionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


query_replica_decree_request::~query_replica_decree_request() throw() {
}


void query_replica_decree_request::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

void query_replica_decree_request::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

uint32_t query_replica_decree_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_replica_decree_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_replica_decree_request");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_replica_decree_request &a, query_replica_decree_request &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.node, b.node);
  swap(a.__isset, b.__isset);
}

query_replica_decree_request::query_replica_decree_request(const query_replica_decree_request& other0) {
  pid = other0.pid;
  node = other0.node;
  __isset = other0.__isset;
}
query_replica_decree_request& query_replica_decree_request::operator=(const query_replica_decree_request& other1) {
  pid = other1.pid;
  node = other1.node;
  __isset = other1.__isset;
  return *this;
}
void query_replica_decree_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_replica_decree_request(";
  out << "pid=" << to_string(pid);
  out << ", " << "node=" << to_string(node);
  out << ")";
}


query_replica_decree_response::~query_replica_decree_response() throw() {
}


void query_replica_decree_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void query_replica_decree_response::__set_last_decree(const int64_t val) {
  this->last_decree = val;
}

uint32_t query_replica_decree_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_decree);
          this->__isset.last_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_replica_decree_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_replica_decree_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_decree", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->last_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_replica_decree_response &a, query_replica_decree_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.last_decree, b.last_decree);
  swap(a.__isset, b.__isset);
}

query_replica_decree_response::query_replica_decree_response(const query_replica_decree_response& other2) {
  err = other2.err;
  last_decree = other2.last_decree;
  __isset = other2.__isset;
}
query_replica_decree_response& query_replica_decree_response::operator=(const query_replica_decree_response& other3) {
  err = other3.err;
  last_decree = other3.last_decree;
  __isset = other3.__isset;
  return *this;
}
void query_replica_decree_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_replica_decree_response(";
  out << "err=" << to_string(err);
  out << ", " << "last_decree=" << to_string(last_decree);
  out << ")";
}


query_replica_info_request::~query_replica_info_request() throw() {
}


void query_replica_info_request::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

uint32_t query_replica_info_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_replica_info_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_replica_info_request");

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_replica_info_request &a, query_replica_info_request &b) {
  using ::std::swap;
  swap(a.node, b.node);
  swap(a.__isset, b.__isset);
}

query_replica_info_request::query_replica_info_request(const query_replica_info_request& other4) {
  node = other4.node;
  __isset = other4.__isset;
}
query_replica_info_request& query_replica_info_request::operator=(const query_replica_info_request& other5) {
  node = other5.node;
  __isset = other5.__isset;
  return *this;
}
void query_replica_info_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_replica_info_request(";
  out << "node=" << to_string(node);
  out << ")";
}


query_replica_info_response::~query_replica_info_response() throw() {
}


void query_replica_info_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void query_replica_info_response::__set_replicas(const std::vector< ::dsn::replication::replica_info> & val) {
  this->replicas = val;
}

uint32_t query_replica_info_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->replicas.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->replicas.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->replicas[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.replicas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_replica_info_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_replica_info_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("replicas", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->replicas.size()));
    std::vector< ::dsn::replication::replica_info> ::const_iterator _iter11;
    for (_iter11 = this->replicas.begin(); _iter11 != this->replicas.end(); ++_iter11)
    {
      xfer += (*_iter11).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_replica_info_response &a, query_replica_info_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.replicas, b.replicas);
  swap(a.__isset, b.__isset);
}

query_replica_info_response::query_replica_info_response(const query_replica_info_response& other12) {
  err = other12.err;
  replicas = other12.replicas;
  __isset = other12.__isset;
}
query_replica_info_response& query_replica_info_response::operator=(const query_replica_info_response& other13) {
  err = other13.err;
  replicas = other13.replicas;
  __isset = other13.__isset;
  return *this;
}
void query_replica_info_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_replica_info_response(";
  out << "err=" << to_string(err);
  out << ", " << "replicas=" << to_string(replicas);
  out << ")";
}


disk_info::~disk_info() throw() {
}


void disk_info::__set_tag(const std::string& val) {
  this->tag = val;
}

void disk_info::__set_full_dir(const std::string& val) {
  this->full_dir = val;
}

void disk_info::__set_disk_capacity_mb(const int64_t val) {
  this->disk_capacity_mb = val;
}

void disk_info::__set_disk_available_mb(const int64_t val) {
  this->disk_available_mb = val;
}

void disk_info::__set_holding_primary_replicas(const std::map<int32_t, std::set< ::dsn::gpid> > & val) {
  this->holding_primary_replicas = val;
}

void disk_info::__set_holding_secondary_replicas(const std::map<int32_t, std::set< ::dsn::gpid> > & val) {
  this->holding_secondary_replicas = val;
}

uint32_t disk_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tag);
          this->__isset.tag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->full_dir);
          this->__isset.full_dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->disk_capacity_mb);
          this->__isset.disk_capacity_mb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->disk_available_mb);
          this->__isset.disk_available_mb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->holding_primary_replicas.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _ktype15;
            ::apache::thrift::protocol::TType _vtype16;
            xfer += iprot->readMapBegin(_ktype15, _vtype16, _size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              int32_t _key19;
              xfer += iprot->readI32(_key19);
              std::set< ::dsn::gpid> & _val20 = this->holding_primary_replicas[_key19];
              {
                _val20.clear();
                uint32_t _size21;
                ::apache::thrift::protocol::TType _etype24;
                xfer += iprot->readSetBegin(_etype24, _size21);
                uint32_t _i25;
                for (_i25 = 0; _i25 < _size21; ++_i25)
                {
                   ::dsn::gpid _elem26;
                  xfer += _elem26.read(iprot);
                  _val20.insert(_elem26);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.holding_primary_replicas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->holding_secondary_replicas.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _ktype28;
            ::apache::thrift::protocol::TType _vtype29;
            xfer += iprot->readMapBegin(_ktype28, _vtype29, _size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              int32_t _key32;
              xfer += iprot->readI32(_key32);
              std::set< ::dsn::gpid> & _val33 = this->holding_secondary_replicas[_key32];
              {
                _val33.clear();
                uint32_t _size34;
                ::apache::thrift::protocol::TType _etype37;
                xfer += iprot->readSetBegin(_etype37, _size34);
                uint32_t _i38;
                for (_i38 = 0; _i38 < _size34; ++_i38)
                {
                   ::dsn::gpid _elem39;
                  xfer += _elem39.read(iprot);
                  _val33.insert(_elem39);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.holding_secondary_replicas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t disk_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("disk_info");

  xfer += oprot->writeFieldBegin("tag", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("full_dir", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->full_dir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("disk_capacity_mb", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->disk_capacity_mb);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("disk_available_mb", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->disk_available_mb);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("holding_primary_replicas", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->holding_primary_replicas.size()));
    std::map<int32_t, std::set< ::dsn::gpid> > ::const_iterator _iter40;
    for (_iter40 = this->holding_primary_replicas.begin(); _iter40 != this->holding_primary_replicas.end(); ++_iter40)
    {
      xfer += oprot->writeI32(_iter40->first);
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter40->second.size()));
        std::set< ::dsn::gpid> ::const_iterator _iter41;
        for (_iter41 = _iter40->second.begin(); _iter41 != _iter40->second.end(); ++_iter41)
        {
          xfer += (*_iter41).write(oprot);
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("holding_secondary_replicas", ::apache::thrift::protocol::T_MAP, 6);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->holding_secondary_replicas.size()));
    std::map<int32_t, std::set< ::dsn::gpid> > ::const_iterator _iter42;
    for (_iter42 = this->holding_secondary_replicas.begin(); _iter42 != this->holding_secondary_replicas.end(); ++_iter42)
    {
      xfer += oprot->writeI32(_iter42->first);
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter42->second.size()));
        std::set< ::dsn::gpid> ::const_iterator _iter43;
        for (_iter43 = _iter42->second.begin(); _iter43 != _iter42->second.end(); ++_iter43)
        {
          xfer += (*_iter43).write(oprot);
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(disk_info &a, disk_info &b) {
  using ::std::swap;
  swap(a.tag, b.tag);
  swap(a.full_dir, b.full_dir);
  swap(a.disk_capacity_mb, b.disk_capacity_mb);
  swap(a.disk_available_mb, b.disk_available_mb);
  swap(a.holding_primary_replicas, b.holding_primary_replicas);
  swap(a.holding_secondary_replicas, b.holding_secondary_replicas);
  swap(a.__isset, b.__isset);
}

disk_info::disk_info(const disk_info& other44) {
  tag = other44.tag;
  full_dir = other44.full_dir;
  disk_capacity_mb = other44.disk_capacity_mb;
  disk_available_mb = other44.disk_available_mb;
  holding_primary_replicas = other44.holding_primary_replicas;
  holding_secondary_replicas = other44.holding_secondary_replicas;
  __isset = other44.__isset;
}
disk_info& disk_info::operator=(const disk_info& other45) {
  tag = other45.tag;
  full_dir = other45.full_dir;
  disk_capacity_mb = other45.disk_capacity_mb;
  disk_available_mb = other45.disk_available_mb;
  holding_primary_replicas = other45.holding_primary_replicas;
  holding_secondary_replicas = other45.holding_secondary_replicas;
  __isset = other45.__isset;
  return *this;
}
void disk_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "disk_info(";
  out << "tag=" << to_string(tag);
  out << ", " << "full_dir=" << to_string(full_dir);
  out << ", " << "disk_capacity_mb=" << to_string(disk_capacity_mb);
  out << ", " << "disk_available_mb=" << to_string(disk_available_mb);
  out << ", " << "holding_primary_replicas=" << to_string(holding_primary_replicas);
  out << ", " << "holding_secondary_replicas=" << to_string(holding_secondary_replicas);
  out << ")";
}


query_disk_info_request::~query_disk_info_request() throw() {
}


void query_disk_info_request::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

void query_disk_info_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

uint32_t query_disk_info_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_disk_info_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_disk_info_request");

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_disk_info_request &a, query_disk_info_request &b) {
  using ::std::swap;
  swap(a.node, b.node);
  swap(a.app_name, b.app_name);
  swap(a.__isset, b.__isset);
}

query_disk_info_request::query_disk_info_request(const query_disk_info_request& other46) {
  node = other46.node;
  app_name = other46.app_name;
  __isset = other46.__isset;
}
query_disk_info_request& query_disk_info_request::operator=(const query_disk_info_request& other47) {
  node = other47.node;
  app_name = other47.app_name;
  __isset = other47.__isset;
  return *this;
}
void query_disk_info_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_disk_info_request(";
  out << "node=" << to_string(node);
  out << ", " << "app_name=" << to_string(app_name);
  out << ")";
}


query_disk_info_response::~query_disk_info_response() throw() {
}


void query_disk_info_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void query_disk_info_response::__set_total_capacity_mb(const int64_t val) {
  this->total_capacity_mb = val;
}

void query_disk_info_response::__set_total_available_mb(const int64_t val) {
  this->total_available_mb = val;
}

void query_disk_info_response::__set_disk_infos(const std::vector<disk_info> & val) {
  this->disk_infos = val;
}

uint32_t query_disk_info_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_capacity_mb);
          this->__isset.total_capacity_mb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_available_mb);
          this->__isset.total_available_mb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->disk_infos.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->disk_infos.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += this->disk_infos[_i52].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.disk_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_disk_info_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_disk_info_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_capacity_mb", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->total_capacity_mb);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_available_mb", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->total_available_mb);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("disk_infos", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->disk_infos.size()));
    std::vector<disk_info> ::const_iterator _iter53;
    for (_iter53 = this->disk_infos.begin(); _iter53 != this->disk_infos.end(); ++_iter53)
    {
      xfer += (*_iter53).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_disk_info_response &a, query_disk_info_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.total_capacity_mb, b.total_capacity_mb);
  swap(a.total_available_mb, b.total_available_mb);
  swap(a.disk_infos, b.disk_infos);
  swap(a.__isset, b.__isset);
}

query_disk_info_response::query_disk_info_response(const query_disk_info_response& other54) {
  err = other54.err;
  total_capacity_mb = other54.total_capacity_mb;
  total_available_mb = other54.total_available_mb;
  disk_infos = other54.disk_infos;
  __isset = other54.__isset;
}
query_disk_info_response& query_disk_info_response::operator=(const query_disk_info_response& other55) {
  err = other55.err;
  total_capacity_mb = other55.total_capacity_mb;
  total_available_mb = other55.total_available_mb;
  disk_infos = other55.disk_infos;
  __isset = other55.__isset;
  return *this;
}
void query_disk_info_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_disk_info_response(";
  out << "err=" << to_string(err);
  out << ", " << "total_capacity_mb=" << to_string(total_capacity_mb);
  out << ", " << "total_available_mb=" << to_string(total_available_mb);
  out << ", " << "disk_infos=" << to_string(disk_infos);
  out << ")";
}


replica_disk_migrate_request::~replica_disk_migrate_request() throw() {
}


void replica_disk_migrate_request::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

void replica_disk_migrate_request::__set_origin_disk(const std::string& val) {
  this->origin_disk = val;
}

void replica_disk_migrate_request::__set_target_disk(const std::string& val) {
  this->target_disk = val;
}

uint32_t replica_disk_migrate_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->origin_disk);
          this->__isset.origin_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target_disk);
          this->__isset.target_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t replica_disk_migrate_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("replica_disk_migrate_request");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("origin_disk", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->origin_disk);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_disk", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->target_disk);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(replica_disk_migrate_request &a, replica_disk_migrate_request &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.origin_disk, b.origin_disk);
  swap(a.target_disk, b.target_disk);
  swap(a.__isset, b.__isset);
}

replica_disk_migrate_request::replica_disk_migrate_request(const replica_disk_migrate_request& other56) {
  pid = other56.pid;
  origin_disk = other56.origin_disk;
  target_disk = other56.target_disk;
  __isset = other56.__isset;
}
replica_disk_migrate_request& replica_disk_migrate_request::operator=(const replica_disk_migrate_request& other57) {
  pid = other57.pid;
  origin_disk = other57.origin_disk;
  target_disk = other57.target_disk;
  __isset = other57.__isset;
  return *this;
}
void replica_disk_migrate_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "replica_disk_migrate_request(";
  out << "pid=" << to_string(pid);
  out << ", " << "origin_disk=" << to_string(origin_disk);
  out << ", " << "target_disk=" << to_string(target_disk);
  out << ")";
}


replica_disk_migrate_response::~replica_disk_migrate_response() throw() {
}


void replica_disk_migrate_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void replica_disk_migrate_response::__set_hint(const std::string& val) {
  this->hint = val;
__isset.hint = true;
}

uint32_t replica_disk_migrate_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint);
          this->__isset.hint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t replica_disk_migrate_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("replica_disk_migrate_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hint) {
    xfer += oprot->writeFieldBegin("hint", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->hint);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(replica_disk_migrate_response &a, replica_disk_migrate_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.hint, b.hint);
  swap(a.__isset, b.__isset);
}

replica_disk_migrate_response::replica_disk_migrate_response(const replica_disk_migrate_response& other58) {
  err = other58.err;
  hint = other58.hint;
  __isset = other58.__isset;
}
replica_disk_migrate_response& replica_disk_migrate_response::operator=(const replica_disk_migrate_response& other59) {
  err = other59.err;
  hint = other59.hint;
  __isset = other59.__isset;
  return *this;
}
void replica_disk_migrate_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "replica_disk_migrate_response(";
  out << "err=" << to_string(err);
  out << ", " << "hint="; (__isset.hint ? (out << to_string(hint)) : (out << "<null>"));
  out << ")";
}


detect_hotkey_request::~detect_hotkey_request() throw() {
}


void detect_hotkey_request::__set_type(const hotkey_type::type val) {
  this->type = val;
}

void detect_hotkey_request::__set_action(const detect_action::type val) {
  this->action = val;
}

void detect_hotkey_request::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

uint32_t detect_hotkey_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast60;
          xfer += iprot->readI32(ecast60);
          this->type = (hotkey_type::type)ecast60;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast61;
          xfer += iprot->readI32(ecast61);
          this->action = (detect_action::type)ecast61;
          this->__isset.action = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t detect_hotkey_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("detect_hotkey_request");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("action", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->action);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(detect_hotkey_request &a, detect_hotkey_request &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.action, b.action);
  swap(a.pid, b.pid);
  swap(a.__isset, b.__isset);
}

detect_hotkey_request::detect_hotkey_request(const detect_hotkey_request& other62) {
  type = other62.type;
  action = other62.action;
  pid = other62.pid;
  __isset = other62.__isset;
}
detect_hotkey_request& detect_hotkey_request::operator=(const detect_hotkey_request& other63) {
  type = other63.type;
  action = other63.action;
  pid = other63.pid;
  __isset = other63.__isset;
  return *this;
}
void detect_hotkey_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "detect_hotkey_request(";
  out << "type=" << to_string(type);
  out << ", " << "action=" << to_string(action);
  out << ", " << "pid=" << to_string(pid);
  out << ")";
}


detect_hotkey_response::~detect_hotkey_response() throw() {
}


void detect_hotkey_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void detect_hotkey_response::__set_err_hint(const std::string& val) {
  this->err_hint = val;
__isset.err_hint = true;
}

void detect_hotkey_response::__set_hotkey_result(const std::string& val) {
  this->hotkey_result = val;
__isset.hotkey_result = true;
}

uint32_t detect_hotkey_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->err_hint);
          this->__isset.err_hint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hotkey_result);
          this->__isset.hotkey_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t detect_hotkey_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("detect_hotkey_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.err_hint) {
    xfer += oprot->writeFieldBegin("err_hint", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->err_hint);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hotkey_result) {
    xfer += oprot->writeFieldBegin("hotkey_result", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->hotkey_result);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(detect_hotkey_response &a, detect_hotkey_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.err_hint, b.err_hint);
  swap(a.hotkey_result, b.hotkey_result);
  swap(a.__isset, b.__isset);
}

detect_hotkey_response::detect_hotkey_response(const detect_hotkey_response& other64) {
  err = other64.err;
  err_hint = other64.err_hint;
  hotkey_result = other64.hotkey_result;
  __isset = other64.__isset;
}
detect_hotkey_response& detect_hotkey_response::operator=(const detect_hotkey_response& other65) {
  err = other65.err;
  err_hint = other65.err_hint;
  hotkey_result = other65.hotkey_result;
  __isset = other65.__isset;
  return *this;
}
void detect_hotkey_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "detect_hotkey_response(";
  out << "err=" << to_string(err);
  out << ", " << "err_hint="; (__isset.err_hint ? (out << to_string(err_hint)) : (out << "<null>"));
  out << ", " << "hotkey_result="; (__isset.hotkey_result ? (out << to_string(hotkey_result)) : (out << "<null>"));
  out << ")";
}

}} // namespace
