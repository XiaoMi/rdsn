/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "duplication_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace dsn { namespace replication {

int _kduplication_statusValues[] = {
  duplication_status::DS_INIT,
  duplication_status::DS_START,
  duplication_status::DS_PAUSE,
  duplication_status::DS_REMOVED
};
const char* _kduplication_statusNames[] = {
  "DS_INIT",
  "DS_START",
  "DS_PAUSE",
  "DS_REMOVED"
};
const std::map<int, const char*> _duplication_status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kduplication_statusValues, _kduplication_statusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kduplication_fail_modeValues[] = {
  duplication_fail_mode::FAIL_SLOW,
  duplication_fail_mode::FAIL_SKIP,
  duplication_fail_mode::FAIL_FAST
};
const char* _kduplication_fail_modeNames[] = {
  "FAIL_SLOW",
  "FAIL_SKIP",
  "FAIL_FAST"
};
const std::map<int, const char*> _duplication_fail_mode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kduplication_fail_modeValues, _kduplication_fail_modeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


duplication_add_request::~duplication_add_request() throw() {
}


void duplication_add_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void duplication_add_request::__set_remote_cluster_name(const std::string& val) {
  this->remote_cluster_name = val;
}

void duplication_add_request::__set_freezed(const bool val) {
  this->freezed = val;
}

uint32_t duplication_add_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remote_cluster_name);
          this->__isset.remote_cluster_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->freezed);
          this->__isset.freezed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t duplication_add_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("duplication_add_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote_cluster_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->remote_cluster_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("freezed", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->freezed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(duplication_add_request &a, duplication_add_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.remote_cluster_name, b.remote_cluster_name);
  swap(a.freezed, b.freezed);
  swap(a.__isset, b.__isset);
}

duplication_add_request::duplication_add_request(const duplication_add_request& other0) {
  app_name = other0.app_name;
  remote_cluster_name = other0.remote_cluster_name;
  freezed = other0.freezed;
  __isset = other0.__isset;
}
duplication_add_request& duplication_add_request::operator=(const duplication_add_request& other1) {
  app_name = other1.app_name;
  remote_cluster_name = other1.remote_cluster_name;
  freezed = other1.freezed;
  __isset = other1.__isset;
  return *this;
}
void duplication_add_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "duplication_add_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "remote_cluster_name=" << to_string(remote_cluster_name);
  out << ", " << "freezed=" << to_string(freezed);
  out << ")";
}


duplication_add_response::~duplication_add_response() throw() {
}


void duplication_add_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void duplication_add_response::__set_appid(const int32_t val) {
  this->appid = val;
}

void duplication_add_response::__set_dupid(const int32_t val) {
  this->dupid = val;
}

void duplication_add_response::__set_hint(const std::string& val) {
  this->hint = val;
__isset.hint = true;
}

uint32_t duplication_add_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->appid);
          this->__isset.appid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dupid);
          this->__isset.dupid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint);
          this->__isset.hint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t duplication_add_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("duplication_add_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->appid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dupid", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->dupid);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hint) {
    xfer += oprot->writeFieldBegin("hint", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->hint);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(duplication_add_response &a, duplication_add_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.appid, b.appid);
  swap(a.dupid, b.dupid);
  swap(a.hint, b.hint);
  swap(a.__isset, b.__isset);
}

duplication_add_response::duplication_add_response(const duplication_add_response& other2) {
  err = other2.err;
  appid = other2.appid;
  dupid = other2.dupid;
  hint = other2.hint;
  __isset = other2.__isset;
}
duplication_add_response& duplication_add_response::operator=(const duplication_add_response& other3) {
  err = other3.err;
  appid = other3.appid;
  dupid = other3.dupid;
  hint = other3.hint;
  __isset = other3.__isset;
  return *this;
}
void duplication_add_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "duplication_add_response(";
  out << "err=" << to_string(err);
  out << ", " << "appid=" << to_string(appid);
  out << ", " << "dupid=" << to_string(dupid);
  out << ", " << "hint="; (__isset.hint ? (out << to_string(hint)) : (out << "<null>"));
  out << ")";
}


duplication_modify_request::~duplication_modify_request() throw() {
}


void duplication_modify_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void duplication_modify_request::__set_dupid(const int32_t val) {
  this->dupid = val;
}

void duplication_modify_request::__set_status(const duplication_status::type val) {
  this->status = val;
__isset.status = true;
}

void duplication_modify_request::__set_fail_mode(const duplication_fail_mode::type val) {
  this->fail_mode = val;
__isset.fail_mode = true;
}

uint32_t duplication_modify_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dupid);
          this->__isset.dupid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->status = (duplication_status::type)ecast4;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->fail_mode = (duplication_fail_mode::type)ecast5;
          this->__isset.fail_mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t duplication_modify_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("duplication_modify_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dupid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->dupid);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fail_mode) {
    xfer += oprot->writeFieldBegin("fail_mode", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->fail_mode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(duplication_modify_request &a, duplication_modify_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.dupid, b.dupid);
  swap(a.status, b.status);
  swap(a.fail_mode, b.fail_mode);
  swap(a.__isset, b.__isset);
}

duplication_modify_request::duplication_modify_request(const duplication_modify_request& other6) {
  app_name = other6.app_name;
  dupid = other6.dupid;
  status = other6.status;
  fail_mode = other6.fail_mode;
  __isset = other6.__isset;
}
duplication_modify_request& duplication_modify_request::operator=(const duplication_modify_request& other7) {
  app_name = other7.app_name;
  dupid = other7.dupid;
  status = other7.status;
  fail_mode = other7.fail_mode;
  __isset = other7.__isset;
  return *this;
}
void duplication_modify_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "duplication_modify_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "dupid=" << to_string(dupid);
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ", " << "fail_mode="; (__isset.fail_mode ? (out << to_string(fail_mode)) : (out << "<null>"));
  out << ")";
}


duplication_modify_response::~duplication_modify_response() throw() {
}


void duplication_modify_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void duplication_modify_response::__set_appid(const int32_t val) {
  this->appid = val;
}

uint32_t duplication_modify_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->appid);
          this->__isset.appid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t duplication_modify_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("duplication_modify_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->appid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(duplication_modify_response &a, duplication_modify_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.appid, b.appid);
  swap(a.__isset, b.__isset);
}

duplication_modify_response::duplication_modify_response(const duplication_modify_response& other8) {
  err = other8.err;
  appid = other8.appid;
  __isset = other8.__isset;
}
duplication_modify_response& duplication_modify_response::operator=(const duplication_modify_response& other9) {
  err = other9.err;
  appid = other9.appid;
  __isset = other9.__isset;
  return *this;
}
void duplication_modify_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "duplication_modify_response(";
  out << "err=" << to_string(err);
  out << ", " << "appid=" << to_string(appid);
  out << ")";
}


duplication_entry::~duplication_entry() throw() {
}


void duplication_entry::__set_dupid(const int32_t val) {
  this->dupid = val;
}

void duplication_entry::__set_status(const duplication_status::type val) {
  this->status = val;
}

void duplication_entry::__set_remote(const std::string& val) {
  this->remote = val;
}

void duplication_entry::__set_create_ts(const int64_t val) {
  this->create_ts = val;
}

void duplication_entry::__set_progress(const std::map<int32_t, int64_t> & val) {
  this->progress = val;
__isset.progress = true;
}

void duplication_entry::__set_fail_mode(const duplication_fail_mode::type val) {
  this->fail_mode = val;
__isset.fail_mode = true;
}

uint32_t duplication_entry::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dupid);
          this->__isset.dupid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->status = (duplication_status::type)ecast10;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remote);
          this->__isset.remote = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->create_ts);
          this->__isset.create_ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->progress.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _ktype12;
            ::apache::thrift::protocol::TType _vtype13;
            xfer += iprot->readMapBegin(_ktype12, _vtype13, _size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              int32_t _key16;
              xfer += iprot->readI32(_key16);
              int64_t& _val17 = this->progress[_key16];
              xfer += iprot->readI64(_val17);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast18;
          xfer += iprot->readI32(ecast18);
          this->fail_mode = (duplication_fail_mode::type)ecast18;
          this->__isset.fail_mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t duplication_entry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("duplication_entry");

  xfer += oprot->writeFieldBegin("dupid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->dupid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->remote);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("create_ts", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->create_ts);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.progress) {
    xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->progress.size()));
      std::map<int32_t, int64_t> ::const_iterator _iter19;
      for (_iter19 = this->progress.begin(); _iter19 != this->progress.end(); ++_iter19)
      {
        xfer += oprot->writeI32(_iter19->first);
        xfer += oprot->writeI64(_iter19->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fail_mode) {
    xfer += oprot->writeFieldBegin("fail_mode", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->fail_mode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(duplication_entry &a, duplication_entry &b) {
  using ::std::swap;
  swap(a.dupid, b.dupid);
  swap(a.status, b.status);
  swap(a.remote, b.remote);
  swap(a.create_ts, b.create_ts);
  swap(a.progress, b.progress);
  swap(a.fail_mode, b.fail_mode);
  swap(a.__isset, b.__isset);
}

duplication_entry::duplication_entry(const duplication_entry& other20) {
  dupid = other20.dupid;
  status = other20.status;
  remote = other20.remote;
  create_ts = other20.create_ts;
  progress = other20.progress;
  fail_mode = other20.fail_mode;
  __isset = other20.__isset;
}
duplication_entry& duplication_entry::operator=(const duplication_entry& other21) {
  dupid = other21.dupid;
  status = other21.status;
  remote = other21.remote;
  create_ts = other21.create_ts;
  progress = other21.progress;
  fail_mode = other21.fail_mode;
  __isset = other21.__isset;
  return *this;
}
void duplication_entry::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "duplication_entry(";
  out << "dupid=" << to_string(dupid);
  out << ", " << "status=" << to_string(status);
  out << ", " << "remote=" << to_string(remote);
  out << ", " << "create_ts=" << to_string(create_ts);
  out << ", " << "progress="; (__isset.progress ? (out << to_string(progress)) : (out << "<null>"));
  out << ", " << "fail_mode="; (__isset.fail_mode ? (out << to_string(fail_mode)) : (out << "<null>"));
  out << ")";
}


duplication_query_request::~duplication_query_request() throw() {
}


void duplication_query_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

uint32_t duplication_query_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t duplication_query_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("duplication_query_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(duplication_query_request &a, duplication_query_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.__isset, b.__isset);
}

duplication_query_request::duplication_query_request(const duplication_query_request& other22) {
  app_name = other22.app_name;
  __isset = other22.__isset;
}
duplication_query_request& duplication_query_request::operator=(const duplication_query_request& other23) {
  app_name = other23.app_name;
  __isset = other23.__isset;
  return *this;
}
void duplication_query_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "duplication_query_request(";
  out << "app_name=" << to_string(app_name);
  out << ")";
}


duplication_query_response::~duplication_query_response() throw() {
}


void duplication_query_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void duplication_query_response::__set_appid(const int32_t val) {
  this->appid = val;
}

void duplication_query_response::__set_entry_list(const std::vector<duplication_entry> & val) {
  this->entry_list = val;
}

uint32_t duplication_query_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->appid);
          this->__isset.appid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->entry_list.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _etype27;
            xfer += iprot->readListBegin(_etype27, _size24);
            this->entry_list.resize(_size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              xfer += this->entry_list[_i28].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.entry_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t duplication_query_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("duplication_query_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appid", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->appid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entry_list", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->entry_list.size()));
    std::vector<duplication_entry> ::const_iterator _iter29;
    for (_iter29 = this->entry_list.begin(); _iter29 != this->entry_list.end(); ++_iter29)
    {
      xfer += (*_iter29).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(duplication_query_response &a, duplication_query_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.appid, b.appid);
  swap(a.entry_list, b.entry_list);
  swap(a.__isset, b.__isset);
}

duplication_query_response::duplication_query_response(const duplication_query_response& other30) {
  err = other30.err;
  appid = other30.appid;
  entry_list = other30.entry_list;
  __isset = other30.__isset;
}
duplication_query_response& duplication_query_response::operator=(const duplication_query_response& other31) {
  err = other31.err;
  appid = other31.appid;
  entry_list = other31.entry_list;
  __isset = other31.__isset;
  return *this;
}
void duplication_query_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "duplication_query_response(";
  out << "err=" << to_string(err);
  out << ", " << "appid=" << to_string(appid);
  out << ", " << "entry_list=" << to_string(entry_list);
  out << ")";
}


duplication_confirm_entry::~duplication_confirm_entry() throw() {
}


void duplication_confirm_entry::__set_dupid(const int32_t val) {
  this->dupid = val;
}

void duplication_confirm_entry::__set_confirmed_decree(const int64_t val) {
  this->confirmed_decree = val;
}

uint32_t duplication_confirm_entry::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dupid);
          this->__isset.dupid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->confirmed_decree);
          this->__isset.confirmed_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t duplication_confirm_entry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("duplication_confirm_entry");

  xfer += oprot->writeFieldBegin("dupid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->dupid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("confirmed_decree", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->confirmed_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(duplication_confirm_entry &a, duplication_confirm_entry &b) {
  using ::std::swap;
  swap(a.dupid, b.dupid);
  swap(a.confirmed_decree, b.confirmed_decree);
  swap(a.__isset, b.__isset);
}

duplication_confirm_entry::duplication_confirm_entry(const duplication_confirm_entry& other32) {
  dupid = other32.dupid;
  confirmed_decree = other32.confirmed_decree;
  __isset = other32.__isset;
}
duplication_confirm_entry& duplication_confirm_entry::operator=(const duplication_confirm_entry& other33) {
  dupid = other33.dupid;
  confirmed_decree = other33.confirmed_decree;
  __isset = other33.__isset;
  return *this;
}
void duplication_confirm_entry::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "duplication_confirm_entry(";
  out << "dupid=" << to_string(dupid);
  out << ", " << "confirmed_decree=" << to_string(confirmed_decree);
  out << ")";
}


duplication_sync_request::~duplication_sync_request() throw() {
}


void duplication_sync_request::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

void duplication_sync_request::__set_confirm_list(const std::map< ::dsn::gpid, std::vector<duplication_confirm_entry> > & val) {
  this->confirm_list = val;
}

uint32_t duplication_sync_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->confirm_list.clear();
            uint32_t _size34;
            ::apache::thrift::protocol::TType _ktype35;
            ::apache::thrift::protocol::TType _vtype36;
            xfer += iprot->readMapBegin(_ktype35, _vtype36, _size34);
            uint32_t _i38;
            for (_i38 = 0; _i38 < _size34; ++_i38)
            {
               ::dsn::gpid _key39;
              xfer += _key39.read(iprot);
              std::vector<duplication_confirm_entry> & _val40 = this->confirm_list[_key39];
              {
                _val40.clear();
                uint32_t _size41;
                ::apache::thrift::protocol::TType _etype44;
                xfer += iprot->readListBegin(_etype44, _size41);
                _val40.resize(_size41);
                uint32_t _i45;
                for (_i45 = 0; _i45 < _size41; ++_i45)
                {
                  xfer += _val40[_i45].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.confirm_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t duplication_sync_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("duplication_sync_request");

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("confirm_list", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->confirm_list.size()));
    std::map< ::dsn::gpid, std::vector<duplication_confirm_entry> > ::const_iterator _iter46;
    for (_iter46 = this->confirm_list.begin(); _iter46 != this->confirm_list.end(); ++_iter46)
    {
      xfer += _iter46->first.write(oprot);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter46->second.size()));
        std::vector<duplication_confirm_entry> ::const_iterator _iter47;
        for (_iter47 = _iter46->second.begin(); _iter47 != _iter46->second.end(); ++_iter47)
        {
          xfer += (*_iter47).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(duplication_sync_request &a, duplication_sync_request &b) {
  using ::std::swap;
  swap(a.node, b.node);
  swap(a.confirm_list, b.confirm_list);
  swap(a.__isset, b.__isset);
}

duplication_sync_request::duplication_sync_request(const duplication_sync_request& other48) {
  node = other48.node;
  confirm_list = other48.confirm_list;
  __isset = other48.__isset;
}
duplication_sync_request& duplication_sync_request::operator=(const duplication_sync_request& other49) {
  node = other49.node;
  confirm_list = other49.confirm_list;
  __isset = other49.__isset;
  return *this;
}
void duplication_sync_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "duplication_sync_request(";
  out << "node=" << to_string(node);
  out << ", " << "confirm_list=" << to_string(confirm_list);
  out << ")";
}


duplication_sync_response::~duplication_sync_response() throw() {
}


void duplication_sync_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void duplication_sync_response::__set_dup_map(const std::map<int32_t, std::map<int32_t, duplication_entry> > & val) {
  this->dup_map = val;
}

uint32_t duplication_sync_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->dup_map.clear();
            uint32_t _size50;
            ::apache::thrift::protocol::TType _ktype51;
            ::apache::thrift::protocol::TType _vtype52;
            xfer += iprot->readMapBegin(_ktype51, _vtype52, _size50);
            uint32_t _i54;
            for (_i54 = 0; _i54 < _size50; ++_i54)
            {
              int32_t _key55;
              xfer += iprot->readI32(_key55);
              std::map<int32_t, duplication_entry> & _val56 = this->dup_map[_key55];
              {
                _val56.clear();
                uint32_t _size57;
                ::apache::thrift::protocol::TType _ktype58;
                ::apache::thrift::protocol::TType _vtype59;
                xfer += iprot->readMapBegin(_ktype58, _vtype59, _size57);
                uint32_t _i61;
                for (_i61 = 0; _i61 < _size57; ++_i61)
                {
                  int32_t _key62;
                  xfer += iprot->readI32(_key62);
                  duplication_entry& _val63 = _val56[_key62];
                  xfer += _val63.read(iprot);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.dup_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t duplication_sync_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("duplication_sync_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dup_map", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->dup_map.size()));
    std::map<int32_t, std::map<int32_t, duplication_entry> > ::const_iterator _iter64;
    for (_iter64 = this->dup_map.begin(); _iter64 != this->dup_map.end(); ++_iter64)
    {
      xfer += oprot->writeI32(_iter64->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter64->second.size()));
        std::map<int32_t, duplication_entry> ::const_iterator _iter65;
        for (_iter65 = _iter64->second.begin(); _iter65 != _iter64->second.end(); ++_iter65)
        {
          xfer += oprot->writeI32(_iter65->first);
          xfer += _iter65->second.write(oprot);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(duplication_sync_response &a, duplication_sync_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.dup_map, b.dup_map);
  swap(a.__isset, b.__isset);
}

duplication_sync_response::duplication_sync_response(const duplication_sync_response& other66) {
  err = other66.err;
  dup_map = other66.dup_map;
  __isset = other66.__isset;
}
duplication_sync_response& duplication_sync_response::operator=(const duplication_sync_response& other67) {
  err = other67.err;
  dup_map = other67.dup_map;
  __isset = other67.__isset;
  return *this;
}
void duplication_sync_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "duplication_sync_response(";
  out << "err=" << to_string(err);
  out << ", " << "dup_map=" << to_string(dup_map);
  out << ")";
}

}} // namespace
