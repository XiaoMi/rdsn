/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include <dsn/dist/replication/replication_types.h>

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace dsn {
namespace replication {

int _kpartition_statusValues[] = {partition_status::PS_INVALID,
                                  partition_status::PS_INACTIVE,
                                  partition_status::PS_ERROR,
                                  partition_status::PS_PRIMARY,
                                  partition_status::PS_SECONDARY,
                                  partition_status::PS_POTENTIAL_SECONDARY,
                                  partition_status::PS_PARTITION_SPLIT};
const char *_kpartition_statusNames[] = {"PS_INVALID",
                                         "PS_INACTIVE",
                                         "PS_ERROR",
                                         "PS_PRIMARY",
                                         "PS_SECONDARY",
                                         "PS_POTENTIAL_SECONDARY",
                                         "PS_PARTITION_SPLIT"};
const std::map<int, const char *> _partition_status_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(7, _kpartition_statusValues, _kpartition_statusNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kread_semanticValues[] = {read_semantic::ReadInvalid,
                               read_semantic::ReadLastUpdate,
                               read_semantic::ReadOutdated,
                               read_semantic::ReadSnapshot};
const char *_kread_semanticNames[] = {
    "ReadInvalid", "ReadLastUpdate", "ReadOutdated", "ReadSnapshot"};
const std::map<int, const char *> _read_semantic_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(4, _kread_semanticValues, _kread_semanticNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _klearn_typeValues[] = {
    learn_type::LT_INVALID, learn_type::LT_CACHE, learn_type::LT_APP, learn_type::LT_LOG};
const char *_klearn_typeNames[] = {"LT_INVALID", "LT_CACHE", "LT_APP", "LT_LOG"};
const std::map<int, const char *> _learn_type_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(4, _klearn_typeValues, _klearn_typeNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _klearner_statusValues[] = {learner_status::LearningInvalid,
                                learner_status::LearningWithoutPrepare,
                                learner_status::LearningWithPrepareTransient,
                                learner_status::LearningWithPrepare,
                                learner_status::LearningSucceeded,
                                learner_status::LearningFailed};
const char *_klearner_statusNames[] = {"LearningInvalid",
                                       "LearningWithoutPrepare",
                                       "LearningWithPrepareTransient",
                                       "LearningWithPrepare",
                                       "LearningSucceeded",
                                       "LearningFailed"};
const std::map<int, const char *> _learner_status_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(6, _klearner_statusValues, _klearner_statusNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _ksplit_statusValues[] = {split_status::NOT_SPLIT,
                              split_status::SPLITTING,
                              split_status::PAUSING,
                              split_status::PAUSED,
                              split_status::CANCELING};
const char *_ksplit_statusNames[] = {"NOT_SPLIT", "SPLITTING", "PAUSING", "PAUSED", "CANCELING"};
const std::map<int, const char *> _split_status_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(5, _ksplit_statusValues, _ksplit_statusNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kconfig_typeValues[] = {config_type::CT_INVALID,
                             config_type::CT_ASSIGN_PRIMARY,
                             config_type::CT_UPGRADE_TO_PRIMARY,
                             config_type::CT_ADD_SECONDARY,
                             config_type::CT_UPGRADE_TO_SECONDARY,
                             config_type::CT_DOWNGRADE_TO_SECONDARY,
                             config_type::CT_DOWNGRADE_TO_INACTIVE,
                             config_type::CT_REMOVE,
                             config_type::CT_ADD_SECONDARY_FOR_LB,
                             config_type::CT_PRIMARY_FORCE_UPDATE_BALLOT,
                             config_type::CT_DROP_PARTITION,
                             config_type::CT_REGISTER_CHILD};
const char *_kconfig_typeNames[] = {"CT_INVALID",
                                    "CT_ASSIGN_PRIMARY",
                                    "CT_UPGRADE_TO_PRIMARY",
                                    "CT_ADD_SECONDARY",
                                    "CT_UPGRADE_TO_SECONDARY",
                                    "CT_DOWNGRADE_TO_SECONDARY",
                                    "CT_DOWNGRADE_TO_INACTIVE",
                                    "CT_REMOVE",
                                    "CT_ADD_SECONDARY_FOR_LB",
                                    "CT_PRIMARY_FORCE_UPDATE_BALLOT",
                                    "CT_DROP_PARTITION",
                                    "CT_REGISTER_CHILD"};
const std::map<int, const char *> _config_type_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(12, _kconfig_typeValues, _kconfig_typeNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _knode_statusValues[] = {
    node_status::NS_INVALID, node_status::NS_ALIVE, node_status::NS_UNALIVE};
const char *_knode_statusNames[] = {"NS_INVALID", "NS_ALIVE", "NS_UNALIVE"};
const std::map<int, const char *> _node_status_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(3, _knode_statusValues, _knode_statusNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kmeta_function_levelValues[] = {meta_function_level::fl_stopped,
                                     meta_function_level::fl_blind,
                                     meta_function_level::fl_freezed,
                                     meta_function_level::fl_steady,
                                     meta_function_level::fl_lively,
                                     meta_function_level::fl_invalid};
const char *_kmeta_function_levelNames[] = {
    "fl_stopped", "fl_blind", "fl_freezed", "fl_steady", "fl_lively", "fl_invalid"};
const std::map<int, const char *> _meta_function_level_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(6, _kmeta_function_levelValues, _kmeta_function_levelNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kbalancer_request_typeValues[] = {balancer_request_type::move_primary,
                                       balancer_request_type::copy_primary,
                                       balancer_request_type::copy_secondary};
const char *_kbalancer_request_typeNames[] = {"move_primary", "copy_primary", "copy_secondary"};
const std::map<int, const char *> _balancer_request_type_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(3, _kbalancer_request_typeValues, _kbalancer_request_typeNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kapp_env_operationValues[] = {app_env_operation::APP_ENV_OP_INVALID,
                                   app_env_operation::APP_ENV_OP_SET,
                                   app_env_operation::APP_ENV_OP_DEL,
                                   app_env_operation::APP_ENV_OP_CLEAR};
const char *_kapp_env_operationNames[] = {
    "APP_ENV_OP_INVALID", "APP_ENV_OP_SET", "APP_ENV_OP_DEL", "APP_ENV_OP_CLEAR"};
const std::map<int, const char *> _app_env_operation_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(4, _kapp_env_operationValues, _kapp_env_operationNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kduplication_statusValues[] = {duplication_status::DS_INIT,
                                    duplication_status::DS_START,
                                    duplication_status::DS_PAUSE,
                                    duplication_status::DS_REMOVED};
const char *_kduplication_statusNames[] = {"DS_INIT", "DS_START", "DS_PAUSE", "DS_REMOVED"};
const std::map<int, const char *> _duplication_status_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(4, _kduplication_statusValues, _kduplication_statusNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kduplication_fail_modeValues[] = {duplication_fail_mode::FAIL_SLOW,
                                       duplication_fail_mode::FAIL_SKIP,
                                       duplication_fail_mode::FAIL_FAST};
const char *_kduplication_fail_modeNames[] = {"FAIL_SLOW", "FAIL_SKIP", "FAIL_FAST"};
const std::map<int, const char *> _duplication_fail_mode_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(3, _kduplication_fail_modeValues, _kduplication_fail_modeNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _ksplit_control_typeValues[] = {
    split_control_type::PAUSE, split_control_type::RESTART, split_control_type::CANCEL};
const char *_ksplit_control_typeNames[] = {"PAUSE", "RESTART", "CANCEL"};
const std::map<int, const char *> _split_control_type_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(3, _ksplit_control_typeValues, _ksplit_control_typeNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kbulk_load_statusValues[] = {bulk_load_status::BLS_INVALID,
                                  bulk_load_status::BLS_DOWNLOADING,
                                  bulk_load_status::BLS_DOWNLOADED,
                                  bulk_load_status::BLS_INGESTING,
                                  bulk_load_status::BLS_SUCCEED,
                                  bulk_load_status::BLS_FAILED,
                                  bulk_load_status::BLS_PAUSING,
                                  bulk_load_status::BLS_PAUSED,
                                  bulk_load_status::BLS_CANCELED};
const char *_kbulk_load_statusNames[] = {"BLS_INVALID",
                                         "BLS_DOWNLOADING",
                                         "BLS_DOWNLOADED",
                                         "BLS_INGESTING",
                                         "BLS_SUCCEED",
                                         "BLS_FAILED",
                                         "BLS_PAUSING",
                                         "BLS_PAUSED",
                                         "BLS_CANCELED"};
const std::map<int, const char *> _bulk_load_status_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(9, _kbulk_load_statusValues, _kbulk_load_statusNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kingestion_statusValues[] = {ingestion_status::IS_INVALID,
                                  ingestion_status::IS_RUNNING,
                                  ingestion_status::IS_SUCCEED,
                                  ingestion_status::IS_FAILED};
const char *_kingestion_statusNames[] = {"IS_INVALID", "IS_RUNNING", "IS_SUCCEED", "IS_FAILED"};
const std::map<int, const char *> _ingestion_status_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(4, _kingestion_statusValues, _kingestion_statusNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kbulk_load_control_typeValues[] = {bulk_load_control_type::BLC_PAUSE,
                                        bulk_load_control_type::BLC_RESTART,
                                        bulk_load_control_type::BLC_CANCEL,
                                        bulk_load_control_type::BLC_FORCE_CANCEL};
const char *_kbulk_load_control_typeNames[] = {
    "BLC_PAUSE", "BLC_RESTART", "BLC_CANCEL", "BLC_FORCE_CANCEL"};
const std::map<int, const char *> _bulk_load_control_type_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(4,
                                    _kbulk_load_control_typeValues,
                                    _kbulk_load_control_typeNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _khotkey_typeValues[] = {hotkey_type::READ, hotkey_type::WRITE};
const char *_khotkey_typeNames[] = {"READ", "WRITE"};
const std::map<int, const char *> _hotkey_type_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(2, _khotkey_typeValues, _khotkey_typeNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kdetect_actionValues[] = {detect_action::START, detect_action::STOP, detect_action::QUERY};
const char *_kdetect_actionNames[] = {"START", "STOP", "QUERY"};
const std::map<int, const char *> _detect_action_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(3, _kdetect_actionValues, _kdetect_actionNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kdisk_migration_statusValues[] = {disk_migration_status::IDLE,
                                       disk_migration_status::MOVING,
                                       disk_migration_status::MOVED,
                                       disk_migration_status::CLOSED};
const char *_kdisk_migration_statusNames[] = {"IDLE", "MOVING", "MOVED", "CLOSED"};
const std::map<int, const char *> _disk_migration_status_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(4, _kdisk_migration_statusValues, _kdisk_migration_statusNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

mutation_header::~mutation_header() throw() {}

void mutation_header::__set_pid(const ::dsn::gpid &val) { this->pid = val; }

void mutation_header::__set_ballot(const int64_t val) { this->ballot = val; }

void mutation_header::__set_decree(const int64_t val) { this->decree = val; }

void mutation_header::__set_log_offset(const int64_t val) { this->log_offset = val; }

void mutation_header::__set_last_committed_decree(const int64_t val)
{
    this->last_committed_decree = val;
}

void mutation_header::__set_timestamp(const int64_t val) { this->timestamp = val; }

uint32_t mutation_header::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->ballot);
                this->__isset.ballot = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->decree);
                this->__isset.decree = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->log_offset);
                this->__isset.log_offset = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->last_committed_decree);
                this->__isset.last_committed_decree = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->timestamp);
                this->__isset.timestamp = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t mutation_header::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("mutation_header");

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->ballot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("decree", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->decree);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("log_offset", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->log_offset);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("last_committed_decree", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->last_committed_decree);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(mutation_header &a, mutation_header &b)
{
    using ::std::swap;
    swap(a.pid, b.pid);
    swap(a.ballot, b.ballot);
    swap(a.decree, b.decree);
    swap(a.log_offset, b.log_offset);
    swap(a.last_committed_decree, b.last_committed_decree);
    swap(a.timestamp, b.timestamp);
    swap(a.__isset, b.__isset);
}

mutation_header::mutation_header(const mutation_header &other0)
{
    pid = other0.pid;
    ballot = other0.ballot;
    decree = other0.decree;
    log_offset = other0.log_offset;
    last_committed_decree = other0.last_committed_decree;
    timestamp = other0.timestamp;
    __isset = other0.__isset;
}
mutation_header::mutation_header(mutation_header &&other1)
{
    pid = std::move(other1.pid);
    ballot = std::move(other1.ballot);
    decree = std::move(other1.decree);
    log_offset = std::move(other1.log_offset);
    last_committed_decree = std::move(other1.last_committed_decree);
    timestamp = std::move(other1.timestamp);
    __isset = std::move(other1.__isset);
}
mutation_header &mutation_header::operator=(const mutation_header &other2)
{
    pid = other2.pid;
    ballot = other2.ballot;
    decree = other2.decree;
    log_offset = other2.log_offset;
    last_committed_decree = other2.last_committed_decree;
    timestamp = other2.timestamp;
    __isset = other2.__isset;
    return *this;
}
mutation_header &mutation_header::operator=(mutation_header &&other3)
{
    pid = std::move(other3.pid);
    ballot = std::move(other3.ballot);
    decree = std::move(other3.decree);
    log_offset = std::move(other3.log_offset);
    last_committed_decree = std::move(other3.last_committed_decree);
    timestamp = std::move(other3.timestamp);
    __isset = std::move(other3.__isset);
    return *this;
}
void mutation_header::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "mutation_header(";
    out << "pid=" << to_string(pid);
    out << ", "
        << "ballot=" << to_string(ballot);
    out << ", "
        << "decree=" << to_string(decree);
    out << ", "
        << "log_offset=" << to_string(log_offset);
    out << ", "
        << "last_committed_decree=" << to_string(last_committed_decree);
    out << ", "
        << "timestamp=" << to_string(timestamp);
    out << ")";
}

mutation_update::~mutation_update() throw() {}

void mutation_update::__set_code(const ::dsn::task_code &val) { this->code = val; }

void mutation_update::__set_serialization_type(const int32_t val)
{
    this->serialization_type = val;
}

void mutation_update::__set_data(const ::dsn::blob &val) { this->data = val; }

void mutation_update::__set_start_time_ns(const int64_t val)
{
    this->start_time_ns = val;
    __isset.start_time_ns = true;
}

uint32_t mutation_update::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->code.read(iprot);
                this->__isset.code = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->serialization_type);
                this->__isset.serialization_type = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->data.read(iprot);
                this->__isset.data = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->start_time_ns);
                this->__isset.start_time_ns = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t mutation_update::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("mutation_update");

    xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->code.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("serialization_type", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->serialization_type);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->data.write(oprot);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.start_time_ns) {
        xfer += oprot->writeFieldBegin("start_time_ns", ::apache::thrift::protocol::T_I64, 4);
        xfer += oprot->writeI64(this->start_time_ns);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(mutation_update &a, mutation_update &b)
{
    using ::std::swap;
    swap(a.code, b.code);
    swap(a.serialization_type, b.serialization_type);
    swap(a.data, b.data);
    swap(a.start_time_ns, b.start_time_ns);
    swap(a.__isset, b.__isset);
}

mutation_update::mutation_update(const mutation_update &other4)
{
    code = other4.code;
    serialization_type = other4.serialization_type;
    data = other4.data;
    start_time_ns = other4.start_time_ns;
    __isset = other4.__isset;
}
mutation_update::mutation_update(mutation_update &&other5)
{
    code = std::move(other5.code);
    serialization_type = std::move(other5.serialization_type);
    data = std::move(other5.data);
    start_time_ns = std::move(other5.start_time_ns);
    __isset = std::move(other5.__isset);
}
mutation_update &mutation_update::operator=(const mutation_update &other6)
{
    code = other6.code;
    serialization_type = other6.serialization_type;
    data = other6.data;
    start_time_ns = other6.start_time_ns;
    __isset = other6.__isset;
    return *this;
}
mutation_update &mutation_update::operator=(mutation_update &&other7)
{
    code = std::move(other7.code);
    serialization_type = std::move(other7.serialization_type);
    data = std::move(other7.data);
    start_time_ns = std::move(other7.start_time_ns);
    __isset = std::move(other7.__isset);
    return *this;
}
void mutation_update::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "mutation_update(";
    out << "code=" << to_string(code);
    out << ", "
        << "serialization_type=" << to_string(serialization_type);
    out << ", "
        << "data=" << to_string(data);
    out << ", "
        << "start_time_ns=";
    (__isset.start_time_ns ? (out << to_string(start_time_ns)) : (out << "<null>"));
    out << ")";
}

mutation_data::~mutation_data() throw() {}

void mutation_data::__set_header(const mutation_header &val) { this->header = val; }

void mutation_data::__set_updates(const std::vector<mutation_update> &val) { this->updates = val; }

uint32_t mutation_data::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->header.read(iprot);
                this->__isset.header = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->updates.clear();
                    uint32_t _size8;
                    ::apache::thrift::protocol::TType _etype11;
                    xfer += iprot->readListBegin(_etype11, _size8);
                    this->updates.resize(_size8);
                    uint32_t _i12;
                    for (_i12 = 0; _i12 < _size8; ++_i12) {
                        xfer += this->updates[_i12].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.updates = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t mutation_data::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("mutation_data");

    xfer += oprot->writeFieldBegin("header", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->header.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("updates", ::apache::thrift::protocol::T_LIST, 2);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                      static_cast<uint32_t>(this->updates.size()));
        std::vector<mutation_update>::const_iterator _iter13;
        for (_iter13 = this->updates.begin(); _iter13 != this->updates.end(); ++_iter13) {
            xfer += (*_iter13).write(oprot);
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(mutation_data &a, mutation_data &b)
{
    using ::std::swap;
    swap(a.header, b.header);
    swap(a.updates, b.updates);
    swap(a.__isset, b.__isset);
}

mutation_data::mutation_data(const mutation_data &other14)
{
    header = other14.header;
    updates = other14.updates;
    __isset = other14.__isset;
}
mutation_data::mutation_data(mutation_data &&other15)
{
    header = std::move(other15.header);
    updates = std::move(other15.updates);
    __isset = std::move(other15.__isset);
}
mutation_data &mutation_data::operator=(const mutation_data &other16)
{
    header = other16.header;
    updates = other16.updates;
    __isset = other16.__isset;
    return *this;
}
mutation_data &mutation_data::operator=(mutation_data &&other17)
{
    header = std::move(other17.header);
    updates = std::move(other17.updates);
    __isset = std::move(other17.__isset);
    return *this;
}
void mutation_data::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "mutation_data(";
    out << "header=" << to_string(header);
    out << ", "
        << "updates=" << to_string(updates);
    out << ")";
}

replica_configuration::~replica_configuration() throw() {}

void replica_configuration::__set_pid(const ::dsn::gpid &val) { this->pid = val; }

void replica_configuration::__set_ballot(const int64_t val) { this->ballot = val; }

void replica_configuration::__set_primary(const ::dsn::rpc_address &val) { this->primary = val; }

void replica_configuration::__set_status(const partition_status::type val) { this->status = val; }

void replica_configuration::__set_learner_signature(const int64_t val)
{
    this->learner_signature = val;
}

void replica_configuration::__set_pop_all(const bool val)
{
    this->pop_all = val;
    __isset.pop_all = true;
}

uint32_t replica_configuration::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->ballot);
                this->__isset.ballot = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->primary.read(iprot);
                this->__isset.primary = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast18;
                xfer += iprot->readI32(ecast18);
                this->status = (partition_status::type)ecast18;
                this->__isset.status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->learner_signature);
                this->__isset.learner_signature = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->pop_all);
                this->__isset.pop_all = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t replica_configuration::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("replica_configuration");

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->ballot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("primary", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->primary.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("learner_signature", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->learner_signature);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.pop_all) {
        xfer += oprot->writeFieldBegin("pop_all", ::apache::thrift::protocol::T_BOOL, 6);
        xfer += oprot->writeBool(this->pop_all);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(replica_configuration &a, replica_configuration &b)
{
    using ::std::swap;
    swap(a.pid, b.pid);
    swap(a.ballot, b.ballot);
    swap(a.primary, b.primary);
    swap(a.status, b.status);
    swap(a.learner_signature, b.learner_signature);
    swap(a.pop_all, b.pop_all);
    swap(a.__isset, b.__isset);
}

replica_configuration::replica_configuration(const replica_configuration &other19)
{
    pid = other19.pid;
    ballot = other19.ballot;
    primary = other19.primary;
    status = other19.status;
    learner_signature = other19.learner_signature;
    pop_all = other19.pop_all;
    __isset = other19.__isset;
}
replica_configuration::replica_configuration(replica_configuration &&other20)
{
    pid = std::move(other20.pid);
    ballot = std::move(other20.ballot);
    primary = std::move(other20.primary);
    status = std::move(other20.status);
    learner_signature = std::move(other20.learner_signature);
    pop_all = std::move(other20.pop_all);
    __isset = std::move(other20.__isset);
}
replica_configuration &replica_configuration::operator=(const replica_configuration &other21)
{
    pid = other21.pid;
    ballot = other21.ballot;
    primary = other21.primary;
    status = other21.status;
    learner_signature = other21.learner_signature;
    pop_all = other21.pop_all;
    __isset = other21.__isset;
    return *this;
}
replica_configuration &replica_configuration::operator=(replica_configuration &&other22)
{
    pid = std::move(other22.pid);
    ballot = std::move(other22.ballot);
    primary = std::move(other22.primary);
    status = std::move(other22.status);
    learner_signature = std::move(other22.learner_signature);
    pop_all = std::move(other22.pop_all);
    __isset = std::move(other22.__isset);
    return *this;
}
void replica_configuration::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "replica_configuration(";
    out << "pid=" << to_string(pid);
    out << ", "
        << "ballot=" << to_string(ballot);
    out << ", "
        << "primary=" << to_string(primary);
    out << ", "
        << "status=" << to_string(status);
    out << ", "
        << "learner_signature=" << to_string(learner_signature);
    out << ", "
        << "pop_all=";
    (__isset.pop_all ? (out << to_string(pop_all)) : (out << "<null>"));
    out << ")";
}

prepare_msg::~prepare_msg() throw() {}

void prepare_msg::__set_config(const replica_configuration &val) { this->config = val; }

void prepare_msg::__set_mu(const mutation_data &val) { this->mu = val; }

uint32_t prepare_msg::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->config.read(iprot);
                this->__isset.config = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->mu.read(iprot);
                this->__isset.mu = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t prepare_msg::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("prepare_msg");

    xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->config.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("mu", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->mu.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(prepare_msg &a, prepare_msg &b)
{
    using ::std::swap;
    swap(a.config, b.config);
    swap(a.mu, b.mu);
    swap(a.__isset, b.__isset);
}

prepare_msg::prepare_msg(const prepare_msg &other23)
{
    config = other23.config;
    mu = other23.mu;
    __isset = other23.__isset;
}
prepare_msg::prepare_msg(prepare_msg &&other24)
{
    config = std::move(other24.config);
    mu = std::move(other24.mu);
    __isset = std::move(other24.__isset);
}
prepare_msg &prepare_msg::operator=(const prepare_msg &other25)
{
    config = other25.config;
    mu = other25.mu;
    __isset = other25.__isset;
    return *this;
}
prepare_msg &prepare_msg::operator=(prepare_msg &&other26)
{
    config = std::move(other26.config);
    mu = std::move(other26.mu);
    __isset = std::move(other26.__isset);
    return *this;
}
void prepare_msg::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "prepare_msg(";
    out << "config=" << to_string(config);
    out << ", "
        << "mu=" << to_string(mu);
    out << ")";
}

read_request_header::~read_request_header() throw() {}

void read_request_header::__set_pid(const ::dsn::gpid &val) { this->pid = val; }

void read_request_header::__set_code(const ::dsn::task_code &val) { this->code = val; }

void read_request_header::__set_semantic(const read_semantic::type val) { this->semantic = val; }

void read_request_header::__set_version_decree(const int64_t val) { this->version_decree = val; }

uint32_t read_request_header::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->code.read(iprot);
                this->__isset.code = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast27;
                xfer += iprot->readI32(ecast27);
                this->semantic = (read_semantic::type)ecast27;
                this->__isset.semantic = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->version_decree);
                this->__isset.version_decree = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t read_request_header::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("read_request_header");

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->code.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("semantic", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->semantic);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("version_decree", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->version_decree);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(read_request_header &a, read_request_header &b)
{
    using ::std::swap;
    swap(a.pid, b.pid);
    swap(a.code, b.code);
    swap(a.semantic, b.semantic);
    swap(a.version_decree, b.version_decree);
    swap(a.__isset, b.__isset);
}

read_request_header::read_request_header(const read_request_header &other28)
{
    pid = other28.pid;
    code = other28.code;
    semantic = other28.semantic;
    version_decree = other28.version_decree;
    __isset = other28.__isset;
}
read_request_header::read_request_header(read_request_header &&other29)
{
    pid = std::move(other29.pid);
    code = std::move(other29.code);
    semantic = std::move(other29.semantic);
    version_decree = std::move(other29.version_decree);
    __isset = std::move(other29.__isset);
}
read_request_header &read_request_header::operator=(const read_request_header &other30)
{
    pid = other30.pid;
    code = other30.code;
    semantic = other30.semantic;
    version_decree = other30.version_decree;
    __isset = other30.__isset;
    return *this;
}
read_request_header &read_request_header::operator=(read_request_header &&other31)
{
    pid = std::move(other31.pid);
    code = std::move(other31.code);
    semantic = std::move(other31.semantic);
    version_decree = std::move(other31.version_decree);
    __isset = std::move(other31.__isset);
    return *this;
}
void read_request_header::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "read_request_header(";
    out << "pid=" << to_string(pid);
    out << ", "
        << "code=" << to_string(code);
    out << ", "
        << "semantic=" << to_string(semantic);
    out << ", "
        << "version_decree=" << to_string(version_decree);
    out << ")";
}

write_request_header::~write_request_header() throw() {}

void write_request_header::__set_pid(const ::dsn::gpid &val) { this->pid = val; }

void write_request_header::__set_code(const ::dsn::task_code &val) { this->code = val; }

uint32_t write_request_header::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->code.read(iprot);
                this->__isset.code = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t write_request_header::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("write_request_header");

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->code.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(write_request_header &a, write_request_header &b)
{
    using ::std::swap;
    swap(a.pid, b.pid);
    swap(a.code, b.code);
    swap(a.__isset, b.__isset);
}

write_request_header::write_request_header(const write_request_header &other32)
{
    pid = other32.pid;
    code = other32.code;
    __isset = other32.__isset;
}
write_request_header::write_request_header(write_request_header &&other33)
{
    pid = std::move(other33.pid);
    code = std::move(other33.code);
    __isset = std::move(other33.__isset);
}
write_request_header &write_request_header::operator=(const write_request_header &other34)
{
    pid = other34.pid;
    code = other34.code;
    __isset = other34.__isset;
    return *this;
}
write_request_header &write_request_header::operator=(write_request_header &&other35)
{
    pid = std::move(other35.pid);
    code = std::move(other35.code);
    __isset = std::move(other35.__isset);
    return *this;
}
void write_request_header::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "write_request_header(";
    out << "pid=" << to_string(pid);
    out << ", "
        << "code=" << to_string(code);
    out << ")";
}

rw_response_header::~rw_response_header() throw() {}

void rw_response_header::__set_err(const ::dsn::error_code &val) { this->err = val; }

uint32_t rw_response_header::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t rw_response_header::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("rw_response_header");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(rw_response_header &a, rw_response_header &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.__isset, b.__isset);
}

rw_response_header::rw_response_header(const rw_response_header &other36)
{
    err = other36.err;
    __isset = other36.__isset;
}
rw_response_header::rw_response_header(rw_response_header &&other37)
{
    err = std::move(other37.err);
    __isset = std::move(other37.__isset);
}
rw_response_header &rw_response_header::operator=(const rw_response_header &other38)
{
    err = other38.err;
    __isset = other38.__isset;
    return *this;
}
rw_response_header &rw_response_header::operator=(rw_response_header &&other39)
{
    err = std::move(other39.err);
    __isset = std::move(other39.__isset);
    return *this;
}
void rw_response_header::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "rw_response_header(";
    out << "err=" << to_string(err);
    out << ")";
}

prepare_ack::~prepare_ack() throw() {}

void prepare_ack::__set_pid(const ::dsn::gpid &val) { this->pid = val; }

void prepare_ack::__set_err(const ::dsn::error_code &val) { this->err = val; }

void prepare_ack::__set_ballot(const int64_t val) { this->ballot = val; }

void prepare_ack::__set_decree(const int64_t val) { this->decree = val; }

void prepare_ack::__set_last_committed_decree_in_app(const int64_t val)
{
    this->last_committed_decree_in_app = val;
}

void prepare_ack::__set_last_committed_decree_in_prepare_list(const int64_t val)
{
    this->last_committed_decree_in_prepare_list = val;
}

uint32_t prepare_ack::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->ballot);
                this->__isset.ballot = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->decree);
                this->__isset.decree = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->last_committed_decree_in_app);
                this->__isset.last_committed_decree_in_app = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->last_committed_decree_in_prepare_list);
                this->__isset.last_committed_decree_in_prepare_list = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t prepare_ack::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("prepare_ack");

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->ballot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("decree", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->decree);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin(
        "last_committed_decree_in_app", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->last_committed_decree_in_app);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin(
        "last_committed_decree_in_prepare_list", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->last_committed_decree_in_prepare_list);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(prepare_ack &a, prepare_ack &b)
{
    using ::std::swap;
    swap(a.pid, b.pid);
    swap(a.err, b.err);
    swap(a.ballot, b.ballot);
    swap(a.decree, b.decree);
    swap(a.last_committed_decree_in_app, b.last_committed_decree_in_app);
    swap(a.last_committed_decree_in_prepare_list, b.last_committed_decree_in_prepare_list);
    swap(a.__isset, b.__isset);
}

prepare_ack::prepare_ack(const prepare_ack &other40)
{
    pid = other40.pid;
    err = other40.err;
    ballot = other40.ballot;
    decree = other40.decree;
    last_committed_decree_in_app = other40.last_committed_decree_in_app;
    last_committed_decree_in_prepare_list = other40.last_committed_decree_in_prepare_list;
    __isset = other40.__isset;
}
prepare_ack::prepare_ack(prepare_ack &&other41)
{
    pid = std::move(other41.pid);
    err = std::move(other41.err);
    ballot = std::move(other41.ballot);
    decree = std::move(other41.decree);
    last_committed_decree_in_app = std::move(other41.last_committed_decree_in_app);
    last_committed_decree_in_prepare_list =
        std::move(other41.last_committed_decree_in_prepare_list);
    __isset = std::move(other41.__isset);
}
prepare_ack &prepare_ack::operator=(const prepare_ack &other42)
{
    pid = other42.pid;
    err = other42.err;
    ballot = other42.ballot;
    decree = other42.decree;
    last_committed_decree_in_app = other42.last_committed_decree_in_app;
    last_committed_decree_in_prepare_list = other42.last_committed_decree_in_prepare_list;
    __isset = other42.__isset;
    return *this;
}
prepare_ack &prepare_ack::operator=(prepare_ack &&other43)
{
    pid = std::move(other43.pid);
    err = std::move(other43.err);
    ballot = std::move(other43.ballot);
    decree = std::move(other43.decree);
    last_committed_decree_in_app = std::move(other43.last_committed_decree_in_app);
    last_committed_decree_in_prepare_list =
        std::move(other43.last_committed_decree_in_prepare_list);
    __isset = std::move(other43.__isset);
    return *this;
}
void prepare_ack::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "prepare_ack(";
    out << "pid=" << to_string(pid);
    out << ", "
        << "err=" << to_string(err);
    out << ", "
        << "ballot=" << to_string(ballot);
    out << ", "
        << "decree=" << to_string(decree);
    out << ", "
        << "last_committed_decree_in_app=" << to_string(last_committed_decree_in_app);
    out << ", "
        << "last_committed_decree_in_prepare_list="
        << to_string(last_committed_decree_in_prepare_list);
    out << ")";
}

learn_state::~learn_state() throw() {}

void learn_state::__set_from_decree_excluded(const int64_t val)
{
    this->from_decree_excluded = val;
}

void learn_state::__set_to_decree_included(const int64_t val) { this->to_decree_included = val; }

void learn_state::__set_meta(const ::dsn::blob &val) { this->meta = val; }

void learn_state::__set_files(const std::vector<std::string> &val) { this->files = val; }

void learn_state::__set_learn_start_decree(const int64_t val)
{
    this->learn_start_decree = val;
    __isset.learn_start_decree = true;
}

uint32_t learn_state::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->from_decree_excluded);
                this->__isset.from_decree_excluded = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->to_decree_included);
                this->__isset.to_decree_included = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->meta.read(iprot);
                this->__isset.meta = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->files.clear();
                    uint32_t _size44;
                    ::apache::thrift::protocol::TType _etype47;
                    xfer += iprot->readListBegin(_etype47, _size44);
                    this->files.resize(_size44);
                    uint32_t _i48;
                    for (_i48 = 0; _i48 < _size44; ++_i48) {
                        xfer += iprot->readString(this->files[_i48]);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.files = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->learn_start_decree);
                this->__isset.learn_start_decree = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t learn_state::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("learn_state");

    xfer += oprot->writeFieldBegin("from_decree_excluded", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->from_decree_excluded);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("to_decree_included", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->to_decree_included);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("meta", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->meta.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_LIST, 4);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING,
                                      static_cast<uint32_t>(this->files.size()));
        std::vector<std::string>::const_iterator _iter49;
        for (_iter49 = this->files.begin(); _iter49 != this->files.end(); ++_iter49) {
            xfer += oprot->writeString((*_iter49));
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    if (this->__isset.learn_start_decree) {
        xfer += oprot->writeFieldBegin("learn_start_decree", ::apache::thrift::protocol::T_I64, 5);
        xfer += oprot->writeI64(this->learn_start_decree);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(learn_state &a, learn_state &b)
{
    using ::std::swap;
    swap(a.from_decree_excluded, b.from_decree_excluded);
    swap(a.to_decree_included, b.to_decree_included);
    swap(a.meta, b.meta);
    swap(a.files, b.files);
    swap(a.learn_start_decree, b.learn_start_decree);
    swap(a.__isset, b.__isset);
}

learn_state::learn_state(const learn_state &other50)
{
    from_decree_excluded = other50.from_decree_excluded;
    to_decree_included = other50.to_decree_included;
    meta = other50.meta;
    files = other50.files;
    learn_start_decree = other50.learn_start_decree;
    __isset = other50.__isset;
}
learn_state::learn_state(learn_state &&other51)
{
    from_decree_excluded = std::move(other51.from_decree_excluded);
    to_decree_included = std::move(other51.to_decree_included);
    meta = std::move(other51.meta);
    files = std::move(other51.files);
    learn_start_decree = std::move(other51.learn_start_decree);
    __isset = std::move(other51.__isset);
}
learn_state &learn_state::operator=(const learn_state &other52)
{
    from_decree_excluded = other52.from_decree_excluded;
    to_decree_included = other52.to_decree_included;
    meta = other52.meta;
    files = other52.files;
    learn_start_decree = other52.learn_start_decree;
    __isset = other52.__isset;
    return *this;
}
learn_state &learn_state::operator=(learn_state &&other53)
{
    from_decree_excluded = std::move(other53.from_decree_excluded);
    to_decree_included = std::move(other53.to_decree_included);
    meta = std::move(other53.meta);
    files = std::move(other53.files);
    learn_start_decree = std::move(other53.learn_start_decree);
    __isset = std::move(other53.__isset);
    return *this;
}
void learn_state::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "learn_state(";
    out << "from_decree_excluded=" << to_string(from_decree_excluded);
    out << ", "
        << "to_decree_included=" << to_string(to_decree_included);
    out << ", "
        << "meta=" << to_string(meta);
    out << ", "
        << "files=" << to_string(files);
    out << ", "
        << "learn_start_decree=";
    (__isset.learn_start_decree ? (out << to_string(learn_start_decree)) : (out << "<null>"));
    out << ")";
}

learn_request::~learn_request() throw() {}

void learn_request::__set_pid(const ::dsn::gpid &val) { this->pid = val; }

void learn_request::__set_learner(const ::dsn::rpc_address &val) { this->learner = val; }

void learn_request::__set_signature(const int64_t val) { this->signature = val; }

void learn_request::__set_last_committed_decree_in_app(const int64_t val)
{
    this->last_committed_decree_in_app = val;
}

void learn_request::__set_last_committed_decree_in_prepare_list(const int64_t val)
{
    this->last_committed_decree_in_prepare_list = val;
}

void learn_request::__set_app_specific_learn_request(const ::dsn::blob &val)
{
    this->app_specific_learn_request = val;
}

void learn_request::__set_max_gced_decree(const int64_t val)
{
    this->max_gced_decree = val;
    __isset.max_gced_decree = true;
}

uint32_t learn_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->learner.read(iprot);
                this->__isset.learner = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->signature);
                this->__isset.signature = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->last_committed_decree_in_app);
                this->__isset.last_committed_decree_in_app = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->last_committed_decree_in_prepare_list);
                this->__isset.last_committed_decree_in_prepare_list = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->app_specific_learn_request.read(iprot);
                this->__isset.app_specific_learn_request = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 7:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->max_gced_decree);
                this->__isset.max_gced_decree = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t learn_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("learn_request");

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("learner", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->learner.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->signature);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin(
        "last_committed_decree_in_app", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->last_committed_decree_in_app);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin(
        "last_committed_decree_in_prepare_list", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->last_committed_decree_in_prepare_list);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin(
        "app_specific_learn_request", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->app_specific_learn_request.write(oprot);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.max_gced_decree) {
        xfer += oprot->writeFieldBegin("max_gced_decree", ::apache::thrift::protocol::T_I64, 7);
        xfer += oprot->writeI64(this->max_gced_decree);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(learn_request &a, learn_request &b)
{
    using ::std::swap;
    swap(a.pid, b.pid);
    swap(a.learner, b.learner);
    swap(a.signature, b.signature);
    swap(a.last_committed_decree_in_app, b.last_committed_decree_in_app);
    swap(a.last_committed_decree_in_prepare_list, b.last_committed_decree_in_prepare_list);
    swap(a.app_specific_learn_request, b.app_specific_learn_request);
    swap(a.max_gced_decree, b.max_gced_decree);
    swap(a.__isset, b.__isset);
}

learn_request::learn_request(const learn_request &other54)
{
    pid = other54.pid;
    learner = other54.learner;
    signature = other54.signature;
    last_committed_decree_in_app = other54.last_committed_decree_in_app;
    last_committed_decree_in_prepare_list = other54.last_committed_decree_in_prepare_list;
    app_specific_learn_request = other54.app_specific_learn_request;
    max_gced_decree = other54.max_gced_decree;
    __isset = other54.__isset;
}
learn_request::learn_request(learn_request &&other55)
{
    pid = std::move(other55.pid);
    learner = std::move(other55.learner);
    signature = std::move(other55.signature);
    last_committed_decree_in_app = std::move(other55.last_committed_decree_in_app);
    last_committed_decree_in_prepare_list =
        std::move(other55.last_committed_decree_in_prepare_list);
    app_specific_learn_request = std::move(other55.app_specific_learn_request);
    max_gced_decree = std::move(other55.max_gced_decree);
    __isset = std::move(other55.__isset);
}
learn_request &learn_request::operator=(const learn_request &other56)
{
    pid = other56.pid;
    learner = other56.learner;
    signature = other56.signature;
    last_committed_decree_in_app = other56.last_committed_decree_in_app;
    last_committed_decree_in_prepare_list = other56.last_committed_decree_in_prepare_list;
    app_specific_learn_request = other56.app_specific_learn_request;
    max_gced_decree = other56.max_gced_decree;
    __isset = other56.__isset;
    return *this;
}
learn_request &learn_request::operator=(learn_request &&other57)
{
    pid = std::move(other57.pid);
    learner = std::move(other57.learner);
    signature = std::move(other57.signature);
    last_committed_decree_in_app = std::move(other57.last_committed_decree_in_app);
    last_committed_decree_in_prepare_list =
        std::move(other57.last_committed_decree_in_prepare_list);
    app_specific_learn_request = std::move(other57.app_specific_learn_request);
    max_gced_decree = std::move(other57.max_gced_decree);
    __isset = std::move(other57.__isset);
    return *this;
}
void learn_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "learn_request(";
    out << "pid=" << to_string(pid);
    out << ", "
        << "learner=" << to_string(learner);
    out << ", "
        << "signature=" << to_string(signature);
    out << ", "
        << "last_committed_decree_in_app=" << to_string(last_committed_decree_in_app);
    out << ", "
        << "last_committed_decree_in_prepare_list="
        << to_string(last_committed_decree_in_prepare_list);
    out << ", "
        << "app_specific_learn_request=" << to_string(app_specific_learn_request);
    out << ", "
        << "max_gced_decree=";
    (__isset.max_gced_decree ? (out << to_string(max_gced_decree)) : (out << "<null>"));
    out << ")";
}

learn_response::~learn_response() throw() {}

void learn_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void learn_response::__set_config(const replica_configuration &val) { this->config = val; }

void learn_response::__set_last_committed_decree(const int64_t val)
{
    this->last_committed_decree = val;
}

void learn_response::__set_prepare_start_decree(const int64_t val)
{
    this->prepare_start_decree = val;
}

void learn_response::__set_type(const learn_type::type val) { this->type = val; }

void learn_response::__set_state(const learn_state &val) { this->state = val; }

void learn_response::__set_address(const ::dsn::rpc_address &val) { this->address = val; }

void learn_response::__set_base_local_dir(const std::string &val) { this->base_local_dir = val; }

uint32_t learn_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->config.read(iprot);
                this->__isset.config = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->last_committed_decree);
                this->__isset.last_committed_decree = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->prepare_start_decree);
                this->__isset.prepare_start_decree = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast58;
                xfer += iprot->readI32(ecast58);
                this->type = (learn_type::type)ecast58;
                this->__isset.type = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->state.read(iprot);
                this->__isset.state = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 7:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->address.read(iprot);
                this->__isset.address = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 8:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->base_local_dir);
                this->__isset.base_local_dir = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t learn_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("learn_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->config.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("last_committed_decree", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->last_committed_decree);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("prepare_start_decree", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->prepare_start_decree);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->state.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->address.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("base_local_dir", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->base_local_dir);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(learn_response &a, learn_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.config, b.config);
    swap(a.last_committed_decree, b.last_committed_decree);
    swap(a.prepare_start_decree, b.prepare_start_decree);
    swap(a.type, b.type);
    swap(a.state, b.state);
    swap(a.address, b.address);
    swap(a.base_local_dir, b.base_local_dir);
    swap(a.__isset, b.__isset);
}

learn_response::learn_response(const learn_response &other59)
{
    err = other59.err;
    config = other59.config;
    last_committed_decree = other59.last_committed_decree;
    prepare_start_decree = other59.prepare_start_decree;
    type = other59.type;
    state = other59.state;
    address = other59.address;
    base_local_dir = other59.base_local_dir;
    __isset = other59.__isset;
}
learn_response::learn_response(learn_response &&other60)
{
    err = std::move(other60.err);
    config = std::move(other60.config);
    last_committed_decree = std::move(other60.last_committed_decree);
    prepare_start_decree = std::move(other60.prepare_start_decree);
    type = std::move(other60.type);
    state = std::move(other60.state);
    address = std::move(other60.address);
    base_local_dir = std::move(other60.base_local_dir);
    __isset = std::move(other60.__isset);
}
learn_response &learn_response::operator=(const learn_response &other61)
{
    err = other61.err;
    config = other61.config;
    last_committed_decree = other61.last_committed_decree;
    prepare_start_decree = other61.prepare_start_decree;
    type = other61.type;
    state = other61.state;
    address = other61.address;
    base_local_dir = other61.base_local_dir;
    __isset = other61.__isset;
    return *this;
}
learn_response &learn_response::operator=(learn_response &&other62)
{
    err = std::move(other62.err);
    config = std::move(other62.config);
    last_committed_decree = std::move(other62.last_committed_decree);
    prepare_start_decree = std::move(other62.prepare_start_decree);
    type = std::move(other62.type);
    state = std::move(other62.state);
    address = std::move(other62.address);
    base_local_dir = std::move(other62.base_local_dir);
    __isset = std::move(other62.__isset);
    return *this;
}
void learn_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "learn_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "config=" << to_string(config);
    out << ", "
        << "last_committed_decree=" << to_string(last_committed_decree);
    out << ", "
        << "prepare_start_decree=" << to_string(prepare_start_decree);
    out << ", "
        << "type=" << to_string(type);
    out << ", "
        << "state=" << to_string(state);
    out << ", "
        << "address=" << to_string(address);
    out << ", "
        << "base_local_dir=" << to_string(base_local_dir);
    out << ")";
}

learn_notify_response::~learn_notify_response() throw() {}

void learn_notify_response::__set_pid(const ::dsn::gpid &val) { this->pid = val; }

void learn_notify_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void learn_notify_response::__set_signature(const int64_t val) { this->signature = val; }

uint32_t learn_notify_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->signature);
                this->__isset.signature = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t learn_notify_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("learn_notify_response");

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->signature);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(learn_notify_response &a, learn_notify_response &b)
{
    using ::std::swap;
    swap(a.pid, b.pid);
    swap(a.err, b.err);
    swap(a.signature, b.signature);
    swap(a.__isset, b.__isset);
}

learn_notify_response::learn_notify_response(const learn_notify_response &other63)
{
    pid = other63.pid;
    err = other63.err;
    signature = other63.signature;
    __isset = other63.__isset;
}
learn_notify_response::learn_notify_response(learn_notify_response &&other64)
{
    pid = std::move(other64.pid);
    err = std::move(other64.err);
    signature = std::move(other64.signature);
    __isset = std::move(other64.__isset);
}
learn_notify_response &learn_notify_response::operator=(const learn_notify_response &other65)
{
    pid = other65.pid;
    err = other65.err;
    signature = other65.signature;
    __isset = other65.__isset;
    return *this;
}
learn_notify_response &learn_notify_response::operator=(learn_notify_response &&other66)
{
    pid = std::move(other66.pid);
    err = std::move(other66.err);
    signature = std::move(other66.signature);
    __isset = std::move(other66.__isset);
    return *this;
}
void learn_notify_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "learn_notify_response(";
    out << "pid=" << to_string(pid);
    out << ", "
        << "err=" << to_string(err);
    out << ", "
        << "signature=" << to_string(signature);
    out << ")";
}

group_check_request::~group_check_request() throw() {}

void group_check_request::__set_app(const ::dsn::app_info &val) { this->app = val; }

void group_check_request::__set_node(const ::dsn::rpc_address &val) { this->node = val; }

void group_check_request::__set_config(const replica_configuration &val) { this->config = val; }

void group_check_request::__set_last_committed_decree(const int64_t val)
{
    this->last_committed_decree = val;
}

void group_check_request::__set_confirmed_decree(const int64_t val)
{
    this->confirmed_decree = val;
    __isset.confirmed_decree = true;
}

void group_check_request::__set_child_gpid(const ::dsn::gpid &val)
{
    this->child_gpid = val;
    __isset.child_gpid = true;
}

void group_check_request::__set_meta_split_status(const split_status::type val)
{
    this->meta_split_status = val;
    __isset.meta_split_status = true;
}

uint32_t group_check_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->app.read(iprot);
                this->__isset.app = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->node.read(iprot);
                this->__isset.node = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->config.read(iprot);
                this->__isset.config = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->last_committed_decree);
                this->__isset.last_committed_decree = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->confirmed_decree);
                this->__isset.confirmed_decree = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->child_gpid.read(iprot);
                this->__isset.child_gpid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 7:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast67;
                xfer += iprot->readI32(ecast67);
                this->meta_split_status = (split_status::type)ecast67;
                this->__isset.meta_split_status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t group_check_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("group_check_request");

    xfer += oprot->writeFieldBegin("app", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->app.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->node.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->config.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("last_committed_decree", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->last_committed_decree);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.confirmed_decree) {
        xfer += oprot->writeFieldBegin("confirmed_decree", ::apache::thrift::protocol::T_I64, 5);
        xfer += oprot->writeI64(this->confirmed_decree);
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.child_gpid) {
        xfer += oprot->writeFieldBegin("child_gpid", ::apache::thrift::protocol::T_STRUCT, 6);
        xfer += this->child_gpid.write(oprot);
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.meta_split_status) {
        xfer += oprot->writeFieldBegin("meta_split_status", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32((int32_t)this->meta_split_status);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(group_check_request &a, group_check_request &b)
{
    using ::std::swap;
    swap(a.app, b.app);
    swap(a.node, b.node);
    swap(a.config, b.config);
    swap(a.last_committed_decree, b.last_committed_decree);
    swap(a.confirmed_decree, b.confirmed_decree);
    swap(a.child_gpid, b.child_gpid);
    swap(a.meta_split_status, b.meta_split_status);
    swap(a.__isset, b.__isset);
}

group_check_request::group_check_request(const group_check_request &other68)
{
    app = other68.app;
    node = other68.node;
    config = other68.config;
    last_committed_decree = other68.last_committed_decree;
    confirmed_decree = other68.confirmed_decree;
    child_gpid = other68.child_gpid;
    meta_split_status = other68.meta_split_status;
    __isset = other68.__isset;
}
group_check_request::group_check_request(group_check_request &&other69)
{
    app = std::move(other69.app);
    node = std::move(other69.node);
    config = std::move(other69.config);
    last_committed_decree = std::move(other69.last_committed_decree);
    confirmed_decree = std::move(other69.confirmed_decree);
    child_gpid = std::move(other69.child_gpid);
    meta_split_status = std::move(other69.meta_split_status);
    __isset = std::move(other69.__isset);
}
group_check_request &group_check_request::operator=(const group_check_request &other70)
{
    app = other70.app;
    node = other70.node;
    config = other70.config;
    last_committed_decree = other70.last_committed_decree;
    confirmed_decree = other70.confirmed_decree;
    child_gpid = other70.child_gpid;
    meta_split_status = other70.meta_split_status;
    __isset = other70.__isset;
    return *this;
}
group_check_request &group_check_request::operator=(group_check_request &&other71)
{
    app = std::move(other71.app);
    node = std::move(other71.node);
    config = std::move(other71.config);
    last_committed_decree = std::move(other71.last_committed_decree);
    confirmed_decree = std::move(other71.confirmed_decree);
    child_gpid = std::move(other71.child_gpid);
    meta_split_status = std::move(other71.meta_split_status);
    __isset = std::move(other71.__isset);
    return *this;
}
void group_check_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "group_check_request(";
    out << "app=" << to_string(app);
    out << ", "
        << "node=" << to_string(node);
    out << ", "
        << "config=" << to_string(config);
    out << ", "
        << "last_committed_decree=" << to_string(last_committed_decree);
    out << ", "
        << "confirmed_decree=";
    (__isset.confirmed_decree ? (out << to_string(confirmed_decree)) : (out << "<null>"));
    out << ", "
        << "child_gpid=";
    (__isset.child_gpid ? (out << to_string(child_gpid)) : (out << "<null>"));
    out << ", "
        << "meta_split_status=";
    (__isset.meta_split_status ? (out << to_string(meta_split_status)) : (out << "<null>"));
    out << ")";
}

group_check_response::~group_check_response() throw() {}

void group_check_response::__set_pid(const ::dsn::gpid &val) { this->pid = val; }

void group_check_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void group_check_response::__set_last_committed_decree_in_app(const int64_t val)
{
    this->last_committed_decree_in_app = val;
}

void group_check_response::__set_last_committed_decree_in_prepare_list(const int64_t val)
{
    this->last_committed_decree_in_prepare_list = val;
}

void group_check_response::__set_learner_status_(const learner_status::type val)
{
    this->learner_status_ = val;
}

void group_check_response::__set_learner_signature(const int64_t val)
{
    this->learner_signature = val;
}

void group_check_response::__set_node(const ::dsn::rpc_address &val) { this->node = val; }

void group_check_response::__set_is_split_stopped(const bool val)
{
    this->is_split_stopped = val;
    __isset.is_split_stopped = true;
}

uint32_t group_check_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->last_committed_decree_in_app);
                this->__isset.last_committed_decree_in_app = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->last_committed_decree_in_prepare_list);
                this->__isset.last_committed_decree_in_prepare_list = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast72;
                xfer += iprot->readI32(ecast72);
                this->learner_status_ = (learner_status::type)ecast72;
                this->__isset.learner_status_ = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->learner_signature);
                this->__isset.learner_signature = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 7:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->node.read(iprot);
                this->__isset.node = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 8:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->is_split_stopped);
                this->__isset.is_split_stopped = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t group_check_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("group_check_response");

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin(
        "last_committed_decree_in_app", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->last_committed_decree_in_app);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin(
        "last_committed_decree_in_prepare_list", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->last_committed_decree_in_prepare_list);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("learner_status_", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->learner_status_);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("learner_signature", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->learner_signature);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->node.write(oprot);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.is_split_stopped) {
        xfer += oprot->writeFieldBegin("is_split_stopped", ::apache::thrift::protocol::T_BOOL, 8);
        xfer += oprot->writeBool(this->is_split_stopped);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(group_check_response &a, group_check_response &b)
{
    using ::std::swap;
    swap(a.pid, b.pid);
    swap(a.err, b.err);
    swap(a.last_committed_decree_in_app, b.last_committed_decree_in_app);
    swap(a.last_committed_decree_in_prepare_list, b.last_committed_decree_in_prepare_list);
    swap(a.learner_status_, b.learner_status_);
    swap(a.learner_signature, b.learner_signature);
    swap(a.node, b.node);
    swap(a.is_split_stopped, b.is_split_stopped);
    swap(a.__isset, b.__isset);
}

group_check_response::group_check_response(const group_check_response &other73)
{
    pid = other73.pid;
    err = other73.err;
    last_committed_decree_in_app = other73.last_committed_decree_in_app;
    last_committed_decree_in_prepare_list = other73.last_committed_decree_in_prepare_list;
    learner_status_ = other73.learner_status_;
    learner_signature = other73.learner_signature;
    node = other73.node;
    is_split_stopped = other73.is_split_stopped;
    __isset = other73.__isset;
}
group_check_response::group_check_response(group_check_response &&other74)
{
    pid = std::move(other74.pid);
    err = std::move(other74.err);
    last_committed_decree_in_app = std::move(other74.last_committed_decree_in_app);
    last_committed_decree_in_prepare_list =
        std::move(other74.last_committed_decree_in_prepare_list);
    learner_status_ = std::move(other74.learner_status_);
    learner_signature = std::move(other74.learner_signature);
    node = std::move(other74.node);
    is_split_stopped = std::move(other74.is_split_stopped);
    __isset = std::move(other74.__isset);
}
group_check_response &group_check_response::operator=(const group_check_response &other75)
{
    pid = other75.pid;
    err = other75.err;
    last_committed_decree_in_app = other75.last_committed_decree_in_app;
    last_committed_decree_in_prepare_list = other75.last_committed_decree_in_prepare_list;
    learner_status_ = other75.learner_status_;
    learner_signature = other75.learner_signature;
    node = other75.node;
    is_split_stopped = other75.is_split_stopped;
    __isset = other75.__isset;
    return *this;
}
group_check_response &group_check_response::operator=(group_check_response &&other76)
{
    pid = std::move(other76.pid);
    err = std::move(other76.err);
    last_committed_decree_in_app = std::move(other76.last_committed_decree_in_app);
    last_committed_decree_in_prepare_list =
        std::move(other76.last_committed_decree_in_prepare_list);
    learner_status_ = std::move(other76.learner_status_);
    learner_signature = std::move(other76.learner_signature);
    node = std::move(other76.node);
    is_split_stopped = std::move(other76.is_split_stopped);
    __isset = std::move(other76.__isset);
    return *this;
}
void group_check_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "group_check_response(";
    out << "pid=" << to_string(pid);
    out << ", "
        << "err=" << to_string(err);
    out << ", "
        << "last_committed_decree_in_app=" << to_string(last_committed_decree_in_app);
    out << ", "
        << "last_committed_decree_in_prepare_list="
        << to_string(last_committed_decree_in_prepare_list);
    out << ", "
        << "learner_status_=" << to_string(learner_status_);
    out << ", "
        << "learner_signature=" << to_string(learner_signature);
    out << ", "
        << "node=" << to_string(node);
    out << ", "
        << "is_split_stopped=";
    (__isset.is_split_stopped ? (out << to_string(is_split_stopped)) : (out << "<null>"));
    out << ")";
}

node_info::~node_info() throw() {}

void node_info::__set_status(const node_status::type val) { this->status = val; }

void node_info::__set_address(const ::dsn::rpc_address &val) { this->address = val; }

uint32_t node_info::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast77;
                xfer += iprot->readI32(ecast77);
                this->status = (node_status::type)ecast77;
                this->__isset.status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->address.read(iprot);
                this->__isset.address = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t node_info::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("node_info");

    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->address.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(node_info &a, node_info &b)
{
    using ::std::swap;
    swap(a.status, b.status);
    swap(a.address, b.address);
    swap(a.__isset, b.__isset);
}

node_info::node_info(const node_info &other78)
{
    status = other78.status;
    address = other78.address;
    __isset = other78.__isset;
}
node_info::node_info(node_info &&other79)
{
    status = std::move(other79.status);
    address = std::move(other79.address);
    __isset = std::move(other79.__isset);
}
node_info &node_info::operator=(const node_info &other80)
{
    status = other80.status;
    address = other80.address;
    __isset = other80.__isset;
    return *this;
}
node_info &node_info::operator=(node_info &&other81)
{
    status = std::move(other81.status);
    address = std::move(other81.address);
    __isset = std::move(other81.__isset);
    return *this;
}
void node_info::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "node_info(";
    out << "status=" << to_string(status);
    out << ", "
        << "address=" << to_string(address);
    out << ")";
}

configuration_update_request::~configuration_update_request() throw() {}

void configuration_update_request::__set_info(const ::dsn::app_info &val) { this->info = val; }

void configuration_update_request::__set_config(const ::dsn::partition_configuration &val)
{
    this->config = val;
}

void configuration_update_request::__set_type(const config_type::type val) { this->type = val; }

void configuration_update_request::__set_node(const ::dsn::rpc_address &val) { this->node = val; }

void configuration_update_request::__set_host_node(const ::dsn::rpc_address &val)
{
    this->host_node = val;
}

void configuration_update_request::__set_meta_split_status(const split_status::type val)
{
    this->meta_split_status = val;
    __isset.meta_split_status = true;
}

uint32_t configuration_update_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->info.read(iprot);
                this->__isset.info = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->config.read(iprot);
                this->__isset.config = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast82;
                xfer += iprot->readI32(ecast82);
                this->type = (config_type::type)ecast82;
                this->__isset.type = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->node.read(iprot);
                this->__isset.node = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->host_node.read(iprot);
                this->__isset.host_node = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast83;
                xfer += iprot->readI32(ecast83);
                this->meta_split_status = (split_status::type)ecast83;
                this->__isset.meta_split_status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_update_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_update_request");

    xfer += oprot->writeFieldBegin("info", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->info.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->config.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->node.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("host_node", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->host_node.write(oprot);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.meta_split_status) {
        xfer += oprot->writeFieldBegin("meta_split_status", ::apache::thrift::protocol::T_I32, 6);
        xfer += oprot->writeI32((int32_t)this->meta_split_status);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_update_request &a, configuration_update_request &b)
{
    using ::std::swap;
    swap(a.info, b.info);
    swap(a.config, b.config);
    swap(a.type, b.type);
    swap(a.node, b.node);
    swap(a.host_node, b.host_node);
    swap(a.meta_split_status, b.meta_split_status);
    swap(a.__isset, b.__isset);
}

configuration_update_request::configuration_update_request(
    const configuration_update_request &other84)
{
    info = other84.info;
    config = other84.config;
    type = other84.type;
    node = other84.node;
    host_node = other84.host_node;
    meta_split_status = other84.meta_split_status;
    __isset = other84.__isset;
}
configuration_update_request::configuration_update_request(configuration_update_request &&other85)
{
    info = std::move(other85.info);
    config = std::move(other85.config);
    type = std::move(other85.type);
    node = std::move(other85.node);
    host_node = std::move(other85.host_node);
    meta_split_status = std::move(other85.meta_split_status);
    __isset = std::move(other85.__isset);
}
configuration_update_request &configuration_update_request::
operator=(const configuration_update_request &other86)
{
    info = other86.info;
    config = other86.config;
    type = other86.type;
    node = other86.node;
    host_node = other86.host_node;
    meta_split_status = other86.meta_split_status;
    __isset = other86.__isset;
    return *this;
}
configuration_update_request &configuration_update_request::
operator=(configuration_update_request &&other87)
{
    info = std::move(other87.info);
    config = std::move(other87.config);
    type = std::move(other87.type);
    node = std::move(other87.node);
    host_node = std::move(other87.host_node);
    meta_split_status = std::move(other87.meta_split_status);
    __isset = std::move(other87.__isset);
    return *this;
}
void configuration_update_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_update_request(";
    out << "info=" << to_string(info);
    out << ", "
        << "config=" << to_string(config);
    out << ", "
        << "type=" << to_string(type);
    out << ", "
        << "node=" << to_string(node);
    out << ", "
        << "host_node=" << to_string(host_node);
    out << ", "
        << "meta_split_status=";
    (__isset.meta_split_status ? (out << to_string(meta_split_status)) : (out << "<null>"));
    out << ")";
}

configuration_update_response::~configuration_update_response() throw() {}

void configuration_update_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void configuration_update_response::__set_config(const ::dsn::partition_configuration &val)
{
    this->config = val;
}

uint32_t configuration_update_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->config.read(iprot);
                this->__isset.config = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_update_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_update_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->config.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_update_response &a, configuration_update_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.config, b.config);
    swap(a.__isset, b.__isset);
}

configuration_update_response::configuration_update_response(
    const configuration_update_response &other88)
{
    err = other88.err;
    config = other88.config;
    __isset = other88.__isset;
}
configuration_update_response::configuration_update_response(
    configuration_update_response &&other89)
{
    err = std::move(other89.err);
    config = std::move(other89.config);
    __isset = std::move(other89.__isset);
}
configuration_update_response &configuration_update_response::
operator=(const configuration_update_response &other90)
{
    err = other90.err;
    config = other90.config;
    __isset = other90.__isset;
    return *this;
}
configuration_update_response &configuration_update_response::
operator=(configuration_update_response &&other91)
{
    err = std::move(other91.err);
    config = std::move(other91.config);
    __isset = std::move(other91.__isset);
    return *this;
}
void configuration_update_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_update_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "config=" << to_string(config);
    out << ")";
}

replica_server_info::~replica_server_info() throw() {}

void replica_server_info::__set_geo_tags(const std::map<std::string, std::string> &val)
{
    this->geo_tags = val;
}

void replica_server_info::__set_total_capacity_mb(const int64_t val)
{
    this->total_capacity_mb = val;
}

uint32_t replica_server_info::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_MAP) {
                {
                    this->geo_tags.clear();
                    uint32_t _size92;
                    ::apache::thrift::protocol::TType _ktype93;
                    ::apache::thrift::protocol::TType _vtype94;
                    xfer += iprot->readMapBegin(_ktype93, _vtype94, _size92);
                    uint32_t _i96;
                    for (_i96 = 0; _i96 < _size92; ++_i96) {
                        std::string _key97;
                        xfer += iprot->readString(_key97);
                        std::string &_val98 = this->geo_tags[_key97];
                        xfer += iprot->readString(_val98);
                    }
                    xfer += iprot->readMapEnd();
                }
                this->__isset.geo_tags = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->total_capacity_mb);
                this->__isset.total_capacity_mb = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t replica_server_info::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("replica_server_info");

    xfer += oprot->writeFieldBegin("geo_tags", ::apache::thrift::protocol::T_MAP, 1);
    {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING,
                                     ::apache::thrift::protocol::T_STRING,
                                     static_cast<uint32_t>(this->geo_tags.size()));
        std::map<std::string, std::string>::const_iterator _iter99;
        for (_iter99 = this->geo_tags.begin(); _iter99 != this->geo_tags.end(); ++_iter99) {
            xfer += oprot->writeString(_iter99->first);
            xfer += oprot->writeString(_iter99->second);
        }
        xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("total_capacity_mb", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->total_capacity_mb);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(replica_server_info &a, replica_server_info &b)
{
    using ::std::swap;
    swap(a.geo_tags, b.geo_tags);
    swap(a.total_capacity_mb, b.total_capacity_mb);
    swap(a.__isset, b.__isset);
}

replica_server_info::replica_server_info(const replica_server_info &other100)
{
    geo_tags = other100.geo_tags;
    total_capacity_mb = other100.total_capacity_mb;
    __isset = other100.__isset;
}
replica_server_info::replica_server_info(replica_server_info &&other101)
{
    geo_tags = std::move(other101.geo_tags);
    total_capacity_mb = std::move(other101.total_capacity_mb);
    __isset = std::move(other101.__isset);
}
replica_server_info &replica_server_info::operator=(const replica_server_info &other102)
{
    geo_tags = other102.geo_tags;
    total_capacity_mb = other102.total_capacity_mb;
    __isset = other102.__isset;
    return *this;
}
replica_server_info &replica_server_info::operator=(replica_server_info &&other103)
{
    geo_tags = std::move(other103.geo_tags);
    total_capacity_mb = std::move(other103.total_capacity_mb);
    __isset = std::move(other103.__isset);
    return *this;
}
void replica_server_info::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "replica_server_info(";
    out << "geo_tags=" << to_string(geo_tags);
    out << ", "
        << "total_capacity_mb=" << to_string(total_capacity_mb);
    out << ")";
}

configuration_query_by_node_request::~configuration_query_by_node_request() throw() {}

void configuration_query_by_node_request::__set_node(const ::dsn::rpc_address &val)
{
    this->node = val;
}

void configuration_query_by_node_request::__set_stored_replicas(
    const std::vector<replica_info> &val)
{
    this->stored_replicas = val;
    __isset.stored_replicas = true;
}

void configuration_query_by_node_request::__set_info(const replica_server_info &val)
{
    this->info = val;
    __isset.info = true;
}

uint32_t configuration_query_by_node_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->node.read(iprot);
                this->__isset.node = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->stored_replicas.clear();
                    uint32_t _size104;
                    ::apache::thrift::protocol::TType _etype107;
                    xfer += iprot->readListBegin(_etype107, _size104);
                    this->stored_replicas.resize(_size104);
                    uint32_t _i108;
                    for (_i108 = 0; _i108 < _size104; ++_i108) {
                        xfer += this->stored_replicas[_i108].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.stored_replicas = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->info.read(iprot);
                this->__isset.info = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t
configuration_query_by_node_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_query_by_node_request");

    xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->node.write(oprot);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.stored_replicas) {
        xfer += oprot->writeFieldBegin("stored_replicas", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                          static_cast<uint32_t>(this->stored_replicas.size()));
            std::vector<replica_info>::const_iterator _iter109;
            for (_iter109 = this->stored_replicas.begin(); _iter109 != this->stored_replicas.end();
                 ++_iter109) {
                xfer += (*_iter109).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.info) {
        xfer += oprot->writeFieldBegin("info", ::apache::thrift::protocol::T_STRUCT, 3);
        xfer += this->info.write(oprot);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_query_by_node_request &a, configuration_query_by_node_request &b)
{
    using ::std::swap;
    swap(a.node, b.node);
    swap(a.stored_replicas, b.stored_replicas);
    swap(a.info, b.info);
    swap(a.__isset, b.__isset);
}

configuration_query_by_node_request::configuration_query_by_node_request(
    const configuration_query_by_node_request &other110)
{
    node = other110.node;
    stored_replicas = other110.stored_replicas;
    info = other110.info;
    __isset = other110.__isset;
}
configuration_query_by_node_request::configuration_query_by_node_request(
    configuration_query_by_node_request &&other111)
{
    node = std::move(other111.node);
    stored_replicas = std::move(other111.stored_replicas);
    info = std::move(other111.info);
    __isset = std::move(other111.__isset);
}
configuration_query_by_node_request &configuration_query_by_node_request::
operator=(const configuration_query_by_node_request &other112)
{
    node = other112.node;
    stored_replicas = other112.stored_replicas;
    info = other112.info;
    __isset = other112.__isset;
    return *this;
}
configuration_query_by_node_request &configuration_query_by_node_request::
operator=(configuration_query_by_node_request &&other113)
{
    node = std::move(other113.node);
    stored_replicas = std::move(other113.stored_replicas);
    info = std::move(other113.info);
    __isset = std::move(other113.__isset);
    return *this;
}
void configuration_query_by_node_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_query_by_node_request(";
    out << "node=" << to_string(node);
    out << ", "
        << "stored_replicas=";
    (__isset.stored_replicas ? (out << to_string(stored_replicas)) : (out << "<null>"));
    out << ", "
        << "info=";
    (__isset.info ? (out << to_string(info)) : (out << "<null>"));
    out << ")";
}

configuration_query_by_node_response::~configuration_query_by_node_response() throw() {}

void configuration_query_by_node_response::__set_err(const ::dsn::error_code &val)
{
    this->err = val;
}

void configuration_query_by_node_response::__set_partitions(
    const std::vector<configuration_update_request> &val)
{
    this->partitions = val;
}

void configuration_query_by_node_response::__set_gc_replicas(const std::vector<replica_info> &val)
{
    this->gc_replicas = val;
    __isset.gc_replicas = true;
}

uint32_t configuration_query_by_node_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->partitions.clear();
                    uint32_t _size114;
                    ::apache::thrift::protocol::TType _etype117;
                    xfer += iprot->readListBegin(_etype117, _size114);
                    this->partitions.resize(_size114);
                    uint32_t _i118;
                    for (_i118 = 0; _i118 < _size114; ++_i118) {
                        xfer += this->partitions[_i118].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.partitions = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->gc_replicas.clear();
                    uint32_t _size119;
                    ::apache::thrift::protocol::TType _etype122;
                    xfer += iprot->readListBegin(_etype122, _size119);
                    this->gc_replicas.resize(_size119);
                    uint32_t _i123;
                    for (_i123 = 0; _i123 < _size119; ++_i123) {
                        xfer += this->gc_replicas[_i123].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.gc_replicas = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t
configuration_query_by_node_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_query_by_node_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 2);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                      static_cast<uint32_t>(this->partitions.size()));
        std::vector<configuration_update_request>::const_iterator _iter124;
        for (_iter124 = this->partitions.begin(); _iter124 != this->partitions.end(); ++_iter124) {
            xfer += (*_iter124).write(oprot);
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    if (this->__isset.gc_replicas) {
        xfer += oprot->writeFieldBegin("gc_replicas", ::apache::thrift::protocol::T_LIST, 3);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                          static_cast<uint32_t>(this->gc_replicas.size()));
            std::vector<replica_info>::const_iterator _iter125;
            for (_iter125 = this->gc_replicas.begin(); _iter125 != this->gc_replicas.end();
                 ++_iter125) {
                xfer += (*_iter125).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_query_by_node_response &a, configuration_query_by_node_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.partitions, b.partitions);
    swap(a.gc_replicas, b.gc_replicas);
    swap(a.__isset, b.__isset);
}

configuration_query_by_node_response::configuration_query_by_node_response(
    const configuration_query_by_node_response &other126)
{
    err = other126.err;
    partitions = other126.partitions;
    gc_replicas = other126.gc_replicas;
    __isset = other126.__isset;
}
configuration_query_by_node_response::configuration_query_by_node_response(
    configuration_query_by_node_response &&other127)
{
    err = std::move(other127.err);
    partitions = std::move(other127.partitions);
    gc_replicas = std::move(other127.gc_replicas);
    __isset = std::move(other127.__isset);
}
configuration_query_by_node_response &configuration_query_by_node_response::
operator=(const configuration_query_by_node_response &other128)
{
    err = other128.err;
    partitions = other128.partitions;
    gc_replicas = other128.gc_replicas;
    __isset = other128.__isset;
    return *this;
}
configuration_query_by_node_response &configuration_query_by_node_response::
operator=(configuration_query_by_node_response &&other129)
{
    err = std::move(other129.err);
    partitions = std::move(other129.partitions);
    gc_replicas = std::move(other129.gc_replicas);
    __isset = std::move(other129.__isset);
    return *this;
}
void configuration_query_by_node_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_query_by_node_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "partitions=" << to_string(partitions);
    out << ", "
        << "gc_replicas=";
    (__isset.gc_replicas ? (out << to_string(gc_replicas)) : (out << "<null>"));
    out << ")";
}

create_app_options::~create_app_options() throw() {}

void create_app_options::__set_partition_count(const int32_t val) { this->partition_count = val; }

void create_app_options::__set_replica_count(const int32_t val) { this->replica_count = val; }

void create_app_options::__set_success_if_exist(const bool val) { this->success_if_exist = val; }

void create_app_options::__set_app_type(const std::string &val) { this->app_type = val; }

void create_app_options::__set_is_stateful(const bool val) { this->is_stateful = val; }

void create_app_options::__set_envs(const std::map<std::string, std::string> &val)
{
    this->envs = val;
}

uint32_t create_app_options::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->partition_count);
                this->__isset.partition_count = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->replica_count);
                this->__isset.replica_count = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->success_if_exist);
                this->__isset.success_if_exist = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_type);
                this->__isset.app_type = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->is_stateful);
                this->__isset.is_stateful = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_MAP) {
                {
                    this->envs.clear();
                    uint32_t _size130;
                    ::apache::thrift::protocol::TType _ktype131;
                    ::apache::thrift::protocol::TType _vtype132;
                    xfer += iprot->readMapBegin(_ktype131, _vtype132, _size130);
                    uint32_t _i134;
                    for (_i134 = 0; _i134 < _size130; ++_i134) {
                        std::string _key135;
                        xfer += iprot->readString(_key135);
                        std::string &_val136 = this->envs[_key135];
                        xfer += iprot->readString(_val136);
                    }
                    xfer += iprot->readMapEnd();
                }
                this->__isset.envs = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t create_app_options::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("create_app_options");

    xfer += oprot->writeFieldBegin("partition_count", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->partition_count);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("replica_count", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->replica_count);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("success_if_exist", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->success_if_exist);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("app_type", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->app_type);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("is_stateful", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->is_stateful);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("envs", ::apache::thrift::protocol::T_MAP, 6);
    {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING,
                                     ::apache::thrift::protocol::T_STRING,
                                     static_cast<uint32_t>(this->envs.size()));
        std::map<std::string, std::string>::const_iterator _iter137;
        for (_iter137 = this->envs.begin(); _iter137 != this->envs.end(); ++_iter137) {
            xfer += oprot->writeString(_iter137->first);
            xfer += oprot->writeString(_iter137->second);
        }
        xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(create_app_options &a, create_app_options &b)
{
    using ::std::swap;
    swap(a.partition_count, b.partition_count);
    swap(a.replica_count, b.replica_count);
    swap(a.success_if_exist, b.success_if_exist);
    swap(a.app_type, b.app_type);
    swap(a.is_stateful, b.is_stateful);
    swap(a.envs, b.envs);
    swap(a.__isset, b.__isset);
}

create_app_options::create_app_options(const create_app_options &other138)
{
    partition_count = other138.partition_count;
    replica_count = other138.replica_count;
    success_if_exist = other138.success_if_exist;
    app_type = other138.app_type;
    is_stateful = other138.is_stateful;
    envs = other138.envs;
    __isset = other138.__isset;
}
create_app_options::create_app_options(create_app_options &&other139)
{
    partition_count = std::move(other139.partition_count);
    replica_count = std::move(other139.replica_count);
    success_if_exist = std::move(other139.success_if_exist);
    app_type = std::move(other139.app_type);
    is_stateful = std::move(other139.is_stateful);
    envs = std::move(other139.envs);
    __isset = std::move(other139.__isset);
}
create_app_options &create_app_options::operator=(const create_app_options &other140)
{
    partition_count = other140.partition_count;
    replica_count = other140.replica_count;
    success_if_exist = other140.success_if_exist;
    app_type = other140.app_type;
    is_stateful = other140.is_stateful;
    envs = other140.envs;
    __isset = other140.__isset;
    return *this;
}
create_app_options &create_app_options::operator=(create_app_options &&other141)
{
    partition_count = std::move(other141.partition_count);
    replica_count = std::move(other141.replica_count);
    success_if_exist = std::move(other141.success_if_exist);
    app_type = std::move(other141.app_type);
    is_stateful = std::move(other141.is_stateful);
    envs = std::move(other141.envs);
    __isset = std::move(other141.__isset);
    return *this;
}
void create_app_options::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "create_app_options(";
    out << "partition_count=" << to_string(partition_count);
    out << ", "
        << "replica_count=" << to_string(replica_count);
    out << ", "
        << "success_if_exist=" << to_string(success_if_exist);
    out << ", "
        << "app_type=" << to_string(app_type);
    out << ", "
        << "is_stateful=" << to_string(is_stateful);
    out << ", "
        << "envs=" << to_string(envs);
    out << ")";
}

configuration_create_app_request::~configuration_create_app_request() throw() {}

void configuration_create_app_request::__set_app_name(const std::string &val)
{
    this->app_name = val;
}

void configuration_create_app_request::__set_options(const create_app_options &val)
{
    this->options = val;
}

uint32_t configuration_create_app_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->options.read(iprot);
                this->__isset.options = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_create_app_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_create_app_request");

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->options.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_create_app_request &a, configuration_create_app_request &b)
{
    using ::std::swap;
    swap(a.app_name, b.app_name);
    swap(a.options, b.options);
    swap(a.__isset, b.__isset);
}

configuration_create_app_request::configuration_create_app_request(
    const configuration_create_app_request &other142)
{
    app_name = other142.app_name;
    options = other142.options;
    __isset = other142.__isset;
}
configuration_create_app_request::configuration_create_app_request(
    configuration_create_app_request &&other143)
{
    app_name = std::move(other143.app_name);
    options = std::move(other143.options);
    __isset = std::move(other143.__isset);
}
configuration_create_app_request &configuration_create_app_request::
operator=(const configuration_create_app_request &other144)
{
    app_name = other144.app_name;
    options = other144.options;
    __isset = other144.__isset;
    return *this;
}
configuration_create_app_request &configuration_create_app_request::
operator=(configuration_create_app_request &&other145)
{
    app_name = std::move(other145.app_name);
    options = std::move(other145.options);
    __isset = std::move(other145.__isset);
    return *this;
}
void configuration_create_app_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_create_app_request(";
    out << "app_name=" << to_string(app_name);
    out << ", "
        << "options=" << to_string(options);
    out << ")";
}

drop_app_options::~drop_app_options() throw() {}

void drop_app_options::__set_success_if_not_exist(const bool val)
{
    this->success_if_not_exist = val;
}

void drop_app_options::__set_reserve_seconds(const int64_t val)
{
    this->reserve_seconds = val;
    __isset.reserve_seconds = true;
}

uint32_t drop_app_options::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->success_if_not_exist);
                this->__isset.success_if_not_exist = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->reserve_seconds);
                this->__isset.reserve_seconds = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t drop_app_options::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("drop_app_options");

    xfer += oprot->writeFieldBegin("success_if_not_exist", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->success_if_not_exist);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.reserve_seconds) {
        xfer += oprot->writeFieldBegin("reserve_seconds", ::apache::thrift::protocol::T_I64, 2);
        xfer += oprot->writeI64(this->reserve_seconds);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(drop_app_options &a, drop_app_options &b)
{
    using ::std::swap;
    swap(a.success_if_not_exist, b.success_if_not_exist);
    swap(a.reserve_seconds, b.reserve_seconds);
    swap(a.__isset, b.__isset);
}

drop_app_options::drop_app_options(const drop_app_options &other146)
{
    success_if_not_exist = other146.success_if_not_exist;
    reserve_seconds = other146.reserve_seconds;
    __isset = other146.__isset;
}
drop_app_options::drop_app_options(drop_app_options &&other147)
{
    success_if_not_exist = std::move(other147.success_if_not_exist);
    reserve_seconds = std::move(other147.reserve_seconds);
    __isset = std::move(other147.__isset);
}
drop_app_options &drop_app_options::operator=(const drop_app_options &other148)
{
    success_if_not_exist = other148.success_if_not_exist;
    reserve_seconds = other148.reserve_seconds;
    __isset = other148.__isset;
    return *this;
}
drop_app_options &drop_app_options::operator=(drop_app_options &&other149)
{
    success_if_not_exist = std::move(other149.success_if_not_exist);
    reserve_seconds = std::move(other149.reserve_seconds);
    __isset = std::move(other149.__isset);
    return *this;
}
void drop_app_options::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "drop_app_options(";
    out << "success_if_not_exist=" << to_string(success_if_not_exist);
    out << ", "
        << "reserve_seconds=";
    (__isset.reserve_seconds ? (out << to_string(reserve_seconds)) : (out << "<null>"));
    out << ")";
}

configuration_drop_app_request::~configuration_drop_app_request() throw() {}

void configuration_drop_app_request::__set_app_name(const std::string &val)
{
    this->app_name = val;
}

void configuration_drop_app_request::__set_options(const drop_app_options &val)
{
    this->options = val;
}

uint32_t configuration_drop_app_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->options.read(iprot);
                this->__isset.options = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_drop_app_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_drop_app_request");

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->options.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_drop_app_request &a, configuration_drop_app_request &b)
{
    using ::std::swap;
    swap(a.app_name, b.app_name);
    swap(a.options, b.options);
    swap(a.__isset, b.__isset);
}

configuration_drop_app_request::configuration_drop_app_request(
    const configuration_drop_app_request &other150)
{
    app_name = other150.app_name;
    options = other150.options;
    __isset = other150.__isset;
}
configuration_drop_app_request::configuration_drop_app_request(
    configuration_drop_app_request &&other151)
{
    app_name = std::move(other151.app_name);
    options = std::move(other151.options);
    __isset = std::move(other151.__isset);
}
configuration_drop_app_request &configuration_drop_app_request::
operator=(const configuration_drop_app_request &other152)
{
    app_name = other152.app_name;
    options = other152.options;
    __isset = other152.__isset;
    return *this;
}
configuration_drop_app_request &configuration_drop_app_request::
operator=(configuration_drop_app_request &&other153)
{
    app_name = std::move(other153.app_name);
    options = std::move(other153.options);
    __isset = std::move(other153.__isset);
    return *this;
}
void configuration_drop_app_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_drop_app_request(";
    out << "app_name=" << to_string(app_name);
    out << ", "
        << "options=" << to_string(options);
    out << ")";
}

configuration_list_apps_request::~configuration_list_apps_request() throw() {}

void configuration_list_apps_request::__set_status(const ::dsn::app_status::type val)
{
    this->status = val;
}

uint32_t configuration_list_apps_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast154;
                xfer += iprot->readI32(ecast154);
                this->status = (::dsn::app_status::type)ecast154;
                this->__isset.status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_list_apps_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_list_apps_request");

    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_list_apps_request &a, configuration_list_apps_request &b)
{
    using ::std::swap;
    swap(a.status, b.status);
    swap(a.__isset, b.__isset);
}

configuration_list_apps_request::configuration_list_apps_request(
    const configuration_list_apps_request &other155)
{
    status = other155.status;
    __isset = other155.__isset;
}
configuration_list_apps_request::configuration_list_apps_request(
    configuration_list_apps_request &&other156)
{
    status = std::move(other156.status);
    __isset = std::move(other156.__isset);
}
configuration_list_apps_request &configuration_list_apps_request::
operator=(const configuration_list_apps_request &other157)
{
    status = other157.status;
    __isset = other157.__isset;
    return *this;
}
configuration_list_apps_request &configuration_list_apps_request::
operator=(configuration_list_apps_request &&other158)
{
    status = std::move(other158.status);
    __isset = std::move(other158.__isset);
    return *this;
}
void configuration_list_apps_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_list_apps_request(";
    out << "status=" << to_string(status);
    out << ")";
}

configuration_list_nodes_request::~configuration_list_nodes_request() throw() {}

void configuration_list_nodes_request::__set_status(const node_status::type val)
{
    this->status = val;
}

uint32_t configuration_list_nodes_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast159;
                xfer += iprot->readI32(ecast159);
                this->status = (node_status::type)ecast159;
                this->__isset.status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_list_nodes_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_list_nodes_request");

    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_list_nodes_request &a, configuration_list_nodes_request &b)
{
    using ::std::swap;
    swap(a.status, b.status);
    swap(a.__isset, b.__isset);
}

configuration_list_nodes_request::configuration_list_nodes_request(
    const configuration_list_nodes_request &other160)
{
    status = other160.status;
    __isset = other160.__isset;
}
configuration_list_nodes_request::configuration_list_nodes_request(
    configuration_list_nodes_request &&other161)
{
    status = std::move(other161.status);
    __isset = std::move(other161.__isset);
}
configuration_list_nodes_request &configuration_list_nodes_request::
operator=(const configuration_list_nodes_request &other162)
{
    status = other162.status;
    __isset = other162.__isset;
    return *this;
}
configuration_list_nodes_request &configuration_list_nodes_request::
operator=(configuration_list_nodes_request &&other163)
{
    status = std::move(other163.status);
    __isset = std::move(other163.__isset);
    return *this;
}
void configuration_list_nodes_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_list_nodes_request(";
    out << "status=" << to_string(status);
    out << ")";
}

configuration_cluster_info_request::~configuration_cluster_info_request() throw() {}

uint32_t configuration_cluster_info_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        xfer += iprot->skip(ftype);
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t
configuration_cluster_info_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_cluster_info_request");

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_cluster_info_request &a, configuration_cluster_info_request &b)
{
    using ::std::swap;
    (void)a;
    (void)b;
}

configuration_cluster_info_request::configuration_cluster_info_request(
    const configuration_cluster_info_request &other164)
{
    (void)other164;
}
configuration_cluster_info_request::configuration_cluster_info_request(
    configuration_cluster_info_request &&other165)
{
    (void)other165;
}
configuration_cluster_info_request &configuration_cluster_info_request::
operator=(const configuration_cluster_info_request &other166)
{
    (void)other166;
    return *this;
}
configuration_cluster_info_request &configuration_cluster_info_request::
operator=(configuration_cluster_info_request &&other167)
{
    (void)other167;
    return *this;
}
void configuration_cluster_info_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_cluster_info_request(";
    out << ")";
}

configuration_recall_app_request::~configuration_recall_app_request() throw() {}

void configuration_recall_app_request::__set_app_id(const int32_t val) { this->app_id = val; }

void configuration_recall_app_request::__set_new_app_name(const std::string &val)
{
    this->new_app_name = val;
}

uint32_t configuration_recall_app_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->app_id);
                this->__isset.app_id = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->new_app_name);
                this->__isset.new_app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_recall_app_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_recall_app_request");

    xfer += oprot->writeFieldBegin("app_id", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->app_id);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("new_app_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->new_app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_recall_app_request &a, configuration_recall_app_request &b)
{
    using ::std::swap;
    swap(a.app_id, b.app_id);
    swap(a.new_app_name, b.new_app_name);
    swap(a.__isset, b.__isset);
}

configuration_recall_app_request::configuration_recall_app_request(
    const configuration_recall_app_request &other168)
{
    app_id = other168.app_id;
    new_app_name = other168.new_app_name;
    __isset = other168.__isset;
}
configuration_recall_app_request::configuration_recall_app_request(
    configuration_recall_app_request &&other169)
{
    app_id = std::move(other169.app_id);
    new_app_name = std::move(other169.new_app_name);
    __isset = std::move(other169.__isset);
}
configuration_recall_app_request &configuration_recall_app_request::
operator=(const configuration_recall_app_request &other170)
{
    app_id = other170.app_id;
    new_app_name = other170.new_app_name;
    __isset = other170.__isset;
    return *this;
}
configuration_recall_app_request &configuration_recall_app_request::
operator=(configuration_recall_app_request &&other171)
{
    app_id = std::move(other171.app_id);
    new_app_name = std::move(other171.new_app_name);
    __isset = std::move(other171.__isset);
    return *this;
}
void configuration_recall_app_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_recall_app_request(";
    out << "app_id=" << to_string(app_id);
    out << ", "
        << "new_app_name=" << to_string(new_app_name);
    out << ")";
}

configuration_create_app_response::~configuration_create_app_response() throw() {}

void configuration_create_app_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void configuration_create_app_response::__set_appid(const int32_t val) { this->appid = val; }

uint32_t configuration_create_app_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->appid);
                this->__isset.appid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t
configuration_create_app_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_create_app_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("appid", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->appid);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_create_app_response &a, configuration_create_app_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.appid, b.appid);
    swap(a.__isset, b.__isset);
}

configuration_create_app_response::configuration_create_app_response(
    const configuration_create_app_response &other172)
{
    err = other172.err;
    appid = other172.appid;
    __isset = other172.__isset;
}
configuration_create_app_response::configuration_create_app_response(
    configuration_create_app_response &&other173)
{
    err = std::move(other173.err);
    appid = std::move(other173.appid);
    __isset = std::move(other173.__isset);
}
configuration_create_app_response &configuration_create_app_response::
operator=(const configuration_create_app_response &other174)
{
    err = other174.err;
    appid = other174.appid;
    __isset = other174.__isset;
    return *this;
}
configuration_create_app_response &configuration_create_app_response::
operator=(configuration_create_app_response &&other175)
{
    err = std::move(other175.err);
    appid = std::move(other175.appid);
    __isset = std::move(other175.__isset);
    return *this;
}
void configuration_create_app_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_create_app_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "appid=" << to_string(appid);
    out << ")";
}

configuration_meta_control_request::~configuration_meta_control_request() throw() {}

void configuration_meta_control_request::__set_level(const meta_function_level::type val)
{
    this->level = val;
}

uint32_t configuration_meta_control_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast176;
                xfer += iprot->readI32(ecast176);
                this->level = (meta_function_level::type)ecast176;
                this->__isset.level = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t
configuration_meta_control_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_meta_control_request");

    xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->level);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_meta_control_request &a, configuration_meta_control_request &b)
{
    using ::std::swap;
    swap(a.level, b.level);
    swap(a.__isset, b.__isset);
}

configuration_meta_control_request::configuration_meta_control_request(
    const configuration_meta_control_request &other177)
{
    level = other177.level;
    __isset = other177.__isset;
}
configuration_meta_control_request::configuration_meta_control_request(
    configuration_meta_control_request &&other178)
{
    level = std::move(other178.level);
    __isset = std::move(other178.__isset);
}
configuration_meta_control_request &configuration_meta_control_request::
operator=(const configuration_meta_control_request &other179)
{
    level = other179.level;
    __isset = other179.__isset;
    return *this;
}
configuration_meta_control_request &configuration_meta_control_request::
operator=(configuration_meta_control_request &&other180)
{
    level = std::move(other180.level);
    __isset = std::move(other180.__isset);
    return *this;
}
void configuration_meta_control_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_meta_control_request(";
    out << "level=" << to_string(level);
    out << ")";
}

configuration_meta_control_response::~configuration_meta_control_response() throw() {}

void configuration_meta_control_response::__set_err(const ::dsn::error_code &val)
{
    this->err = val;
}

void configuration_meta_control_response::__set_old_level(const meta_function_level::type val)
{
    this->old_level = val;
}

uint32_t configuration_meta_control_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast181;
                xfer += iprot->readI32(ecast181);
                this->old_level = (meta_function_level::type)ecast181;
                this->__isset.old_level = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t
configuration_meta_control_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_meta_control_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("old_level", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->old_level);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_meta_control_response &a, configuration_meta_control_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.old_level, b.old_level);
    swap(a.__isset, b.__isset);
}

configuration_meta_control_response::configuration_meta_control_response(
    const configuration_meta_control_response &other182)
{
    err = other182.err;
    old_level = other182.old_level;
    __isset = other182.__isset;
}
configuration_meta_control_response::configuration_meta_control_response(
    configuration_meta_control_response &&other183)
{
    err = std::move(other183.err);
    old_level = std::move(other183.old_level);
    __isset = std::move(other183.__isset);
}
configuration_meta_control_response &configuration_meta_control_response::
operator=(const configuration_meta_control_response &other184)
{
    err = other184.err;
    old_level = other184.old_level;
    __isset = other184.__isset;
    return *this;
}
configuration_meta_control_response &configuration_meta_control_response::
operator=(configuration_meta_control_response &&other185)
{
    err = std::move(other185.err);
    old_level = std::move(other185.old_level);
    __isset = std::move(other185.__isset);
    return *this;
}
void configuration_meta_control_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_meta_control_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "old_level=" << to_string(old_level);
    out << ")";
}

configuration_proposal_action::~configuration_proposal_action() throw() {}

void configuration_proposal_action::__set_target(const ::dsn::rpc_address &val)
{
    this->target = val;
}

void configuration_proposal_action::__set_node(const ::dsn::rpc_address &val) { this->node = val; }

void configuration_proposal_action::__set_type(const config_type::type val) { this->type = val; }

uint32_t configuration_proposal_action::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->target.read(iprot);
                this->__isset.target = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->node.read(iprot);
                this->__isset.node = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast186;
                xfer += iprot->readI32(ecast186);
                this->type = (config_type::type)ecast186;
                this->__isset.type = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_proposal_action::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_proposal_action");

    xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->target.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->node.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_proposal_action &a, configuration_proposal_action &b)
{
    using ::std::swap;
    swap(a.target, b.target);
    swap(a.node, b.node);
    swap(a.type, b.type);
    swap(a.__isset, b.__isset);
}

configuration_proposal_action::configuration_proposal_action(
    const configuration_proposal_action &other187)
{
    target = other187.target;
    node = other187.node;
    type = other187.type;
    __isset = other187.__isset;
}
configuration_proposal_action::configuration_proposal_action(
    configuration_proposal_action &&other188)
{
    target = std::move(other188.target);
    node = std::move(other188.node);
    type = std::move(other188.type);
    __isset = std::move(other188.__isset);
}
configuration_proposal_action &configuration_proposal_action::
operator=(const configuration_proposal_action &other189)
{
    target = other189.target;
    node = other189.node;
    type = other189.type;
    __isset = other189.__isset;
    return *this;
}
configuration_proposal_action &configuration_proposal_action::
operator=(configuration_proposal_action &&other190)
{
    target = std::move(other190.target);
    node = std::move(other190.node);
    type = std::move(other190.type);
    __isset = std::move(other190.__isset);
    return *this;
}
void configuration_proposal_action::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_proposal_action(";
    out << "target=" << to_string(target);
    out << ", "
        << "node=" << to_string(node);
    out << ", "
        << "type=" << to_string(type);
    out << ")";
}

configuration_balancer_request::~configuration_balancer_request() throw() {}

void configuration_balancer_request::__set_gpid(const ::dsn::gpid &val) { this->gpid = val; }

void configuration_balancer_request::__set_action_list(
    const std::vector<configuration_proposal_action> &val)
{
    this->action_list = val;
}

void configuration_balancer_request::__set_force(const bool val)
{
    this->force = val;
    __isset.force = true;
}

void configuration_balancer_request::__set_balance_type(const balancer_request_type::type val)
{
    this->balance_type = val;
    __isset.balance_type = true;
}

uint32_t configuration_balancer_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->gpid.read(iprot);
                this->__isset.gpid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->action_list.clear();
                    uint32_t _size191;
                    ::apache::thrift::protocol::TType _etype194;
                    xfer += iprot->readListBegin(_etype194, _size191);
                    this->action_list.resize(_size191);
                    uint32_t _i195;
                    for (_i195 = 0; _i195 < _size191; ++_i195) {
                        xfer += this->action_list[_i195].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.action_list = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->force);
                this->__isset.force = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast196;
                xfer += iprot->readI32(ecast196);
                this->balance_type = (balancer_request_type::type)ecast196;
                this->__isset.balance_type = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_balancer_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_balancer_request");

    xfer += oprot->writeFieldBegin("gpid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->gpid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("action_list", ::apache::thrift::protocol::T_LIST, 2);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                      static_cast<uint32_t>(this->action_list.size()));
        std::vector<configuration_proposal_action>::const_iterator _iter197;
        for (_iter197 = this->action_list.begin(); _iter197 != this->action_list.end();
             ++_iter197) {
            xfer += (*_iter197).write(oprot);
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    if (this->__isset.force) {
        xfer += oprot->writeFieldBegin("force", ::apache::thrift::protocol::T_BOOL, 3);
        xfer += oprot->writeBool(this->force);
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.balance_type) {
        xfer += oprot->writeFieldBegin("balance_type", ::apache::thrift::protocol::T_I32, 4);
        xfer += oprot->writeI32((int32_t)this->balance_type);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_balancer_request &a, configuration_balancer_request &b)
{
    using ::std::swap;
    swap(a.gpid, b.gpid);
    swap(a.action_list, b.action_list);
    swap(a.force, b.force);
    swap(a.balance_type, b.balance_type);
    swap(a.__isset, b.__isset);
}

configuration_balancer_request::configuration_balancer_request(
    const configuration_balancer_request &other198)
{
    gpid = other198.gpid;
    action_list = other198.action_list;
    force = other198.force;
    balance_type = other198.balance_type;
    __isset = other198.__isset;
}
configuration_balancer_request::configuration_balancer_request(
    configuration_balancer_request &&other199)
{
    gpid = std::move(other199.gpid);
    action_list = std::move(other199.action_list);
    force = std::move(other199.force);
    balance_type = std::move(other199.balance_type);
    __isset = std::move(other199.__isset);
}
configuration_balancer_request &configuration_balancer_request::
operator=(const configuration_balancer_request &other200)
{
    gpid = other200.gpid;
    action_list = other200.action_list;
    force = other200.force;
    balance_type = other200.balance_type;
    __isset = other200.__isset;
    return *this;
}
configuration_balancer_request &configuration_balancer_request::
operator=(configuration_balancer_request &&other201)
{
    gpid = std::move(other201.gpid);
    action_list = std::move(other201.action_list);
    force = std::move(other201.force);
    balance_type = std::move(other201.balance_type);
    __isset = std::move(other201.__isset);
    return *this;
}
void configuration_balancer_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_balancer_request(";
    out << "gpid=" << to_string(gpid);
    out << ", "
        << "action_list=" << to_string(action_list);
    out << ", "
        << "force=";
    (__isset.force ? (out << to_string(force)) : (out << "<null>"));
    out << ", "
        << "balance_type=";
    (__isset.balance_type ? (out << to_string(balance_type)) : (out << "<null>"));
    out << ")";
}

configuration_balancer_response::~configuration_balancer_response() throw() {}

void configuration_balancer_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

uint32_t configuration_balancer_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_balancer_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_balancer_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_balancer_response &a, configuration_balancer_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.__isset, b.__isset);
}

configuration_balancer_response::configuration_balancer_response(
    const configuration_balancer_response &other202)
{
    err = other202.err;
    __isset = other202.__isset;
}
configuration_balancer_response::configuration_balancer_response(
    configuration_balancer_response &&other203)
{
    err = std::move(other203.err);
    __isset = std::move(other203.__isset);
}
configuration_balancer_response &configuration_balancer_response::
operator=(const configuration_balancer_response &other204)
{
    err = other204.err;
    __isset = other204.__isset;
    return *this;
}
configuration_balancer_response &configuration_balancer_response::
operator=(configuration_balancer_response &&other205)
{
    err = std::move(other205.err);
    __isset = std::move(other205.__isset);
    return *this;
}
void configuration_balancer_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_balancer_response(";
    out << "err=" << to_string(err);
    out << ")";
}

configuration_drop_app_response::~configuration_drop_app_response() throw() {}

void configuration_drop_app_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

uint32_t configuration_drop_app_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_drop_app_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_drop_app_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_drop_app_response &a, configuration_drop_app_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.__isset, b.__isset);
}

configuration_drop_app_response::configuration_drop_app_response(
    const configuration_drop_app_response &other206)
{
    err = other206.err;
    __isset = other206.__isset;
}
configuration_drop_app_response::configuration_drop_app_response(
    configuration_drop_app_response &&other207)
{
    err = std::move(other207.err);
    __isset = std::move(other207.__isset);
}
configuration_drop_app_response &configuration_drop_app_response::
operator=(const configuration_drop_app_response &other208)
{
    err = other208.err;
    __isset = other208.__isset;
    return *this;
}
configuration_drop_app_response &configuration_drop_app_response::
operator=(configuration_drop_app_response &&other209)
{
    err = std::move(other209.err);
    __isset = std::move(other209.__isset);
    return *this;
}
void configuration_drop_app_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_drop_app_response(";
    out << "err=" << to_string(err);
    out << ")";
}

configuration_list_apps_response::~configuration_list_apps_response() throw() {}

void configuration_list_apps_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void configuration_list_apps_response::__set_infos(const std::vector<::dsn::app_info> &val)
{
    this->infos = val;
}

uint32_t configuration_list_apps_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->infos.clear();
                    uint32_t _size210;
                    ::apache::thrift::protocol::TType _etype213;
                    xfer += iprot->readListBegin(_etype213, _size210);
                    this->infos.resize(_size210);
                    uint32_t _i214;
                    for (_i214 = 0; _i214 < _size210; ++_i214) {
                        xfer += this->infos[_i214].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.infos = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_list_apps_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_list_apps_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("infos", ::apache::thrift::protocol::T_LIST, 2);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                      static_cast<uint32_t>(this->infos.size()));
        std::vector<::dsn::app_info>::const_iterator _iter215;
        for (_iter215 = this->infos.begin(); _iter215 != this->infos.end(); ++_iter215) {
            xfer += (*_iter215).write(oprot);
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_list_apps_response &a, configuration_list_apps_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.infos, b.infos);
    swap(a.__isset, b.__isset);
}

configuration_list_apps_response::configuration_list_apps_response(
    const configuration_list_apps_response &other216)
{
    err = other216.err;
    infos = other216.infos;
    __isset = other216.__isset;
}
configuration_list_apps_response::configuration_list_apps_response(
    configuration_list_apps_response &&other217)
{
    err = std::move(other217.err);
    infos = std::move(other217.infos);
    __isset = std::move(other217.__isset);
}
configuration_list_apps_response &configuration_list_apps_response::
operator=(const configuration_list_apps_response &other218)
{
    err = other218.err;
    infos = other218.infos;
    __isset = other218.__isset;
    return *this;
}
configuration_list_apps_response &configuration_list_apps_response::
operator=(configuration_list_apps_response &&other219)
{
    err = std::move(other219.err);
    infos = std::move(other219.infos);
    __isset = std::move(other219.__isset);
    return *this;
}
void configuration_list_apps_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_list_apps_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "infos=" << to_string(infos);
    out << ")";
}

configuration_list_nodes_response::~configuration_list_nodes_response() throw() {}

void configuration_list_nodes_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void configuration_list_nodes_response::__set_infos(const std::vector<node_info> &val)
{
    this->infos = val;
}

uint32_t configuration_list_nodes_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->infos.clear();
                    uint32_t _size220;
                    ::apache::thrift::protocol::TType _etype223;
                    xfer += iprot->readListBegin(_etype223, _size220);
                    this->infos.resize(_size220);
                    uint32_t _i224;
                    for (_i224 = 0; _i224 < _size220; ++_i224) {
                        xfer += this->infos[_i224].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.infos = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t
configuration_list_nodes_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_list_nodes_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("infos", ::apache::thrift::protocol::T_LIST, 2);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                      static_cast<uint32_t>(this->infos.size()));
        std::vector<node_info>::const_iterator _iter225;
        for (_iter225 = this->infos.begin(); _iter225 != this->infos.end(); ++_iter225) {
            xfer += (*_iter225).write(oprot);
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_list_nodes_response &a, configuration_list_nodes_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.infos, b.infos);
    swap(a.__isset, b.__isset);
}

configuration_list_nodes_response::configuration_list_nodes_response(
    const configuration_list_nodes_response &other226)
{
    err = other226.err;
    infos = other226.infos;
    __isset = other226.__isset;
}
configuration_list_nodes_response::configuration_list_nodes_response(
    configuration_list_nodes_response &&other227)
{
    err = std::move(other227.err);
    infos = std::move(other227.infos);
    __isset = std::move(other227.__isset);
}
configuration_list_nodes_response &configuration_list_nodes_response::
operator=(const configuration_list_nodes_response &other228)
{
    err = other228.err;
    infos = other228.infos;
    __isset = other228.__isset;
    return *this;
}
configuration_list_nodes_response &configuration_list_nodes_response::
operator=(configuration_list_nodes_response &&other229)
{
    err = std::move(other229.err);
    infos = std::move(other229.infos);
    __isset = std::move(other229.__isset);
    return *this;
}
void configuration_list_nodes_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_list_nodes_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "infos=" << to_string(infos);
    out << ")";
}

configuration_cluster_info_response::~configuration_cluster_info_response() throw() {}

void configuration_cluster_info_response::__set_err(const ::dsn::error_code &val)
{
    this->err = val;
}

void configuration_cluster_info_response::__set_keys(const std::vector<std::string> &val)
{
    this->keys = val;
}

void configuration_cluster_info_response::__set_values(const std::vector<std::string> &val)
{
    this->values = val;
}

uint32_t configuration_cluster_info_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->keys.clear();
                    uint32_t _size230;
                    ::apache::thrift::protocol::TType _etype233;
                    xfer += iprot->readListBegin(_etype233, _size230);
                    this->keys.resize(_size230);
                    uint32_t _i234;
                    for (_i234 = 0; _i234 < _size230; ++_i234) {
                        xfer += iprot->readString(this->keys[_i234]);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.keys = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->values.clear();
                    uint32_t _size235;
                    ::apache::thrift::protocol::TType _etype238;
                    xfer += iprot->readListBegin(_etype238, _size235);
                    this->values.resize(_size235);
                    uint32_t _i239;
                    for (_i239 = 0; _i239 < _size235; ++_i239) {
                        xfer += iprot->readString(this->values[_i239]);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.values = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t
configuration_cluster_info_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_cluster_info_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("keys", ::apache::thrift::protocol::T_LIST, 2);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING,
                                      static_cast<uint32_t>(this->keys.size()));
        std::vector<std::string>::const_iterator _iter240;
        for (_iter240 = this->keys.begin(); _iter240 != this->keys.end(); ++_iter240) {
            xfer += oprot->writeString((*_iter240));
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 3);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING,
                                      static_cast<uint32_t>(this->values.size()));
        std::vector<std::string>::const_iterator _iter241;
        for (_iter241 = this->values.begin(); _iter241 != this->values.end(); ++_iter241) {
            xfer += oprot->writeString((*_iter241));
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_cluster_info_response &a, configuration_cluster_info_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.keys, b.keys);
    swap(a.values, b.values);
    swap(a.__isset, b.__isset);
}

configuration_cluster_info_response::configuration_cluster_info_response(
    const configuration_cluster_info_response &other242)
{
    err = other242.err;
    keys = other242.keys;
    values = other242.values;
    __isset = other242.__isset;
}
configuration_cluster_info_response::configuration_cluster_info_response(
    configuration_cluster_info_response &&other243)
{
    err = std::move(other243.err);
    keys = std::move(other243.keys);
    values = std::move(other243.values);
    __isset = std::move(other243.__isset);
}
configuration_cluster_info_response &configuration_cluster_info_response::
operator=(const configuration_cluster_info_response &other244)
{
    err = other244.err;
    keys = other244.keys;
    values = other244.values;
    __isset = other244.__isset;
    return *this;
}
configuration_cluster_info_response &configuration_cluster_info_response::
operator=(configuration_cluster_info_response &&other245)
{
    err = std::move(other245.err);
    keys = std::move(other245.keys);
    values = std::move(other245.values);
    __isset = std::move(other245.__isset);
    return *this;
}
void configuration_cluster_info_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_cluster_info_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "keys=" << to_string(keys);
    out << ", "
        << "values=" << to_string(values);
    out << ")";
}

configuration_recall_app_response::~configuration_recall_app_response() throw() {}

void configuration_recall_app_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void configuration_recall_app_response::__set_info(const ::dsn::app_info &val) { this->info = val; }

uint32_t configuration_recall_app_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->info.read(iprot);
                this->__isset.info = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t
configuration_recall_app_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_recall_app_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("info", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->info.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_recall_app_response &a, configuration_recall_app_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.info, b.info);
    swap(a.__isset, b.__isset);
}

configuration_recall_app_response::configuration_recall_app_response(
    const configuration_recall_app_response &other246)
{
    err = other246.err;
    info = other246.info;
    __isset = other246.__isset;
}
configuration_recall_app_response::configuration_recall_app_response(
    configuration_recall_app_response &&other247)
{
    err = std::move(other247.err);
    info = std::move(other247.info);
    __isset = std::move(other247.__isset);
}
configuration_recall_app_response &configuration_recall_app_response::
operator=(const configuration_recall_app_response &other248)
{
    err = other248.err;
    info = other248.info;
    __isset = other248.__isset;
    return *this;
}
configuration_recall_app_response &configuration_recall_app_response::
operator=(configuration_recall_app_response &&other249)
{
    err = std::move(other249.err);
    info = std::move(other249.info);
    __isset = std::move(other249.__isset);
    return *this;
}
void configuration_recall_app_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_recall_app_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "info=" << to_string(info);
    out << ")";
}

query_replica_decree_request::~query_replica_decree_request() throw() {}

void query_replica_decree_request::__set_pid(const ::dsn::gpid &val) { this->pid = val; }

void query_replica_decree_request::__set_node(const ::dsn::rpc_address &val) { this->node = val; }

uint32_t query_replica_decree_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->node.read(iprot);
                this->__isset.node = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t query_replica_decree_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("query_replica_decree_request");

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->node.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(query_replica_decree_request &a, query_replica_decree_request &b)
{
    using ::std::swap;
    swap(a.pid, b.pid);
    swap(a.node, b.node);
    swap(a.__isset, b.__isset);
}

query_replica_decree_request::query_replica_decree_request(
    const query_replica_decree_request &other250)
{
    pid = other250.pid;
    node = other250.node;
    __isset = other250.__isset;
}
query_replica_decree_request::query_replica_decree_request(query_replica_decree_request &&other251)
{
    pid = std::move(other251.pid);
    node = std::move(other251.node);
    __isset = std::move(other251.__isset);
}
query_replica_decree_request &query_replica_decree_request::
operator=(const query_replica_decree_request &other252)
{
    pid = other252.pid;
    node = other252.node;
    __isset = other252.__isset;
    return *this;
}
query_replica_decree_request &query_replica_decree_request::
operator=(query_replica_decree_request &&other253)
{
    pid = std::move(other253.pid);
    node = std::move(other253.node);
    __isset = std::move(other253.__isset);
    return *this;
}
void query_replica_decree_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "query_replica_decree_request(";
    out << "pid=" << to_string(pid);
    out << ", "
        << "node=" << to_string(node);
    out << ")";
}

query_replica_decree_response::~query_replica_decree_response() throw() {}

void query_replica_decree_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void query_replica_decree_response::__set_last_decree(const int64_t val)
{
    this->last_decree = val;
}

uint32_t query_replica_decree_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->last_decree);
                this->__isset.last_decree = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t query_replica_decree_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("query_replica_decree_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("last_decree", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->last_decree);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(query_replica_decree_response &a, query_replica_decree_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.last_decree, b.last_decree);
    swap(a.__isset, b.__isset);
}

query_replica_decree_response::query_replica_decree_response(
    const query_replica_decree_response &other254)
{
    err = other254.err;
    last_decree = other254.last_decree;
    __isset = other254.__isset;
}
query_replica_decree_response::query_replica_decree_response(
    query_replica_decree_response &&other255)
{
    err = std::move(other255.err);
    last_decree = std::move(other255.last_decree);
    __isset = std::move(other255.__isset);
}
query_replica_decree_response &query_replica_decree_response::
operator=(const query_replica_decree_response &other256)
{
    err = other256.err;
    last_decree = other256.last_decree;
    __isset = other256.__isset;
    return *this;
}
query_replica_decree_response &query_replica_decree_response::
operator=(query_replica_decree_response &&other257)
{
    err = std::move(other257.err);
    last_decree = std::move(other257.last_decree);
    __isset = std::move(other257.__isset);
    return *this;
}
void query_replica_decree_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "query_replica_decree_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "last_decree=" << to_string(last_decree);
    out << ")";
}

replica_info::~replica_info() throw() {}

void replica_info::__set_pid(const ::dsn::gpid &val) { this->pid = val; }

void replica_info::__set_ballot(const int64_t val) { this->ballot = val; }

void replica_info::__set_status(const partition_status::type val) { this->status = val; }

void replica_info::__set_last_committed_decree(const int64_t val)
{
    this->last_committed_decree = val;
}

void replica_info::__set_last_prepared_decree(const int64_t val)
{
    this->last_prepared_decree = val;
}

void replica_info::__set_last_durable_decree(const int64_t val) { this->last_durable_decree = val; }

void replica_info::__set_app_type(const std::string &val) { this->app_type = val; }

void replica_info::__set_disk_tag(const std::string &val) { this->disk_tag = val; }

uint32_t replica_info::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->ballot);
                this->__isset.ballot = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast258;
                xfer += iprot->readI32(ecast258);
                this->status = (partition_status::type)ecast258;
                this->__isset.status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->last_committed_decree);
                this->__isset.last_committed_decree = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->last_prepared_decree);
                this->__isset.last_prepared_decree = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->last_durable_decree);
                this->__isset.last_durable_decree = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 7:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_type);
                this->__isset.app_type = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 8:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->disk_tag);
                this->__isset.disk_tag = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t replica_info::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("replica_info");

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->ballot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("last_committed_decree", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->last_committed_decree);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("last_prepared_decree", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->last_prepared_decree);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("last_durable_decree", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->last_durable_decree);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("app_type", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->app_type);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("disk_tag", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->disk_tag);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(replica_info &a, replica_info &b)
{
    using ::std::swap;
    swap(a.pid, b.pid);
    swap(a.ballot, b.ballot);
    swap(a.status, b.status);
    swap(a.last_committed_decree, b.last_committed_decree);
    swap(a.last_prepared_decree, b.last_prepared_decree);
    swap(a.last_durable_decree, b.last_durable_decree);
    swap(a.app_type, b.app_type);
    swap(a.disk_tag, b.disk_tag);
    swap(a.__isset, b.__isset);
}

replica_info::replica_info(const replica_info &other259)
{
    pid = other259.pid;
    ballot = other259.ballot;
    status = other259.status;
    last_committed_decree = other259.last_committed_decree;
    last_prepared_decree = other259.last_prepared_decree;
    last_durable_decree = other259.last_durable_decree;
    app_type = other259.app_type;
    disk_tag = other259.disk_tag;
    __isset = other259.__isset;
}
replica_info::replica_info(replica_info &&other260)
{
    pid = std::move(other260.pid);
    ballot = std::move(other260.ballot);
    status = std::move(other260.status);
    last_committed_decree = std::move(other260.last_committed_decree);
    last_prepared_decree = std::move(other260.last_prepared_decree);
    last_durable_decree = std::move(other260.last_durable_decree);
    app_type = std::move(other260.app_type);
    disk_tag = std::move(other260.disk_tag);
    __isset = std::move(other260.__isset);
}
replica_info &replica_info::operator=(const replica_info &other261)
{
    pid = other261.pid;
    ballot = other261.ballot;
    status = other261.status;
    last_committed_decree = other261.last_committed_decree;
    last_prepared_decree = other261.last_prepared_decree;
    last_durable_decree = other261.last_durable_decree;
    app_type = other261.app_type;
    disk_tag = other261.disk_tag;
    __isset = other261.__isset;
    return *this;
}
replica_info &replica_info::operator=(replica_info &&other262)
{
    pid = std::move(other262.pid);
    ballot = std::move(other262.ballot);
    status = std::move(other262.status);
    last_committed_decree = std::move(other262.last_committed_decree);
    last_prepared_decree = std::move(other262.last_prepared_decree);
    last_durable_decree = std::move(other262.last_durable_decree);
    app_type = std::move(other262.app_type);
    disk_tag = std::move(other262.disk_tag);
    __isset = std::move(other262.__isset);
    return *this;
}
void replica_info::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "replica_info(";
    out << "pid=" << to_string(pid);
    out << ", "
        << "ballot=" << to_string(ballot);
    out << ", "
        << "status=" << to_string(status);
    out << ", "
        << "last_committed_decree=" << to_string(last_committed_decree);
    out << ", "
        << "last_prepared_decree=" << to_string(last_prepared_decree);
    out << ", "
        << "last_durable_decree=" << to_string(last_durable_decree);
    out << ", "
        << "app_type=" << to_string(app_type);
    out << ", "
        << "disk_tag=" << to_string(disk_tag);
    out << ")";
}

query_replica_info_request::~query_replica_info_request() throw() {}

void query_replica_info_request::__set_node(const ::dsn::rpc_address &val) { this->node = val; }

uint32_t query_replica_info_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->node.read(iprot);
                this->__isset.node = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t query_replica_info_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("query_replica_info_request");

    xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->node.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(query_replica_info_request &a, query_replica_info_request &b)
{
    using ::std::swap;
    swap(a.node, b.node);
    swap(a.__isset, b.__isset);
}

query_replica_info_request::query_replica_info_request(const query_replica_info_request &other263)
{
    node = other263.node;
    __isset = other263.__isset;
}
query_replica_info_request::query_replica_info_request(query_replica_info_request &&other264)
{
    node = std::move(other264.node);
    __isset = std::move(other264.__isset);
}
query_replica_info_request &query_replica_info_request::
operator=(const query_replica_info_request &other265)
{
    node = other265.node;
    __isset = other265.__isset;
    return *this;
}
query_replica_info_request &query_replica_info_request::
operator=(query_replica_info_request &&other266)
{
    node = std::move(other266.node);
    __isset = std::move(other266.__isset);
    return *this;
}
void query_replica_info_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "query_replica_info_request(";
    out << "node=" << to_string(node);
    out << ")";
}

query_replica_info_response::~query_replica_info_response() throw() {}

void query_replica_info_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void query_replica_info_response::__set_replicas(const std::vector<replica_info> &val)
{
    this->replicas = val;
}

uint32_t query_replica_info_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->replicas.clear();
                    uint32_t _size267;
                    ::apache::thrift::protocol::TType _etype270;
                    xfer += iprot->readListBegin(_etype270, _size267);
                    this->replicas.resize(_size267);
                    uint32_t _i271;
                    for (_i271 = 0; _i271 < _size267; ++_i271) {
                        xfer += this->replicas[_i271].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.replicas = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t query_replica_info_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("query_replica_info_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("replicas", ::apache::thrift::protocol::T_LIST, 2);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                      static_cast<uint32_t>(this->replicas.size()));
        std::vector<replica_info>::const_iterator _iter272;
        for (_iter272 = this->replicas.begin(); _iter272 != this->replicas.end(); ++_iter272) {
            xfer += (*_iter272).write(oprot);
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(query_replica_info_response &a, query_replica_info_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.replicas, b.replicas);
    swap(a.__isset, b.__isset);
}

query_replica_info_response::query_replica_info_response(
    const query_replica_info_response &other273)
{
    err = other273.err;
    replicas = other273.replicas;
    __isset = other273.__isset;
}
query_replica_info_response::query_replica_info_response(query_replica_info_response &&other274)
{
    err = std::move(other274.err);
    replicas = std::move(other274.replicas);
    __isset = std::move(other274.__isset);
}
query_replica_info_response &query_replica_info_response::
operator=(const query_replica_info_response &other275)
{
    err = other275.err;
    replicas = other275.replicas;
    __isset = other275.__isset;
    return *this;
}
query_replica_info_response &query_replica_info_response::
operator=(query_replica_info_response &&other276)
{
    err = std::move(other276.err);
    replicas = std::move(other276.replicas);
    __isset = std::move(other276.__isset);
    return *this;
}
void query_replica_info_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "query_replica_info_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "replicas=" << to_string(replicas);
    out << ")";
}

disk_info::~disk_info() throw() {}

void disk_info::__set_tag(const std::string &val) { this->tag = val; }

void disk_info::__set_full_dir(const std::string &val) { this->full_dir = val; }

void disk_info::__set_disk_capacity_mb(const int64_t val) { this->disk_capacity_mb = val; }

void disk_info::__set_disk_available_mb(const int64_t val) { this->disk_available_mb = val; }

void disk_info::__set_holding_primary_replicas(const std::map<int32_t, std::set<::dsn::gpid>> &val)
{
    this->holding_primary_replicas = val;
}

void disk_info::__set_holding_secondary_replicas(
    const std::map<int32_t, std::set<::dsn::gpid>> &val)
{
    this->holding_secondary_replicas = val;
}

uint32_t disk_info::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->tag);
                this->__isset.tag = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->full_dir);
                this->__isset.full_dir = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->disk_capacity_mb);
                this->__isset.disk_capacity_mb = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->disk_available_mb);
                this->__isset.disk_available_mb = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_MAP) {
                {
                    this->holding_primary_replicas.clear();
                    uint32_t _size277;
                    ::apache::thrift::protocol::TType _ktype278;
                    ::apache::thrift::protocol::TType _vtype279;
                    xfer += iprot->readMapBegin(_ktype278, _vtype279, _size277);
                    uint32_t _i281;
                    for (_i281 = 0; _i281 < _size277; ++_i281) {
                        int32_t _key282;
                        xfer += iprot->readI32(_key282);
                        std::set<::dsn::gpid> &_val283 = this->holding_primary_replicas[_key282];
                        {
                            _val283.clear();
                            uint32_t _size284;
                            ::apache::thrift::protocol::TType _etype287;
                            xfer += iprot->readSetBegin(_etype287, _size284);
                            uint32_t _i288;
                            for (_i288 = 0; _i288 < _size284; ++_i288) {
                                ::dsn::gpid _elem289;
                                xfer += _elem289.read(iprot);
                                _val283.insert(_elem289);
                            }
                            xfer += iprot->readSetEnd();
                        }
                    }
                    xfer += iprot->readMapEnd();
                }
                this->__isset.holding_primary_replicas = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_MAP) {
                {
                    this->holding_secondary_replicas.clear();
                    uint32_t _size290;
                    ::apache::thrift::protocol::TType _ktype291;
                    ::apache::thrift::protocol::TType _vtype292;
                    xfer += iprot->readMapBegin(_ktype291, _vtype292, _size290);
                    uint32_t _i294;
                    for (_i294 = 0; _i294 < _size290; ++_i294) {
                        int32_t _key295;
                        xfer += iprot->readI32(_key295);
                        std::set<::dsn::gpid> &_val296 = this->holding_secondary_replicas[_key295];
                        {
                            _val296.clear();
                            uint32_t _size297;
                            ::apache::thrift::protocol::TType _etype300;
                            xfer += iprot->readSetBegin(_etype300, _size297);
                            uint32_t _i301;
                            for (_i301 = 0; _i301 < _size297; ++_i301) {
                                ::dsn::gpid _elem302;
                                xfer += _elem302.read(iprot);
                                _val296.insert(_elem302);
                            }
                            xfer += iprot->readSetEnd();
                        }
                    }
                    xfer += iprot->readMapEnd();
                }
                this->__isset.holding_secondary_replicas = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t disk_info::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("disk_info");

    xfer += oprot->writeFieldBegin("tag", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->tag);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("full_dir", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->full_dir);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("disk_capacity_mb", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->disk_capacity_mb);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("disk_available_mb", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->disk_available_mb);
    xfer += oprot->writeFieldEnd();

    xfer +=
        oprot->writeFieldBegin("holding_primary_replicas", ::apache::thrift::protocol::T_MAP, 5);
    {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32,
                                     ::apache::thrift::protocol::T_SET,
                                     static_cast<uint32_t>(this->holding_primary_replicas.size()));
        std::map<int32_t, std::set<::dsn::gpid>>::const_iterator _iter303;
        for (_iter303 = this->holding_primary_replicas.begin();
             _iter303 != this->holding_primary_replicas.end();
             ++_iter303) {
            xfer += oprot->writeI32(_iter303->first);
            {
                xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT,
                                             static_cast<uint32_t>(_iter303->second.size()));
                std::set<::dsn::gpid>::const_iterator _iter304;
                for (_iter304 = _iter303->second.begin(); _iter304 != _iter303->second.end();
                     ++_iter304) {
                    xfer += (*_iter304).write(oprot);
                }
                xfer += oprot->writeSetEnd();
            }
        }
        xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer +=
        oprot->writeFieldBegin("holding_secondary_replicas", ::apache::thrift::protocol::T_MAP, 6);
    {
        xfer +=
            oprot->writeMapBegin(::apache::thrift::protocol::T_I32,
                                 ::apache::thrift::protocol::T_SET,
                                 static_cast<uint32_t>(this->holding_secondary_replicas.size()));
        std::map<int32_t, std::set<::dsn::gpid>>::const_iterator _iter305;
        for (_iter305 = this->holding_secondary_replicas.begin();
             _iter305 != this->holding_secondary_replicas.end();
             ++_iter305) {
            xfer += oprot->writeI32(_iter305->first);
            {
                xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT,
                                             static_cast<uint32_t>(_iter305->second.size()));
                std::set<::dsn::gpid>::const_iterator _iter306;
                for (_iter306 = _iter305->second.begin(); _iter306 != _iter305->second.end();
                     ++_iter306) {
                    xfer += (*_iter306).write(oprot);
                }
                xfer += oprot->writeSetEnd();
            }
        }
        xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(disk_info &a, disk_info &b)
{
    using ::std::swap;
    swap(a.tag, b.tag);
    swap(a.full_dir, b.full_dir);
    swap(a.disk_capacity_mb, b.disk_capacity_mb);
    swap(a.disk_available_mb, b.disk_available_mb);
    swap(a.holding_primary_replicas, b.holding_primary_replicas);
    swap(a.holding_secondary_replicas, b.holding_secondary_replicas);
    swap(a.__isset, b.__isset);
}

disk_info::disk_info(const disk_info &other307)
{
    tag = other307.tag;
    full_dir = other307.full_dir;
    disk_capacity_mb = other307.disk_capacity_mb;
    disk_available_mb = other307.disk_available_mb;
    holding_primary_replicas = other307.holding_primary_replicas;
    holding_secondary_replicas = other307.holding_secondary_replicas;
    __isset = other307.__isset;
}
disk_info::disk_info(disk_info &&other308)
{
    tag = std::move(other308.tag);
    full_dir = std::move(other308.full_dir);
    disk_capacity_mb = std::move(other308.disk_capacity_mb);
    disk_available_mb = std::move(other308.disk_available_mb);
    holding_primary_replicas = std::move(other308.holding_primary_replicas);
    holding_secondary_replicas = std::move(other308.holding_secondary_replicas);
    __isset = std::move(other308.__isset);
}
disk_info &disk_info::operator=(const disk_info &other309)
{
    tag = other309.tag;
    full_dir = other309.full_dir;
    disk_capacity_mb = other309.disk_capacity_mb;
    disk_available_mb = other309.disk_available_mb;
    holding_primary_replicas = other309.holding_primary_replicas;
    holding_secondary_replicas = other309.holding_secondary_replicas;
    __isset = other309.__isset;
    return *this;
}
disk_info &disk_info::operator=(disk_info &&other310)
{
    tag = std::move(other310.tag);
    full_dir = std::move(other310.full_dir);
    disk_capacity_mb = std::move(other310.disk_capacity_mb);
    disk_available_mb = std::move(other310.disk_available_mb);
    holding_primary_replicas = std::move(other310.holding_primary_replicas);
    holding_secondary_replicas = std::move(other310.holding_secondary_replicas);
    __isset = std::move(other310.__isset);
    return *this;
}
void disk_info::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "disk_info(";
    out << "tag=" << to_string(tag);
    out << ", "
        << "full_dir=" << to_string(full_dir);
    out << ", "
        << "disk_capacity_mb=" << to_string(disk_capacity_mb);
    out << ", "
        << "disk_available_mb=" << to_string(disk_available_mb);
    out << ", "
        << "holding_primary_replicas=" << to_string(holding_primary_replicas);
    out << ", "
        << "holding_secondary_replicas=" << to_string(holding_secondary_replicas);
    out << ")";
}

query_disk_info_request::~query_disk_info_request() throw() {}

void query_disk_info_request::__set_node(const ::dsn::rpc_address &val) { this->node = val; }

void query_disk_info_request::__set_app_name(const std::string &val) { this->app_name = val; }

uint32_t query_disk_info_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->node.read(iprot);
                this->__isset.node = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t query_disk_info_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("query_disk_info_request");

    xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->node.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(query_disk_info_request &a, query_disk_info_request &b)
{
    using ::std::swap;
    swap(a.node, b.node);
    swap(a.app_name, b.app_name);
    swap(a.__isset, b.__isset);
}

query_disk_info_request::query_disk_info_request(const query_disk_info_request &other311)
{
    node = other311.node;
    app_name = other311.app_name;
    __isset = other311.__isset;
}
query_disk_info_request::query_disk_info_request(query_disk_info_request &&other312)
{
    node = std::move(other312.node);
    app_name = std::move(other312.app_name);
    __isset = std::move(other312.__isset);
}
query_disk_info_request &query_disk_info_request::operator=(const query_disk_info_request &other313)
{
    node = other313.node;
    app_name = other313.app_name;
    __isset = other313.__isset;
    return *this;
}
query_disk_info_request &query_disk_info_request::operator=(query_disk_info_request &&other314)
{
    node = std::move(other314.node);
    app_name = std::move(other314.app_name);
    __isset = std::move(other314.__isset);
    return *this;
}
void query_disk_info_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "query_disk_info_request(";
    out << "node=" << to_string(node);
    out << ", "
        << "app_name=" << to_string(app_name);
    out << ")";
}

query_disk_info_response::~query_disk_info_response() throw() {}

void query_disk_info_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void query_disk_info_response::__set_total_capacity_mb(const int64_t val)
{
    this->total_capacity_mb = val;
}

void query_disk_info_response::__set_total_available_mb(const int64_t val)
{
    this->total_available_mb = val;
}

void query_disk_info_response::__set_disk_infos(const std::vector<disk_info> &val)
{
    this->disk_infos = val;
}

uint32_t query_disk_info_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->total_capacity_mb);
                this->__isset.total_capacity_mb = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->total_available_mb);
                this->__isset.total_available_mb = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->disk_infos.clear();
                    uint32_t _size315;
                    ::apache::thrift::protocol::TType _etype318;
                    xfer += iprot->readListBegin(_etype318, _size315);
                    this->disk_infos.resize(_size315);
                    uint32_t _i319;
                    for (_i319 = 0; _i319 < _size315; ++_i319) {
                        xfer += this->disk_infos[_i319].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.disk_infos = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t query_disk_info_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("query_disk_info_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("total_capacity_mb", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->total_capacity_mb);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("total_available_mb", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->total_available_mb);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("disk_infos", ::apache::thrift::protocol::T_LIST, 4);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                      static_cast<uint32_t>(this->disk_infos.size()));
        std::vector<disk_info>::const_iterator _iter320;
        for (_iter320 = this->disk_infos.begin(); _iter320 != this->disk_infos.end(); ++_iter320) {
            xfer += (*_iter320).write(oprot);
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(query_disk_info_response &a, query_disk_info_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.total_capacity_mb, b.total_capacity_mb);
    swap(a.total_available_mb, b.total_available_mb);
    swap(a.disk_infos, b.disk_infos);
    swap(a.__isset, b.__isset);
}

query_disk_info_response::query_disk_info_response(const query_disk_info_response &other321)
{
    err = other321.err;
    total_capacity_mb = other321.total_capacity_mb;
    total_available_mb = other321.total_available_mb;
    disk_infos = other321.disk_infos;
    __isset = other321.__isset;
}
query_disk_info_response::query_disk_info_response(query_disk_info_response &&other322)
{
    err = std::move(other322.err);
    total_capacity_mb = std::move(other322.total_capacity_mb);
    total_available_mb = std::move(other322.total_available_mb);
    disk_infos = std::move(other322.disk_infos);
    __isset = std::move(other322.__isset);
}
query_disk_info_response &query_disk_info_response::
operator=(const query_disk_info_response &other323)
{
    err = other323.err;
    total_capacity_mb = other323.total_capacity_mb;
    total_available_mb = other323.total_available_mb;
    disk_infos = other323.disk_infos;
    __isset = other323.__isset;
    return *this;
}
query_disk_info_response &query_disk_info_response::operator=(query_disk_info_response &&other324)
{
    err = std::move(other324.err);
    total_capacity_mb = std::move(other324.total_capacity_mb);
    total_available_mb = std::move(other324.total_available_mb);
    disk_infos = std::move(other324.disk_infos);
    __isset = std::move(other324.__isset);
    return *this;
}
void query_disk_info_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "query_disk_info_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "total_capacity_mb=" << to_string(total_capacity_mb);
    out << ", "
        << "total_available_mb=" << to_string(total_available_mb);
    out << ", "
        << "disk_infos=" << to_string(disk_infos);
    out << ")";
}

replica_disk_migrate_request::~replica_disk_migrate_request() throw() {}

void replica_disk_migrate_request::__set_pid(const ::dsn::gpid &val) { this->pid = val; }

void replica_disk_migrate_request::__set_origin_disk(const std::string &val)
{
    this->origin_disk = val;
}

void replica_disk_migrate_request::__set_target_disk(const std::string &val)
{
    this->target_disk = val;
}

uint32_t replica_disk_migrate_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->origin_disk);
                this->__isset.origin_disk = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->target_disk);
                this->__isset.target_disk = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t replica_disk_migrate_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("replica_disk_migrate_request");

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("origin_disk", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->origin_disk);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("target_disk", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->target_disk);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(replica_disk_migrate_request &a, replica_disk_migrate_request &b)
{
    using ::std::swap;
    swap(a.pid, b.pid);
    swap(a.origin_disk, b.origin_disk);
    swap(a.target_disk, b.target_disk);
    swap(a.__isset, b.__isset);
}

replica_disk_migrate_request::replica_disk_migrate_request(
    const replica_disk_migrate_request &other325)
{
    pid = other325.pid;
    origin_disk = other325.origin_disk;
    target_disk = other325.target_disk;
    __isset = other325.__isset;
}
replica_disk_migrate_request::replica_disk_migrate_request(replica_disk_migrate_request &&other326)
{
    pid = std::move(other326.pid);
    origin_disk = std::move(other326.origin_disk);
    target_disk = std::move(other326.target_disk);
    __isset = std::move(other326.__isset);
}
replica_disk_migrate_request &replica_disk_migrate_request::
operator=(const replica_disk_migrate_request &other327)
{
    pid = other327.pid;
    origin_disk = other327.origin_disk;
    target_disk = other327.target_disk;
    __isset = other327.__isset;
    return *this;
}
replica_disk_migrate_request &replica_disk_migrate_request::
operator=(replica_disk_migrate_request &&other328)
{
    pid = std::move(other328.pid);
    origin_disk = std::move(other328.origin_disk);
    target_disk = std::move(other328.target_disk);
    __isset = std::move(other328.__isset);
    return *this;
}
void replica_disk_migrate_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "replica_disk_migrate_request(";
    out << "pid=" << to_string(pid);
    out << ", "
        << "origin_disk=" << to_string(origin_disk);
    out << ", "
        << "target_disk=" << to_string(target_disk);
    out << ")";
}

replica_disk_migrate_response::~replica_disk_migrate_response() throw() {}

void replica_disk_migrate_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void replica_disk_migrate_response::__set_hint(const std::string &val)
{
    this->hint = val;
    __isset.hint = true;
}

uint32_t replica_disk_migrate_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->hint);
                this->__isset.hint = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t replica_disk_migrate_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("replica_disk_migrate_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.hint) {
        xfer += oprot->writeFieldBegin("hint", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->hint);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(replica_disk_migrate_response &a, replica_disk_migrate_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.hint, b.hint);
    swap(a.__isset, b.__isset);
}

replica_disk_migrate_response::replica_disk_migrate_response(
    const replica_disk_migrate_response &other329)
{
    err = other329.err;
    hint = other329.hint;
    __isset = other329.__isset;
}
replica_disk_migrate_response::replica_disk_migrate_response(
    replica_disk_migrate_response &&other330)
{
    err = std::move(other330.err);
    hint = std::move(other330.hint);
    __isset = std::move(other330.__isset);
}
replica_disk_migrate_response &replica_disk_migrate_response::
operator=(const replica_disk_migrate_response &other331)
{
    err = other331.err;
    hint = other331.hint;
    __isset = other331.__isset;
    return *this;
}
replica_disk_migrate_response &replica_disk_migrate_response::
operator=(replica_disk_migrate_response &&other332)
{
    err = std::move(other332.err);
    hint = std::move(other332.hint);
    __isset = std::move(other332.__isset);
    return *this;
}
void replica_disk_migrate_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "replica_disk_migrate_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "hint=";
    (__isset.hint ? (out << to_string(hint)) : (out << "<null>"));
    out << ")";
}

query_app_info_request::~query_app_info_request() throw() {}

void query_app_info_request::__set_meta_server(const ::dsn::rpc_address &val)
{
    this->meta_server = val;
}

uint32_t query_app_info_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->meta_server.read(iprot);
                this->__isset.meta_server = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t query_app_info_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("query_app_info_request");

    xfer += oprot->writeFieldBegin("meta_server", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->meta_server.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(query_app_info_request &a, query_app_info_request &b)
{
    using ::std::swap;
    swap(a.meta_server, b.meta_server);
    swap(a.__isset, b.__isset);
}

query_app_info_request::query_app_info_request(const query_app_info_request &other333)
{
    meta_server = other333.meta_server;
    __isset = other333.__isset;
}
query_app_info_request::query_app_info_request(query_app_info_request &&other334)
{
    meta_server = std::move(other334.meta_server);
    __isset = std::move(other334.__isset);
}
query_app_info_request &query_app_info_request::operator=(const query_app_info_request &other335)
{
    meta_server = other335.meta_server;
    __isset = other335.__isset;
    return *this;
}
query_app_info_request &query_app_info_request::operator=(query_app_info_request &&other336)
{
    meta_server = std::move(other336.meta_server);
    __isset = std::move(other336.__isset);
    return *this;
}
void query_app_info_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "query_app_info_request(";
    out << "meta_server=" << to_string(meta_server);
    out << ")";
}

query_app_info_response::~query_app_info_response() throw() {}

void query_app_info_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void query_app_info_response::__set_apps(const std::vector<::dsn::app_info> &val)
{
    this->apps = val;
}

uint32_t query_app_info_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->apps.clear();
                    uint32_t _size337;
                    ::apache::thrift::protocol::TType _etype340;
                    xfer += iprot->readListBegin(_etype340, _size337);
                    this->apps.resize(_size337);
                    uint32_t _i341;
                    for (_i341 = 0; _i341 < _size337; ++_i341) {
                        xfer += this->apps[_i341].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.apps = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t query_app_info_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("query_app_info_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("apps", ::apache::thrift::protocol::T_LIST, 2);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                      static_cast<uint32_t>(this->apps.size()));
        std::vector<::dsn::app_info>::const_iterator _iter342;
        for (_iter342 = this->apps.begin(); _iter342 != this->apps.end(); ++_iter342) {
            xfer += (*_iter342).write(oprot);
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(query_app_info_response &a, query_app_info_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.apps, b.apps);
    swap(a.__isset, b.__isset);
}

query_app_info_response::query_app_info_response(const query_app_info_response &other343)
{
    err = other343.err;
    apps = other343.apps;
    __isset = other343.__isset;
}
query_app_info_response::query_app_info_response(query_app_info_response &&other344)
{
    err = std::move(other344.err);
    apps = std::move(other344.apps);
    __isset = std::move(other344.__isset);
}
query_app_info_response &query_app_info_response::operator=(const query_app_info_response &other345)
{
    err = other345.err;
    apps = other345.apps;
    __isset = other345.__isset;
    return *this;
}
query_app_info_response &query_app_info_response::operator=(query_app_info_response &&other346)
{
    err = std::move(other346.err);
    apps = std::move(other346.apps);
    __isset = std::move(other346.__isset);
    return *this;
}
void query_app_info_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "query_app_info_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "apps=" << to_string(apps);
    out << ")";
}

configuration_recovery_request::~configuration_recovery_request() throw() {}

void configuration_recovery_request::__set_recovery_set(const std::vector<::dsn::rpc_address> &val)
{
    this->recovery_set = val;
}

void configuration_recovery_request::__set_skip_bad_nodes(const bool val)
{
    this->skip_bad_nodes = val;
}

void configuration_recovery_request::__set_skip_lost_partitions(const bool val)
{
    this->skip_lost_partitions = val;
}

uint32_t configuration_recovery_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->recovery_set.clear();
                    uint32_t _size347;
                    ::apache::thrift::protocol::TType _etype350;
                    xfer += iprot->readListBegin(_etype350, _size347);
                    this->recovery_set.resize(_size347);
                    uint32_t _i351;
                    for (_i351 = 0; _i351 < _size347; ++_i351) {
                        xfer += this->recovery_set[_i351].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.recovery_set = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->skip_bad_nodes);
                this->__isset.skip_bad_nodes = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->skip_lost_partitions);
                this->__isset.skip_lost_partitions = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_recovery_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_recovery_request");

    xfer += oprot->writeFieldBegin("recovery_set", ::apache::thrift::protocol::T_LIST, 1);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                      static_cast<uint32_t>(this->recovery_set.size()));
        std::vector<::dsn::rpc_address>::const_iterator _iter352;
        for (_iter352 = this->recovery_set.begin(); _iter352 != this->recovery_set.end();
             ++_iter352) {
            xfer += (*_iter352).write(oprot);
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("skip_bad_nodes", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->skip_bad_nodes);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("skip_lost_partitions", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->skip_lost_partitions);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_recovery_request &a, configuration_recovery_request &b)
{
    using ::std::swap;
    swap(a.recovery_set, b.recovery_set);
    swap(a.skip_bad_nodes, b.skip_bad_nodes);
    swap(a.skip_lost_partitions, b.skip_lost_partitions);
    swap(a.__isset, b.__isset);
}

configuration_recovery_request::configuration_recovery_request(
    const configuration_recovery_request &other353)
{
    recovery_set = other353.recovery_set;
    skip_bad_nodes = other353.skip_bad_nodes;
    skip_lost_partitions = other353.skip_lost_partitions;
    __isset = other353.__isset;
}
configuration_recovery_request::configuration_recovery_request(
    configuration_recovery_request &&other354)
{
    recovery_set = std::move(other354.recovery_set);
    skip_bad_nodes = std::move(other354.skip_bad_nodes);
    skip_lost_partitions = std::move(other354.skip_lost_partitions);
    __isset = std::move(other354.__isset);
}
configuration_recovery_request &configuration_recovery_request::
operator=(const configuration_recovery_request &other355)
{
    recovery_set = other355.recovery_set;
    skip_bad_nodes = other355.skip_bad_nodes;
    skip_lost_partitions = other355.skip_lost_partitions;
    __isset = other355.__isset;
    return *this;
}
configuration_recovery_request &configuration_recovery_request::
operator=(configuration_recovery_request &&other356)
{
    recovery_set = std::move(other356.recovery_set);
    skip_bad_nodes = std::move(other356.skip_bad_nodes);
    skip_lost_partitions = std::move(other356.skip_lost_partitions);
    __isset = std::move(other356.__isset);
    return *this;
}
void configuration_recovery_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_recovery_request(";
    out << "recovery_set=" << to_string(recovery_set);
    out << ", "
        << "skip_bad_nodes=" << to_string(skip_bad_nodes);
    out << ", "
        << "skip_lost_partitions=" << to_string(skip_lost_partitions);
    out << ")";
}

configuration_recovery_response::~configuration_recovery_response() throw() {}

void configuration_recovery_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void configuration_recovery_response::__set_hint_message(const std::string &val)
{
    this->hint_message = val;
}

uint32_t configuration_recovery_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->hint_message);
                this->__isset.hint_message = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_recovery_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_recovery_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("hint_message", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->hint_message);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_recovery_response &a, configuration_recovery_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.hint_message, b.hint_message);
    swap(a.__isset, b.__isset);
}

configuration_recovery_response::configuration_recovery_response(
    const configuration_recovery_response &other357)
{
    err = other357.err;
    hint_message = other357.hint_message;
    __isset = other357.__isset;
}
configuration_recovery_response::configuration_recovery_response(
    configuration_recovery_response &&other358)
{
    err = std::move(other358.err);
    hint_message = std::move(other358.hint_message);
    __isset = std::move(other358.__isset);
}
configuration_recovery_response &configuration_recovery_response::
operator=(const configuration_recovery_response &other359)
{
    err = other359.err;
    hint_message = other359.hint_message;
    __isset = other359.__isset;
    return *this;
}
configuration_recovery_response &configuration_recovery_response::
operator=(configuration_recovery_response &&other360)
{
    err = std::move(other360.err);
    hint_message = std::move(other360.hint_message);
    __isset = std::move(other360.__isset);
    return *this;
}
void configuration_recovery_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_recovery_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "hint_message=" << to_string(hint_message);
    out << ")";
}

policy_info::~policy_info() throw() {}

void policy_info::__set_policy_name(const std::string &val) { this->policy_name = val; }

void policy_info::__set_backup_provider_type(const std::string &val)
{
    this->backup_provider_type = val;
}

uint32_t policy_info::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->policy_name);
                this->__isset.policy_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->backup_provider_type);
                this->__isset.backup_provider_type = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t policy_info::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("policy_info");

    xfer += oprot->writeFieldBegin("policy_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->policy_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("backup_provider_type", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->backup_provider_type);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(policy_info &a, policy_info &b)
{
    using ::std::swap;
    swap(a.policy_name, b.policy_name);
    swap(a.backup_provider_type, b.backup_provider_type);
    swap(a.__isset, b.__isset);
}

policy_info::policy_info(const policy_info &other361)
{
    policy_name = other361.policy_name;
    backup_provider_type = other361.backup_provider_type;
    __isset = other361.__isset;
}
policy_info::policy_info(policy_info &&other362)
{
    policy_name = std::move(other362.policy_name);
    backup_provider_type = std::move(other362.backup_provider_type);
    __isset = std::move(other362.__isset);
}
policy_info &policy_info::operator=(const policy_info &other363)
{
    policy_name = other363.policy_name;
    backup_provider_type = other363.backup_provider_type;
    __isset = other363.__isset;
    return *this;
}
policy_info &policy_info::operator=(policy_info &&other364)
{
    policy_name = std::move(other364.policy_name);
    backup_provider_type = std::move(other364.backup_provider_type);
    __isset = std::move(other364.__isset);
    return *this;
}
void policy_info::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "policy_info(";
    out << "policy_name=" << to_string(policy_name);
    out << ", "
        << "backup_provider_type=" << to_string(backup_provider_type);
    out << ")";
}

configuration_restore_request::~configuration_restore_request() throw() {}

void configuration_restore_request::__set_cluster_name(const std::string &val)
{
    this->cluster_name = val;
}

void configuration_restore_request::__set_policy_name(const std::string &val)
{
    this->policy_name = val;
}

void configuration_restore_request::__set_time_stamp(const int64_t val) { this->time_stamp = val; }

void configuration_restore_request::__set_app_name(const std::string &val) { this->app_name = val; }

void configuration_restore_request::__set_app_id(const int32_t val) { this->app_id = val; }

void configuration_restore_request::__set_new_app_name(const std::string &val)
{
    this->new_app_name = val;
}

void configuration_restore_request::__set_backup_provider_name(const std::string &val)
{
    this->backup_provider_name = val;
}

void configuration_restore_request::__set_skip_bad_partition(const bool val)
{
    this->skip_bad_partition = val;
}

uint32_t configuration_restore_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->cluster_name);
                this->__isset.cluster_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->policy_name);
                this->__isset.policy_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->time_stamp);
                this->__isset.time_stamp = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->app_id);
                this->__isset.app_id = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->new_app_name);
                this->__isset.new_app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 7:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->backup_provider_name);
                this->__isset.backup_provider_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 8:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->skip_bad_partition);
                this->__isset.skip_bad_partition = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_restore_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_restore_request");

    xfer += oprot->writeFieldBegin("cluster_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->cluster_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("policy_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->policy_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("time_stamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->time_stamp);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("app_id", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->app_id);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("new_app_name", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->new_app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("backup_provider_name", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->backup_provider_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("skip_bad_partition", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->skip_bad_partition);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_restore_request &a, configuration_restore_request &b)
{
    using ::std::swap;
    swap(a.cluster_name, b.cluster_name);
    swap(a.policy_name, b.policy_name);
    swap(a.time_stamp, b.time_stamp);
    swap(a.app_name, b.app_name);
    swap(a.app_id, b.app_id);
    swap(a.new_app_name, b.new_app_name);
    swap(a.backup_provider_name, b.backup_provider_name);
    swap(a.skip_bad_partition, b.skip_bad_partition);
    swap(a.__isset, b.__isset);
}

configuration_restore_request::configuration_restore_request(
    const configuration_restore_request &other365)
{
    cluster_name = other365.cluster_name;
    policy_name = other365.policy_name;
    time_stamp = other365.time_stamp;
    app_name = other365.app_name;
    app_id = other365.app_id;
    new_app_name = other365.new_app_name;
    backup_provider_name = other365.backup_provider_name;
    skip_bad_partition = other365.skip_bad_partition;
    __isset = other365.__isset;
}
configuration_restore_request::configuration_restore_request(
    configuration_restore_request &&other366)
{
    cluster_name = std::move(other366.cluster_name);
    policy_name = std::move(other366.policy_name);
    time_stamp = std::move(other366.time_stamp);
    app_name = std::move(other366.app_name);
    app_id = std::move(other366.app_id);
    new_app_name = std::move(other366.new_app_name);
    backup_provider_name = std::move(other366.backup_provider_name);
    skip_bad_partition = std::move(other366.skip_bad_partition);
    __isset = std::move(other366.__isset);
}
configuration_restore_request &configuration_restore_request::
operator=(const configuration_restore_request &other367)
{
    cluster_name = other367.cluster_name;
    policy_name = other367.policy_name;
    time_stamp = other367.time_stamp;
    app_name = other367.app_name;
    app_id = other367.app_id;
    new_app_name = other367.new_app_name;
    backup_provider_name = other367.backup_provider_name;
    skip_bad_partition = other367.skip_bad_partition;
    __isset = other367.__isset;
    return *this;
}
configuration_restore_request &configuration_restore_request::
operator=(configuration_restore_request &&other368)
{
    cluster_name = std::move(other368.cluster_name);
    policy_name = std::move(other368.policy_name);
    time_stamp = std::move(other368.time_stamp);
    app_name = std::move(other368.app_name);
    app_id = std::move(other368.app_id);
    new_app_name = std::move(other368.new_app_name);
    backup_provider_name = std::move(other368.backup_provider_name);
    skip_bad_partition = std::move(other368.skip_bad_partition);
    __isset = std::move(other368.__isset);
    return *this;
}
void configuration_restore_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_restore_request(";
    out << "cluster_name=" << to_string(cluster_name);
    out << ", "
        << "policy_name=" << to_string(policy_name);
    out << ", "
        << "time_stamp=" << to_string(time_stamp);
    out << ", "
        << "app_name=" << to_string(app_name);
    out << ", "
        << "app_id=" << to_string(app_id);
    out << ", "
        << "new_app_name=" << to_string(new_app_name);
    out << ", "
        << "backup_provider_name=" << to_string(backup_provider_name);
    out << ", "
        << "skip_bad_partition=" << to_string(skip_bad_partition);
    out << ")";
}

backup_request::~backup_request() throw() {}

void backup_request::__set_pid(const ::dsn::gpid &val) { this->pid = val; }

void backup_request::__set_policy(const policy_info &val) { this->policy = val; }

void backup_request::__set_app_name(const std::string &val) { this->app_name = val; }

void backup_request::__set_backup_id(const int64_t val) { this->backup_id = val; }

uint32_t backup_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->policy.read(iprot);
                this->__isset.policy = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->backup_id);
                this->__isset.backup_id = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t backup_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("backup_request");

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("policy", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->policy.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("backup_id", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->backup_id);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(backup_request &a, backup_request &b)
{
    using ::std::swap;
    swap(a.pid, b.pid);
    swap(a.policy, b.policy);
    swap(a.app_name, b.app_name);
    swap(a.backup_id, b.backup_id);
    swap(a.__isset, b.__isset);
}

backup_request::backup_request(const backup_request &other369)
{
    pid = other369.pid;
    policy = other369.policy;
    app_name = other369.app_name;
    backup_id = other369.backup_id;
    __isset = other369.__isset;
}
backup_request::backup_request(backup_request &&other370)
{
    pid = std::move(other370.pid);
    policy = std::move(other370.policy);
    app_name = std::move(other370.app_name);
    backup_id = std::move(other370.backup_id);
    __isset = std::move(other370.__isset);
}
backup_request &backup_request::operator=(const backup_request &other371)
{
    pid = other371.pid;
    policy = other371.policy;
    app_name = other371.app_name;
    backup_id = other371.backup_id;
    __isset = other371.__isset;
    return *this;
}
backup_request &backup_request::operator=(backup_request &&other372)
{
    pid = std::move(other372.pid);
    policy = std::move(other372.policy);
    app_name = std::move(other372.app_name);
    backup_id = std::move(other372.backup_id);
    __isset = std::move(other372.__isset);
    return *this;
}
void backup_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "backup_request(";
    out << "pid=" << to_string(pid);
    out << ", "
        << "policy=" << to_string(policy);
    out << ", "
        << "app_name=" << to_string(app_name);
    out << ", "
        << "backup_id=" << to_string(backup_id);
    out << ")";
}

backup_response::~backup_response() throw() {}

void backup_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void backup_response::__set_pid(const ::dsn::gpid &val) { this->pid = val; }

void backup_response::__set_progress(const int32_t val) { this->progress = val; }

void backup_response::__set_policy_name(const std::string &val) { this->policy_name = val; }

void backup_response::__set_backup_id(const int64_t val) { this->backup_id = val; }

void backup_response::__set_checkpoint_total_size(const int64_t val)
{
    this->checkpoint_total_size = val;
}

uint32_t backup_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->progress);
                this->__isset.progress = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->policy_name);
                this->__isset.policy_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->backup_id);
                this->__isset.backup_id = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->checkpoint_total_size);
                this->__isset.checkpoint_total_size = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t backup_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("backup_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->progress);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("policy_name", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->policy_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("backup_id", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->backup_id);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("checkpoint_total_size", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->checkpoint_total_size);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(backup_response &a, backup_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.pid, b.pid);
    swap(a.progress, b.progress);
    swap(a.policy_name, b.policy_name);
    swap(a.backup_id, b.backup_id);
    swap(a.checkpoint_total_size, b.checkpoint_total_size);
    swap(a.__isset, b.__isset);
}

backup_response::backup_response(const backup_response &other373)
{
    err = other373.err;
    pid = other373.pid;
    progress = other373.progress;
    policy_name = other373.policy_name;
    backup_id = other373.backup_id;
    checkpoint_total_size = other373.checkpoint_total_size;
    __isset = other373.__isset;
}
backup_response::backup_response(backup_response &&other374)
{
    err = std::move(other374.err);
    pid = std::move(other374.pid);
    progress = std::move(other374.progress);
    policy_name = std::move(other374.policy_name);
    backup_id = std::move(other374.backup_id);
    checkpoint_total_size = std::move(other374.checkpoint_total_size);
    __isset = std::move(other374.__isset);
}
backup_response &backup_response::operator=(const backup_response &other375)
{
    err = other375.err;
    pid = other375.pid;
    progress = other375.progress;
    policy_name = other375.policy_name;
    backup_id = other375.backup_id;
    checkpoint_total_size = other375.checkpoint_total_size;
    __isset = other375.__isset;
    return *this;
}
backup_response &backup_response::operator=(backup_response &&other376)
{
    err = std::move(other376.err);
    pid = std::move(other376.pid);
    progress = std::move(other376.progress);
    policy_name = std::move(other376.policy_name);
    backup_id = std::move(other376.backup_id);
    checkpoint_total_size = std::move(other376.checkpoint_total_size);
    __isset = std::move(other376.__isset);
    return *this;
}
void backup_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "backup_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "pid=" << to_string(pid);
    out << ", "
        << "progress=" << to_string(progress);
    out << ", "
        << "policy_name=" << to_string(policy_name);
    out << ", "
        << "backup_id=" << to_string(backup_id);
    out << ", "
        << "checkpoint_total_size=" << to_string(checkpoint_total_size);
    out << ")";
}

backup_clear_request::~backup_clear_request() throw() {}

void backup_clear_request::__set_pid(const ::dsn::gpid &val) { this->pid = val; }

void backup_clear_request::__set_policy_name(const std::string &val) { this->policy_name = val; }

uint32_t backup_clear_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->policy_name);
                this->__isset.policy_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t backup_clear_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("backup_clear_request");

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("policy_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->policy_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(backup_clear_request &a, backup_clear_request &b)
{
    using ::std::swap;
    swap(a.pid, b.pid);
    swap(a.policy_name, b.policy_name);
    swap(a.__isset, b.__isset);
}

backup_clear_request::backup_clear_request(const backup_clear_request &other377)
{
    pid = other377.pid;
    policy_name = other377.policy_name;
    __isset = other377.__isset;
}
backup_clear_request::backup_clear_request(backup_clear_request &&other378)
{
    pid = std::move(other378.pid);
    policy_name = std::move(other378.policy_name);
    __isset = std::move(other378.__isset);
}
backup_clear_request &backup_clear_request::operator=(const backup_clear_request &other379)
{
    pid = other379.pid;
    policy_name = other379.policy_name;
    __isset = other379.__isset;
    return *this;
}
backup_clear_request &backup_clear_request::operator=(backup_clear_request &&other380)
{
    pid = std::move(other380.pid);
    policy_name = std::move(other380.policy_name);
    __isset = std::move(other380.__isset);
    return *this;
}
void backup_clear_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "backup_clear_request(";
    out << "pid=" << to_string(pid);
    out << ", "
        << "policy_name=" << to_string(policy_name);
    out << ")";
}

configuration_modify_backup_policy_request::~configuration_modify_backup_policy_request() throw() {}

void configuration_modify_backup_policy_request::__set_policy_name(const std::string &val)
{
    this->policy_name = val;
}

void configuration_modify_backup_policy_request::__set_add_appids(const std::vector<int32_t> &val)
{
    this->add_appids = val;
    __isset.add_appids = true;
}

void configuration_modify_backup_policy_request::__set_removal_appids(
    const std::vector<int32_t> &val)
{
    this->removal_appids = val;
    __isset.removal_appids = true;
}

void configuration_modify_backup_policy_request::__set_new_backup_interval_sec(const int64_t val)
{
    this->new_backup_interval_sec = val;
    __isset.new_backup_interval_sec = true;
}

void configuration_modify_backup_policy_request::__set_backup_history_count_to_keep(
    const int32_t val)
{
    this->backup_history_count_to_keep = val;
    __isset.backup_history_count_to_keep = true;
}

void configuration_modify_backup_policy_request::__set_is_disable(const bool val)
{
    this->is_disable = val;
    __isset.is_disable = true;
}

void configuration_modify_backup_policy_request::__set_start_time(const std::string &val)
{
    this->start_time = val;
    __isset.start_time = true;
}

uint32_t
configuration_modify_backup_policy_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->policy_name);
                this->__isset.policy_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->add_appids.clear();
                    uint32_t _size381;
                    ::apache::thrift::protocol::TType _etype384;
                    xfer += iprot->readListBegin(_etype384, _size381);
                    this->add_appids.resize(_size381);
                    uint32_t _i385;
                    for (_i385 = 0; _i385 < _size381; ++_i385) {
                        xfer += iprot->readI32(this->add_appids[_i385]);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.add_appids = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->removal_appids.clear();
                    uint32_t _size386;
                    ::apache::thrift::protocol::TType _etype389;
                    xfer += iprot->readListBegin(_etype389, _size386);
                    this->removal_appids.resize(_size386);
                    uint32_t _i390;
                    for (_i390 = 0; _i390 < _size386; ++_i390) {
                        xfer += iprot->readI32(this->removal_appids[_i390]);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.removal_appids = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->new_backup_interval_sec);
                this->__isset.new_backup_interval_sec = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->backup_history_count_to_keep);
                this->__isset.backup_history_count_to_keep = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->is_disable);
                this->__isset.is_disable = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 7:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->start_time);
                this->__isset.start_time = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_modify_backup_policy_request::write(
    ::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_modify_backup_policy_request");

    xfer += oprot->writeFieldBegin("policy_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->policy_name);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.add_appids) {
        xfer += oprot->writeFieldBegin("add_appids", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32,
                                          static_cast<uint32_t>(this->add_appids.size()));
            std::vector<int32_t>::const_iterator _iter391;
            for (_iter391 = this->add_appids.begin(); _iter391 != this->add_appids.end();
                 ++_iter391) {
                xfer += oprot->writeI32((*_iter391));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.removal_appids) {
        xfer += oprot->writeFieldBegin("removal_appids", ::apache::thrift::protocol::T_LIST, 3);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32,
                                          static_cast<uint32_t>(this->removal_appids.size()));
            std::vector<int32_t>::const_iterator _iter392;
            for (_iter392 = this->removal_appids.begin(); _iter392 != this->removal_appids.end();
                 ++_iter392) {
                xfer += oprot->writeI32((*_iter392));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.new_backup_interval_sec) {
        xfer +=
            oprot->writeFieldBegin("new_backup_interval_sec", ::apache::thrift::protocol::T_I64, 4);
        xfer += oprot->writeI64(this->new_backup_interval_sec);
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.backup_history_count_to_keep) {
        xfer += oprot->writeFieldBegin(
            "backup_history_count_to_keep", ::apache::thrift::protocol::T_I32, 5);
        xfer += oprot->writeI32(this->backup_history_count_to_keep);
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.is_disable) {
        xfer += oprot->writeFieldBegin("is_disable", ::apache::thrift::protocol::T_BOOL, 6);
        xfer += oprot->writeBool(this->is_disable);
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.start_time) {
        xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_STRING, 7);
        xfer += oprot->writeString(this->start_time);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_modify_backup_policy_request &a,
          configuration_modify_backup_policy_request &b)
{
    using ::std::swap;
    swap(a.policy_name, b.policy_name);
    swap(a.add_appids, b.add_appids);
    swap(a.removal_appids, b.removal_appids);
    swap(a.new_backup_interval_sec, b.new_backup_interval_sec);
    swap(a.backup_history_count_to_keep, b.backup_history_count_to_keep);
    swap(a.is_disable, b.is_disable);
    swap(a.start_time, b.start_time);
    swap(a.__isset, b.__isset);
}

configuration_modify_backup_policy_request::configuration_modify_backup_policy_request(
    const configuration_modify_backup_policy_request &other393)
{
    policy_name = other393.policy_name;
    add_appids = other393.add_appids;
    removal_appids = other393.removal_appids;
    new_backup_interval_sec = other393.new_backup_interval_sec;
    backup_history_count_to_keep = other393.backup_history_count_to_keep;
    is_disable = other393.is_disable;
    start_time = other393.start_time;
    __isset = other393.__isset;
}
configuration_modify_backup_policy_request::configuration_modify_backup_policy_request(
    configuration_modify_backup_policy_request &&other394)
{
    policy_name = std::move(other394.policy_name);
    add_appids = std::move(other394.add_appids);
    removal_appids = std::move(other394.removal_appids);
    new_backup_interval_sec = std::move(other394.new_backup_interval_sec);
    backup_history_count_to_keep = std::move(other394.backup_history_count_to_keep);
    is_disable = std::move(other394.is_disable);
    start_time = std::move(other394.start_time);
    __isset = std::move(other394.__isset);
}
configuration_modify_backup_policy_request &configuration_modify_backup_policy_request::
operator=(const configuration_modify_backup_policy_request &other395)
{
    policy_name = other395.policy_name;
    add_appids = other395.add_appids;
    removal_appids = other395.removal_appids;
    new_backup_interval_sec = other395.new_backup_interval_sec;
    backup_history_count_to_keep = other395.backup_history_count_to_keep;
    is_disable = other395.is_disable;
    start_time = other395.start_time;
    __isset = other395.__isset;
    return *this;
}
configuration_modify_backup_policy_request &configuration_modify_backup_policy_request::
operator=(configuration_modify_backup_policy_request &&other396)
{
    policy_name = std::move(other396.policy_name);
    add_appids = std::move(other396.add_appids);
    removal_appids = std::move(other396.removal_appids);
    new_backup_interval_sec = std::move(other396.new_backup_interval_sec);
    backup_history_count_to_keep = std::move(other396.backup_history_count_to_keep);
    is_disable = std::move(other396.is_disable);
    start_time = std::move(other396.start_time);
    __isset = std::move(other396.__isset);
    return *this;
}
void configuration_modify_backup_policy_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_modify_backup_policy_request(";
    out << "policy_name=" << to_string(policy_name);
    out << ", "
        << "add_appids=";
    (__isset.add_appids ? (out << to_string(add_appids)) : (out << "<null>"));
    out << ", "
        << "removal_appids=";
    (__isset.removal_appids ? (out << to_string(removal_appids)) : (out << "<null>"));
    out << ", "
        << "new_backup_interval_sec=";
    (__isset.new_backup_interval_sec ? (out << to_string(new_backup_interval_sec))
                                     : (out << "<null>"));
    out << ", "
        << "backup_history_count_to_keep=";
    (__isset.backup_history_count_to_keep ? (out << to_string(backup_history_count_to_keep))
                                          : (out << "<null>"));
    out << ", "
        << "is_disable=";
    (__isset.is_disable ? (out << to_string(is_disable)) : (out << "<null>"));
    out << ", "
        << "start_time=";
    (__isset.start_time ? (out << to_string(start_time)) : (out << "<null>"));
    out << ")";
}

configuration_modify_backup_policy_response::~configuration_modify_backup_policy_response() throw()
{
}

void configuration_modify_backup_policy_response::__set_err(const ::dsn::error_code &val)
{
    this->err = val;
}

void configuration_modify_backup_policy_response::__set_hint_message(const std::string &val)
{
    this->hint_message = val;
}

uint32_t
configuration_modify_backup_policy_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->hint_message);
                this->__isset.hint_message = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_modify_backup_policy_response::write(
    ::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_modify_backup_policy_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("hint_message", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->hint_message);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_modify_backup_policy_response &a,
          configuration_modify_backup_policy_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.hint_message, b.hint_message);
    swap(a.__isset, b.__isset);
}

configuration_modify_backup_policy_response::configuration_modify_backup_policy_response(
    const configuration_modify_backup_policy_response &other397)
{
    err = other397.err;
    hint_message = other397.hint_message;
    __isset = other397.__isset;
}
configuration_modify_backup_policy_response::configuration_modify_backup_policy_response(
    configuration_modify_backup_policy_response &&other398)
{
    err = std::move(other398.err);
    hint_message = std::move(other398.hint_message);
    __isset = std::move(other398.__isset);
}
configuration_modify_backup_policy_response &configuration_modify_backup_policy_response::
operator=(const configuration_modify_backup_policy_response &other399)
{
    err = other399.err;
    hint_message = other399.hint_message;
    __isset = other399.__isset;
    return *this;
}
configuration_modify_backup_policy_response &configuration_modify_backup_policy_response::
operator=(configuration_modify_backup_policy_response &&other400)
{
    err = std::move(other400.err);
    hint_message = std::move(other400.hint_message);
    __isset = std::move(other400.__isset);
    return *this;
}
void configuration_modify_backup_policy_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_modify_backup_policy_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "hint_message=" << to_string(hint_message);
    out << ")";
}

configuration_add_backup_policy_request::~configuration_add_backup_policy_request() throw() {}

void configuration_add_backup_policy_request::__set_backup_provider_type(const std::string &val)
{
    this->backup_provider_type = val;
}

void configuration_add_backup_policy_request::__set_policy_name(const std::string &val)
{
    this->policy_name = val;
}

void configuration_add_backup_policy_request::__set_app_ids(const std::vector<int32_t> &val)
{
    this->app_ids = val;
}

void configuration_add_backup_policy_request::__set_backup_interval_seconds(const int64_t val)
{
    this->backup_interval_seconds = val;
}

void configuration_add_backup_policy_request::__set_backup_history_count_to_keep(const int32_t val)
{
    this->backup_history_count_to_keep = val;
}

void configuration_add_backup_policy_request::__set_start_time(const std::string &val)
{
    this->start_time = val;
}

uint32_t configuration_add_backup_policy_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->backup_provider_type);
                this->__isset.backup_provider_type = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->policy_name);
                this->__isset.policy_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->app_ids.clear();
                    uint32_t _size401;
                    ::apache::thrift::protocol::TType _etype404;
                    xfer += iprot->readListBegin(_etype404, _size401);
                    this->app_ids.resize(_size401);
                    uint32_t _i405;
                    for (_i405 = 0; _i405 < _size401; ++_i405) {
                        xfer += iprot->readI32(this->app_ids[_i405]);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.app_ids = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->backup_interval_seconds);
                this->__isset.backup_interval_seconds = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->backup_history_count_to_keep);
                this->__isset.backup_history_count_to_keep = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->start_time);
                this->__isset.start_time = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t
configuration_add_backup_policy_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_add_backup_policy_request");

    xfer += oprot->writeFieldBegin("backup_provider_type", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->backup_provider_type);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("policy_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->policy_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("app_ids", ::apache::thrift::protocol::T_LIST, 3);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32,
                                      static_cast<uint32_t>(this->app_ids.size()));
        std::vector<int32_t>::const_iterator _iter406;
        for (_iter406 = this->app_ids.begin(); _iter406 != this->app_ids.end(); ++_iter406) {
            xfer += oprot->writeI32((*_iter406));
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("backup_interval_seconds", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->backup_interval_seconds);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin(
        "backup_history_count_to_keep", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->backup_history_count_to_keep);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->start_time);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_add_backup_policy_request &a, configuration_add_backup_policy_request &b)
{
    using ::std::swap;
    swap(a.backup_provider_type, b.backup_provider_type);
    swap(a.policy_name, b.policy_name);
    swap(a.app_ids, b.app_ids);
    swap(a.backup_interval_seconds, b.backup_interval_seconds);
    swap(a.backup_history_count_to_keep, b.backup_history_count_to_keep);
    swap(a.start_time, b.start_time);
    swap(a.__isset, b.__isset);
}

configuration_add_backup_policy_request::configuration_add_backup_policy_request(
    const configuration_add_backup_policy_request &other407)
{
    backup_provider_type = other407.backup_provider_type;
    policy_name = other407.policy_name;
    app_ids = other407.app_ids;
    backup_interval_seconds = other407.backup_interval_seconds;
    backup_history_count_to_keep = other407.backup_history_count_to_keep;
    start_time = other407.start_time;
    __isset = other407.__isset;
}
configuration_add_backup_policy_request::configuration_add_backup_policy_request(
    configuration_add_backup_policy_request &&other408)
{
    backup_provider_type = std::move(other408.backup_provider_type);
    policy_name = std::move(other408.policy_name);
    app_ids = std::move(other408.app_ids);
    backup_interval_seconds = std::move(other408.backup_interval_seconds);
    backup_history_count_to_keep = std::move(other408.backup_history_count_to_keep);
    start_time = std::move(other408.start_time);
    __isset = std::move(other408.__isset);
}
configuration_add_backup_policy_request &configuration_add_backup_policy_request::
operator=(const configuration_add_backup_policy_request &other409)
{
    backup_provider_type = other409.backup_provider_type;
    policy_name = other409.policy_name;
    app_ids = other409.app_ids;
    backup_interval_seconds = other409.backup_interval_seconds;
    backup_history_count_to_keep = other409.backup_history_count_to_keep;
    start_time = other409.start_time;
    __isset = other409.__isset;
    return *this;
}
configuration_add_backup_policy_request &configuration_add_backup_policy_request::
operator=(configuration_add_backup_policy_request &&other410)
{
    backup_provider_type = std::move(other410.backup_provider_type);
    policy_name = std::move(other410.policy_name);
    app_ids = std::move(other410.app_ids);
    backup_interval_seconds = std::move(other410.backup_interval_seconds);
    backup_history_count_to_keep = std::move(other410.backup_history_count_to_keep);
    start_time = std::move(other410.start_time);
    __isset = std::move(other410.__isset);
    return *this;
}
void configuration_add_backup_policy_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_add_backup_policy_request(";
    out << "backup_provider_type=" << to_string(backup_provider_type);
    out << ", "
        << "policy_name=" << to_string(policy_name);
    out << ", "
        << "app_ids=" << to_string(app_ids);
    out << ", "
        << "backup_interval_seconds=" << to_string(backup_interval_seconds);
    out << ", "
        << "backup_history_count_to_keep=" << to_string(backup_history_count_to_keep);
    out << ", "
        << "start_time=" << to_string(start_time);
    out << ")";
}

configuration_add_backup_policy_response::~configuration_add_backup_policy_response() throw() {}

void configuration_add_backup_policy_response::__set_err(const ::dsn::error_code &val)
{
    this->err = val;
}

void configuration_add_backup_policy_response::__set_hint_message(const std::string &val)
{
    this->hint_message = val;
}

uint32_t
configuration_add_backup_policy_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->hint_message);
                this->__isset.hint_message = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t
configuration_add_backup_policy_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_add_backup_policy_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("hint_message", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->hint_message);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_add_backup_policy_response &a, configuration_add_backup_policy_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.hint_message, b.hint_message);
    swap(a.__isset, b.__isset);
}

configuration_add_backup_policy_response::configuration_add_backup_policy_response(
    const configuration_add_backup_policy_response &other411)
{
    err = other411.err;
    hint_message = other411.hint_message;
    __isset = other411.__isset;
}
configuration_add_backup_policy_response::configuration_add_backup_policy_response(
    configuration_add_backup_policy_response &&other412)
{
    err = std::move(other412.err);
    hint_message = std::move(other412.hint_message);
    __isset = std::move(other412.__isset);
}
configuration_add_backup_policy_response &configuration_add_backup_policy_response::
operator=(const configuration_add_backup_policy_response &other413)
{
    err = other413.err;
    hint_message = other413.hint_message;
    __isset = other413.__isset;
    return *this;
}
configuration_add_backup_policy_response &configuration_add_backup_policy_response::
operator=(configuration_add_backup_policy_response &&other414)
{
    err = std::move(other414.err);
    hint_message = std::move(other414.hint_message);
    __isset = std::move(other414.__isset);
    return *this;
}
void configuration_add_backup_policy_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_add_backup_policy_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "hint_message=" << to_string(hint_message);
    out << ")";
}

policy_entry::~policy_entry() throw() {}

void policy_entry::__set_policy_name(const std::string &val) { this->policy_name = val; }

void policy_entry::__set_backup_provider_type(const std::string &val)
{
    this->backup_provider_type = val;
}

void policy_entry::__set_backup_interval_seconds(const std::string &val)
{
    this->backup_interval_seconds = val;
}

void policy_entry::__set_app_ids(const std::set<int32_t> &val) { this->app_ids = val; }

void policy_entry::__set_backup_history_count_to_keep(const int32_t val)
{
    this->backup_history_count_to_keep = val;
}

void policy_entry::__set_start_time(const std::string &val) { this->start_time = val; }

void policy_entry::__set_is_disable(const bool val) { this->is_disable = val; }

uint32_t policy_entry::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->policy_name);
                this->__isset.policy_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->backup_provider_type);
                this->__isset.backup_provider_type = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->backup_interval_seconds);
                this->__isset.backup_interval_seconds = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_SET) {
                {
                    this->app_ids.clear();
                    uint32_t _size415;
                    ::apache::thrift::protocol::TType _etype418;
                    xfer += iprot->readSetBegin(_etype418, _size415);
                    uint32_t _i419;
                    for (_i419 = 0; _i419 < _size415; ++_i419) {
                        int32_t _elem420;
                        xfer += iprot->readI32(_elem420);
                        this->app_ids.insert(_elem420);
                    }
                    xfer += iprot->readSetEnd();
                }
                this->__isset.app_ids = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->backup_history_count_to_keep);
                this->__isset.backup_history_count_to_keep = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->start_time);
                this->__isset.start_time = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 7:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->is_disable);
                this->__isset.is_disable = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t policy_entry::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("policy_entry");

    xfer += oprot->writeFieldBegin("policy_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->policy_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("backup_provider_type", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->backup_provider_type);
    xfer += oprot->writeFieldEnd();

    xfer +=
        oprot->writeFieldBegin("backup_interval_seconds", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->backup_interval_seconds);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("app_ids", ::apache::thrift::protocol::T_SET, 4);
    {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32,
                                     static_cast<uint32_t>(this->app_ids.size()));
        std::set<int32_t>::const_iterator _iter421;
        for (_iter421 = this->app_ids.begin(); _iter421 != this->app_ids.end(); ++_iter421) {
            xfer += oprot->writeI32((*_iter421));
        }
        xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin(
        "backup_history_count_to_keep", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->backup_history_count_to_keep);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->start_time);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("is_disable", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_disable);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(policy_entry &a, policy_entry &b)
{
    using ::std::swap;
    swap(a.policy_name, b.policy_name);
    swap(a.backup_provider_type, b.backup_provider_type);
    swap(a.backup_interval_seconds, b.backup_interval_seconds);
    swap(a.app_ids, b.app_ids);
    swap(a.backup_history_count_to_keep, b.backup_history_count_to_keep);
    swap(a.start_time, b.start_time);
    swap(a.is_disable, b.is_disable);
    swap(a.__isset, b.__isset);
}

policy_entry::policy_entry(const policy_entry &other422)
{
    policy_name = other422.policy_name;
    backup_provider_type = other422.backup_provider_type;
    backup_interval_seconds = other422.backup_interval_seconds;
    app_ids = other422.app_ids;
    backup_history_count_to_keep = other422.backup_history_count_to_keep;
    start_time = other422.start_time;
    is_disable = other422.is_disable;
    __isset = other422.__isset;
}
policy_entry::policy_entry(policy_entry &&other423)
{
    policy_name = std::move(other423.policy_name);
    backup_provider_type = std::move(other423.backup_provider_type);
    backup_interval_seconds = std::move(other423.backup_interval_seconds);
    app_ids = std::move(other423.app_ids);
    backup_history_count_to_keep = std::move(other423.backup_history_count_to_keep);
    start_time = std::move(other423.start_time);
    is_disable = std::move(other423.is_disable);
    __isset = std::move(other423.__isset);
}
policy_entry &policy_entry::operator=(const policy_entry &other424)
{
    policy_name = other424.policy_name;
    backup_provider_type = other424.backup_provider_type;
    backup_interval_seconds = other424.backup_interval_seconds;
    app_ids = other424.app_ids;
    backup_history_count_to_keep = other424.backup_history_count_to_keep;
    start_time = other424.start_time;
    is_disable = other424.is_disable;
    __isset = other424.__isset;
    return *this;
}
policy_entry &policy_entry::operator=(policy_entry &&other425)
{
    policy_name = std::move(other425.policy_name);
    backup_provider_type = std::move(other425.backup_provider_type);
    backup_interval_seconds = std::move(other425.backup_interval_seconds);
    app_ids = std::move(other425.app_ids);
    backup_history_count_to_keep = std::move(other425.backup_history_count_to_keep);
    start_time = std::move(other425.start_time);
    is_disable = std::move(other425.is_disable);
    __isset = std::move(other425.__isset);
    return *this;
}
void policy_entry::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "policy_entry(";
    out << "policy_name=" << to_string(policy_name);
    out << ", "
        << "backup_provider_type=" << to_string(backup_provider_type);
    out << ", "
        << "backup_interval_seconds=" << to_string(backup_interval_seconds);
    out << ", "
        << "app_ids=" << to_string(app_ids);
    out << ", "
        << "backup_history_count_to_keep=" << to_string(backup_history_count_to_keep);
    out << ", "
        << "start_time=" << to_string(start_time);
    out << ", "
        << "is_disable=" << to_string(is_disable);
    out << ")";
}

backup_entry::~backup_entry() throw() {}

void backup_entry::__set_backup_id(const int64_t val) { this->backup_id = val; }

void backup_entry::__set_start_time_ms(const int64_t val) { this->start_time_ms = val; }

void backup_entry::__set_end_time_ms(const int64_t val) { this->end_time_ms = val; }

void backup_entry::__set_app_ids(const std::set<int32_t> &val) { this->app_ids = val; }

uint32_t backup_entry::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->backup_id);
                this->__isset.backup_id = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->start_time_ms);
                this->__isset.start_time_ms = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->end_time_ms);
                this->__isset.end_time_ms = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_SET) {
                {
                    this->app_ids.clear();
                    uint32_t _size426;
                    ::apache::thrift::protocol::TType _etype429;
                    xfer += iprot->readSetBegin(_etype429, _size426);
                    uint32_t _i430;
                    for (_i430 = 0; _i430 < _size426; ++_i430) {
                        int32_t _elem431;
                        xfer += iprot->readI32(_elem431);
                        this->app_ids.insert(_elem431);
                    }
                    xfer += iprot->readSetEnd();
                }
                this->__isset.app_ids = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t backup_entry::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("backup_entry");

    xfer += oprot->writeFieldBegin("backup_id", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->backup_id);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("start_time_ms", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->start_time_ms);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("end_time_ms", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->end_time_ms);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("app_ids", ::apache::thrift::protocol::T_SET, 4);
    {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32,
                                     static_cast<uint32_t>(this->app_ids.size()));
        std::set<int32_t>::const_iterator _iter432;
        for (_iter432 = this->app_ids.begin(); _iter432 != this->app_ids.end(); ++_iter432) {
            xfer += oprot->writeI32((*_iter432));
        }
        xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(backup_entry &a, backup_entry &b)
{
    using ::std::swap;
    swap(a.backup_id, b.backup_id);
    swap(a.start_time_ms, b.start_time_ms);
    swap(a.end_time_ms, b.end_time_ms);
    swap(a.app_ids, b.app_ids);
    swap(a.__isset, b.__isset);
}

backup_entry::backup_entry(const backup_entry &other433)
{
    backup_id = other433.backup_id;
    start_time_ms = other433.start_time_ms;
    end_time_ms = other433.end_time_ms;
    app_ids = other433.app_ids;
    __isset = other433.__isset;
}
backup_entry::backup_entry(backup_entry &&other434)
{
    backup_id = std::move(other434.backup_id);
    start_time_ms = std::move(other434.start_time_ms);
    end_time_ms = std::move(other434.end_time_ms);
    app_ids = std::move(other434.app_ids);
    __isset = std::move(other434.__isset);
}
backup_entry &backup_entry::operator=(const backup_entry &other435)
{
    backup_id = other435.backup_id;
    start_time_ms = other435.start_time_ms;
    end_time_ms = other435.end_time_ms;
    app_ids = other435.app_ids;
    __isset = other435.__isset;
    return *this;
}
backup_entry &backup_entry::operator=(backup_entry &&other436)
{
    backup_id = std::move(other436.backup_id);
    start_time_ms = std::move(other436.start_time_ms);
    end_time_ms = std::move(other436.end_time_ms);
    app_ids = std::move(other436.app_ids);
    __isset = std::move(other436.__isset);
    return *this;
}
void backup_entry::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "backup_entry(";
    out << "backup_id=" << to_string(backup_id);
    out << ", "
        << "start_time_ms=" << to_string(start_time_ms);
    out << ", "
        << "end_time_ms=" << to_string(end_time_ms);
    out << ", "
        << "app_ids=" << to_string(app_ids);
    out << ")";
}

configuration_query_backup_policy_request::~configuration_query_backup_policy_request() throw() {}

void configuration_query_backup_policy_request::__set_policy_names(
    const std::vector<std::string> &val)
{
    this->policy_names = val;
}

void configuration_query_backup_policy_request::__set_backup_info_count(const int32_t val)
{
    this->backup_info_count = val;
}

uint32_t
configuration_query_backup_policy_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->policy_names.clear();
                    uint32_t _size437;
                    ::apache::thrift::protocol::TType _etype440;
                    xfer += iprot->readListBegin(_etype440, _size437);
                    this->policy_names.resize(_size437);
                    uint32_t _i441;
                    for (_i441 = 0; _i441 < _size437; ++_i441) {
                        xfer += iprot->readString(this->policy_names[_i441]);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.policy_names = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->backup_info_count);
                this->__isset.backup_info_count = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t
configuration_query_backup_policy_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_query_backup_policy_request");

    xfer += oprot->writeFieldBegin("policy_names", ::apache::thrift::protocol::T_LIST, 1);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING,
                                      static_cast<uint32_t>(this->policy_names.size()));
        std::vector<std::string>::const_iterator _iter442;
        for (_iter442 = this->policy_names.begin(); _iter442 != this->policy_names.end();
             ++_iter442) {
            xfer += oprot->writeString((*_iter442));
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("backup_info_count", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->backup_info_count);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_query_backup_policy_request &a,
          configuration_query_backup_policy_request &b)
{
    using ::std::swap;
    swap(a.policy_names, b.policy_names);
    swap(a.backup_info_count, b.backup_info_count);
    swap(a.__isset, b.__isset);
}

configuration_query_backup_policy_request::configuration_query_backup_policy_request(
    const configuration_query_backup_policy_request &other443)
{
    policy_names = other443.policy_names;
    backup_info_count = other443.backup_info_count;
    __isset = other443.__isset;
}
configuration_query_backup_policy_request::configuration_query_backup_policy_request(
    configuration_query_backup_policy_request &&other444)
{
    policy_names = std::move(other444.policy_names);
    backup_info_count = std::move(other444.backup_info_count);
    __isset = std::move(other444.__isset);
}
configuration_query_backup_policy_request &configuration_query_backup_policy_request::
operator=(const configuration_query_backup_policy_request &other445)
{
    policy_names = other445.policy_names;
    backup_info_count = other445.backup_info_count;
    __isset = other445.__isset;
    return *this;
}
configuration_query_backup_policy_request &configuration_query_backup_policy_request::
operator=(configuration_query_backup_policy_request &&other446)
{
    policy_names = std::move(other446.policy_names);
    backup_info_count = std::move(other446.backup_info_count);
    __isset = std::move(other446.__isset);
    return *this;
}
void configuration_query_backup_policy_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_query_backup_policy_request(";
    out << "policy_names=" << to_string(policy_names);
    out << ", "
        << "backup_info_count=" << to_string(backup_info_count);
    out << ")";
}

configuration_query_backup_policy_response::~configuration_query_backup_policy_response() throw() {}

void configuration_query_backup_policy_response::__set_err(const ::dsn::error_code &val)
{
    this->err = val;
}

void configuration_query_backup_policy_response::__set_policys(const std::vector<policy_entry> &val)
{
    this->policys = val;
}

void configuration_query_backup_policy_response::__set_backup_infos(
    const std::vector<std::vector<backup_entry>> &val)
{
    this->backup_infos = val;
}

void configuration_query_backup_policy_response::__set_hint_msg(const std::string &val)
{
    this->hint_msg = val;
    __isset.hint_msg = true;
}

uint32_t
configuration_query_backup_policy_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->policys.clear();
                    uint32_t _size447;
                    ::apache::thrift::protocol::TType _etype450;
                    xfer += iprot->readListBegin(_etype450, _size447);
                    this->policys.resize(_size447);
                    uint32_t _i451;
                    for (_i451 = 0; _i451 < _size447; ++_i451) {
                        xfer += this->policys[_i451].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.policys = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->backup_infos.clear();
                    uint32_t _size452;
                    ::apache::thrift::protocol::TType _etype455;
                    xfer += iprot->readListBegin(_etype455, _size452);
                    this->backup_infos.resize(_size452);
                    uint32_t _i456;
                    for (_i456 = 0; _i456 < _size452; ++_i456) {
                        {
                            this->backup_infos[_i456].clear();
                            uint32_t _size457;
                            ::apache::thrift::protocol::TType _etype460;
                            xfer += iprot->readListBegin(_etype460, _size457);
                            this->backup_infos[_i456].resize(_size457);
                            uint32_t _i461;
                            for (_i461 = 0; _i461 < _size457; ++_i461) {
                                xfer += this->backup_infos[_i456][_i461].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.backup_infos = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->hint_msg);
                this->__isset.hint_msg = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_query_backup_policy_response::write(
    ::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_query_backup_policy_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("policys", ::apache::thrift::protocol::T_LIST, 2);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                      static_cast<uint32_t>(this->policys.size()));
        std::vector<policy_entry>::const_iterator _iter462;
        for (_iter462 = this->policys.begin(); _iter462 != this->policys.end(); ++_iter462) {
            xfer += (*_iter462).write(oprot);
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("backup_infos", ::apache::thrift::protocol::T_LIST, 3);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST,
                                      static_cast<uint32_t>(this->backup_infos.size()));
        std::vector<std::vector<backup_entry>>::const_iterator _iter463;
        for (_iter463 = this->backup_infos.begin(); _iter463 != this->backup_infos.end();
             ++_iter463) {
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                              static_cast<uint32_t>((*_iter463).size()));
                std::vector<backup_entry>::const_iterator _iter464;
                for (_iter464 = (*_iter463).begin(); _iter464 != (*_iter463).end(); ++_iter464) {
                    xfer += (*_iter464).write(oprot);
                }
                xfer += oprot->writeListEnd();
            }
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    if (this->__isset.hint_msg) {
        xfer += oprot->writeFieldBegin("hint_msg", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->hint_msg);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_query_backup_policy_response &a,
          configuration_query_backup_policy_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.policys, b.policys);
    swap(a.backup_infos, b.backup_infos);
    swap(a.hint_msg, b.hint_msg);
    swap(a.__isset, b.__isset);
}

configuration_query_backup_policy_response::configuration_query_backup_policy_response(
    const configuration_query_backup_policy_response &other465)
{
    err = other465.err;
    policys = other465.policys;
    backup_infos = other465.backup_infos;
    hint_msg = other465.hint_msg;
    __isset = other465.__isset;
}
configuration_query_backup_policy_response::configuration_query_backup_policy_response(
    configuration_query_backup_policy_response &&other466)
{
    err = std::move(other466.err);
    policys = std::move(other466.policys);
    backup_infos = std::move(other466.backup_infos);
    hint_msg = std::move(other466.hint_msg);
    __isset = std::move(other466.__isset);
}
configuration_query_backup_policy_response &configuration_query_backup_policy_response::
operator=(const configuration_query_backup_policy_response &other467)
{
    err = other467.err;
    policys = other467.policys;
    backup_infos = other467.backup_infos;
    hint_msg = other467.hint_msg;
    __isset = other467.__isset;
    return *this;
}
configuration_query_backup_policy_response &configuration_query_backup_policy_response::
operator=(configuration_query_backup_policy_response &&other468)
{
    err = std::move(other468.err);
    policys = std::move(other468.policys);
    backup_infos = std::move(other468.backup_infos);
    hint_msg = std::move(other468.hint_msg);
    __isset = std::move(other468.__isset);
    return *this;
}
void configuration_query_backup_policy_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_query_backup_policy_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "policys=" << to_string(policys);
    out << ", "
        << "backup_infos=" << to_string(backup_infos);
    out << ", "
        << "hint_msg=";
    (__isset.hint_msg ? (out << to_string(hint_msg)) : (out << "<null>"));
    out << ")";
}

configuration_report_restore_status_request::~configuration_report_restore_status_request() throw()
{
}

void configuration_report_restore_status_request::__set_pid(const ::dsn::gpid &val)
{
    this->pid = val;
}

void configuration_report_restore_status_request::__set_restore_status(const ::dsn::error_code &val)
{
    this->restore_status = val;
}

void configuration_report_restore_status_request::__set_progress(const int32_t val)
{
    this->progress = val;
}

void configuration_report_restore_status_request::__set_reason(const std::string &val)
{
    this->reason = val;
    __isset.reason = true;
}

uint32_t
configuration_report_restore_status_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->restore_status.read(iprot);
                this->__isset.restore_status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->progress);
                this->__isset.progress = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->reason);
                this->__isset.reason = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_report_restore_status_request::write(
    ::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_report_restore_status_request");

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("restore_status", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->restore_status.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->progress);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.reason) {
        xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->reason);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_report_restore_status_request &a,
          configuration_report_restore_status_request &b)
{
    using ::std::swap;
    swap(a.pid, b.pid);
    swap(a.restore_status, b.restore_status);
    swap(a.progress, b.progress);
    swap(a.reason, b.reason);
    swap(a.__isset, b.__isset);
}

configuration_report_restore_status_request::configuration_report_restore_status_request(
    const configuration_report_restore_status_request &other469)
{
    pid = other469.pid;
    restore_status = other469.restore_status;
    progress = other469.progress;
    reason = other469.reason;
    __isset = other469.__isset;
}
configuration_report_restore_status_request::configuration_report_restore_status_request(
    configuration_report_restore_status_request &&other470)
{
    pid = std::move(other470.pid);
    restore_status = std::move(other470.restore_status);
    progress = std::move(other470.progress);
    reason = std::move(other470.reason);
    __isset = std::move(other470.__isset);
}
configuration_report_restore_status_request &configuration_report_restore_status_request::
operator=(const configuration_report_restore_status_request &other471)
{
    pid = other471.pid;
    restore_status = other471.restore_status;
    progress = other471.progress;
    reason = other471.reason;
    __isset = other471.__isset;
    return *this;
}
configuration_report_restore_status_request &configuration_report_restore_status_request::
operator=(configuration_report_restore_status_request &&other472)
{
    pid = std::move(other472.pid);
    restore_status = std::move(other472.restore_status);
    progress = std::move(other472.progress);
    reason = std::move(other472.reason);
    __isset = std::move(other472.__isset);
    return *this;
}
void configuration_report_restore_status_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_report_restore_status_request(";
    out << "pid=" << to_string(pid);
    out << ", "
        << "restore_status=" << to_string(restore_status);
    out << ", "
        << "progress=" << to_string(progress);
    out << ", "
        << "reason=";
    (__isset.reason ? (out << to_string(reason)) : (out << "<null>"));
    out << ")";
}

configuration_report_restore_status_response::
    ~configuration_report_restore_status_response() throw()
{
}

void configuration_report_restore_status_response::__set_err(const ::dsn::error_code &val)
{
    this->err = val;
}

uint32_t
configuration_report_restore_status_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t configuration_report_restore_status_response::write(
    ::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_report_restore_status_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_report_restore_status_response &a,
          configuration_report_restore_status_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.__isset, b.__isset);
}

configuration_report_restore_status_response::configuration_report_restore_status_response(
    const configuration_report_restore_status_response &other473)
{
    err = other473.err;
    __isset = other473.__isset;
}
configuration_report_restore_status_response::configuration_report_restore_status_response(
    configuration_report_restore_status_response &&other474)
{
    err = std::move(other474.err);
    __isset = std::move(other474.__isset);
}
configuration_report_restore_status_response &configuration_report_restore_status_response::
operator=(const configuration_report_restore_status_response &other475)
{
    err = other475.err;
    __isset = other475.__isset;
    return *this;
}
configuration_report_restore_status_response &configuration_report_restore_status_response::
operator=(configuration_report_restore_status_response &&other476)
{
    err = std::move(other476.err);
    __isset = std::move(other476.__isset);
    return *this;
}
void configuration_report_restore_status_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_report_restore_status_response(";
    out << "err=" << to_string(err);
    out << ")";
}

configuration_query_restore_request::~configuration_query_restore_request() throw() {}

void configuration_query_restore_request::__set_restore_app_id(const int32_t val)
{
    this->restore_app_id = val;
}

uint32_t configuration_query_restore_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->restore_app_id);
                this->__isset.restore_app_id = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t
configuration_query_restore_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_query_restore_request");

    xfer += oprot->writeFieldBegin("restore_app_id", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->restore_app_id);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_query_restore_request &a, configuration_query_restore_request &b)
{
    using ::std::swap;
    swap(a.restore_app_id, b.restore_app_id);
    swap(a.__isset, b.__isset);
}

configuration_query_restore_request::configuration_query_restore_request(
    const configuration_query_restore_request &other477)
{
    restore_app_id = other477.restore_app_id;
    __isset = other477.__isset;
}
configuration_query_restore_request::configuration_query_restore_request(
    configuration_query_restore_request &&other478)
{
    restore_app_id = std::move(other478.restore_app_id);
    __isset = std::move(other478.__isset);
}
configuration_query_restore_request &configuration_query_restore_request::
operator=(const configuration_query_restore_request &other479)
{
    restore_app_id = other479.restore_app_id;
    __isset = other479.__isset;
    return *this;
}
configuration_query_restore_request &configuration_query_restore_request::
operator=(configuration_query_restore_request &&other480)
{
    restore_app_id = std::move(other480.restore_app_id);
    __isset = std::move(other480.__isset);
    return *this;
}
void configuration_query_restore_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_query_restore_request(";
    out << "restore_app_id=" << to_string(restore_app_id);
    out << ")";
}

configuration_query_restore_response::~configuration_query_restore_response() throw() {}

void configuration_query_restore_response::__set_err(const ::dsn::error_code &val)
{
    this->err = val;
}

void configuration_query_restore_response::__set_restore_status(
    const std::vector<::dsn::error_code> &val)
{
    this->restore_status = val;
}

void configuration_query_restore_response::__set_restore_progress(const std::vector<int32_t> &val)
{
    this->restore_progress = val;
}

uint32_t configuration_query_restore_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->restore_status.clear();
                    uint32_t _size481;
                    ::apache::thrift::protocol::TType _etype484;
                    xfer += iprot->readListBegin(_etype484, _size481);
                    this->restore_status.resize(_size481);
                    uint32_t _i485;
                    for (_i485 = 0; _i485 < _size481; ++_i485) {
                        xfer += this->restore_status[_i485].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.restore_status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->restore_progress.clear();
                    uint32_t _size486;
                    ::apache::thrift::protocol::TType _etype489;
                    xfer += iprot->readListBegin(_etype489, _size486);
                    this->restore_progress.resize(_size486);
                    uint32_t _i490;
                    for (_i490 = 0; _i490 < _size486; ++_i490) {
                        xfer += iprot->readI32(this->restore_progress[_i490]);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.restore_progress = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t
configuration_query_restore_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_query_restore_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("restore_status", ::apache::thrift::protocol::T_LIST, 2);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                      static_cast<uint32_t>(this->restore_status.size()));
        std::vector<::dsn::error_code>::const_iterator _iter491;
        for (_iter491 = this->restore_status.begin(); _iter491 != this->restore_status.end();
             ++_iter491) {
            xfer += (*_iter491).write(oprot);
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("restore_progress", ::apache::thrift::protocol::T_LIST, 3);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32,
                                      static_cast<uint32_t>(this->restore_progress.size()));
        std::vector<int32_t>::const_iterator _iter492;
        for (_iter492 = this->restore_progress.begin(); _iter492 != this->restore_progress.end();
             ++_iter492) {
            xfer += oprot->writeI32((*_iter492));
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_query_restore_response &a, configuration_query_restore_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.restore_status, b.restore_status);
    swap(a.restore_progress, b.restore_progress);
    swap(a.__isset, b.__isset);
}

configuration_query_restore_response::configuration_query_restore_response(
    const configuration_query_restore_response &other493)
{
    err = other493.err;
    restore_status = other493.restore_status;
    restore_progress = other493.restore_progress;
    __isset = other493.__isset;
}
configuration_query_restore_response::configuration_query_restore_response(
    configuration_query_restore_response &&other494)
{
    err = std::move(other494.err);
    restore_status = std::move(other494.restore_status);
    restore_progress = std::move(other494.restore_progress);
    __isset = std::move(other494.__isset);
}
configuration_query_restore_response &configuration_query_restore_response::
operator=(const configuration_query_restore_response &other495)
{
    err = other495.err;
    restore_status = other495.restore_status;
    restore_progress = other495.restore_progress;
    __isset = other495.__isset;
    return *this;
}
configuration_query_restore_response &configuration_query_restore_response::
operator=(configuration_query_restore_response &&other496)
{
    err = std::move(other496.err);
    restore_status = std::move(other496.restore_status);
    restore_progress = std::move(other496.restore_progress);
    __isset = std::move(other496.__isset);
    return *this;
}
void configuration_query_restore_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_query_restore_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "restore_status=" << to_string(restore_status);
    out << ", "
        << "restore_progress=" << to_string(restore_progress);
    out << ")";
}

file_meta::~file_meta() throw() {}

void file_meta::__set_name(const std::string &val) { this->name = val; }

void file_meta::__set_size(const int64_t val) { this->size = val; }

void file_meta::__set_md5(const std::string &val) { this->md5 = val; }

uint32_t file_meta::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->name);
                this->__isset.name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->size);
                this->__isset.size = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->md5);
                this->__isset.md5 = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t file_meta::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("file_meta");

    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("md5", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->md5);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(file_meta &a, file_meta &b)
{
    using ::std::swap;
    swap(a.name, b.name);
    swap(a.size, b.size);
    swap(a.md5, b.md5);
    swap(a.__isset, b.__isset);
}

file_meta::file_meta(const file_meta &other497)
{
    name = other497.name;
    size = other497.size;
    md5 = other497.md5;
    __isset = other497.__isset;
}
file_meta::file_meta(file_meta &&other498)
{
    name = std::move(other498.name);
    size = std::move(other498.size);
    md5 = std::move(other498.md5);
    __isset = std::move(other498.__isset);
}
file_meta &file_meta::operator=(const file_meta &other499)
{
    name = other499.name;
    size = other499.size;
    md5 = other499.md5;
    __isset = other499.__isset;
    return *this;
}
file_meta &file_meta::operator=(file_meta &&other500)
{
    name = std::move(other500.name);
    size = std::move(other500.size);
    md5 = std::move(other500.md5);
    __isset = std::move(other500.__isset);
    return *this;
}
void file_meta::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "file_meta(";
    out << "name=" << to_string(name);
    out << ", "
        << "size=" << to_string(size);
    out << ", "
        << "md5=" << to_string(md5);
    out << ")";
}

configuration_update_app_env_request::~configuration_update_app_env_request() throw() {}

void configuration_update_app_env_request::__set_app_name(const std::string &val)
{
    this->app_name = val;
}

void configuration_update_app_env_request::__set_op(const app_env_operation::type val)
{
    this->op = val;
}

void configuration_update_app_env_request::__set_keys(const std::vector<std::string> &val)
{
    this->keys = val;
    __isset.keys = true;
}

void configuration_update_app_env_request::__set_values(const std::vector<std::string> &val)
{
    this->values = val;
    __isset.values = true;
}

void configuration_update_app_env_request::__set_clear_prefix(const std::string &val)
{
    this->clear_prefix = val;
    __isset.clear_prefix = true;
}

uint32_t configuration_update_app_env_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast501;
                xfer += iprot->readI32(ecast501);
                this->op = (app_env_operation::type)ecast501;
                this->__isset.op = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->keys.clear();
                    uint32_t _size502;
                    ::apache::thrift::protocol::TType _etype505;
                    xfer += iprot->readListBegin(_etype505, _size502);
                    this->keys.resize(_size502);
                    uint32_t _i506;
                    for (_i506 = 0; _i506 < _size502; ++_i506) {
                        xfer += iprot->readString(this->keys[_i506]);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.keys = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->values.clear();
                    uint32_t _size507;
                    ::apache::thrift::protocol::TType _etype510;
                    xfer += iprot->readListBegin(_etype510, _size507);
                    this->values.resize(_size507);
                    uint32_t _i511;
                    for (_i511 = 0; _i511 < _size507; ++_i511) {
                        xfer += iprot->readString(this->values[_i511]);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.values = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->clear_prefix);
                this->__isset.clear_prefix = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t
configuration_update_app_env_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_update_app_env_request");

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->op);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.keys) {
        xfer += oprot->writeFieldBegin("keys", ::apache::thrift::protocol::T_LIST, 3);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING,
                                          static_cast<uint32_t>(this->keys.size()));
            std::vector<std::string>::const_iterator _iter512;
            for (_iter512 = this->keys.begin(); _iter512 != this->keys.end(); ++_iter512) {
                xfer += oprot->writeString((*_iter512));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.values) {
        xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 4);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING,
                                          static_cast<uint32_t>(this->values.size()));
            std::vector<std::string>::const_iterator _iter513;
            for (_iter513 = this->values.begin(); _iter513 != this->values.end(); ++_iter513) {
                xfer += oprot->writeString((*_iter513));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.clear_prefix) {
        xfer += oprot->writeFieldBegin("clear_prefix", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->clear_prefix);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_update_app_env_request &a, configuration_update_app_env_request &b)
{
    using ::std::swap;
    swap(a.app_name, b.app_name);
    swap(a.op, b.op);
    swap(a.keys, b.keys);
    swap(a.values, b.values);
    swap(a.clear_prefix, b.clear_prefix);
    swap(a.__isset, b.__isset);
}

configuration_update_app_env_request::configuration_update_app_env_request(
    const configuration_update_app_env_request &other514)
{
    app_name = other514.app_name;
    op = other514.op;
    keys = other514.keys;
    values = other514.values;
    clear_prefix = other514.clear_prefix;
    __isset = other514.__isset;
}
configuration_update_app_env_request::configuration_update_app_env_request(
    configuration_update_app_env_request &&other515)
{
    app_name = std::move(other515.app_name);
    op = std::move(other515.op);
    keys = std::move(other515.keys);
    values = std::move(other515.values);
    clear_prefix = std::move(other515.clear_prefix);
    __isset = std::move(other515.__isset);
}
configuration_update_app_env_request &configuration_update_app_env_request::
operator=(const configuration_update_app_env_request &other516)
{
    app_name = other516.app_name;
    op = other516.op;
    keys = other516.keys;
    values = other516.values;
    clear_prefix = other516.clear_prefix;
    __isset = other516.__isset;
    return *this;
}
configuration_update_app_env_request &configuration_update_app_env_request::
operator=(configuration_update_app_env_request &&other517)
{
    app_name = std::move(other517.app_name);
    op = std::move(other517.op);
    keys = std::move(other517.keys);
    values = std::move(other517.values);
    clear_prefix = std::move(other517.clear_prefix);
    __isset = std::move(other517.__isset);
    return *this;
}
void configuration_update_app_env_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_update_app_env_request(";
    out << "app_name=" << to_string(app_name);
    out << ", "
        << "op=" << to_string(op);
    out << ", "
        << "keys=";
    (__isset.keys ? (out << to_string(keys)) : (out << "<null>"));
    out << ", "
        << "values=";
    (__isset.values ? (out << to_string(values)) : (out << "<null>"));
    out << ", "
        << "clear_prefix=";
    (__isset.clear_prefix ? (out << to_string(clear_prefix)) : (out << "<null>"));
    out << ")";
}

configuration_update_app_env_response::~configuration_update_app_env_response() throw() {}

void configuration_update_app_env_response::__set_err(const ::dsn::error_code &val)
{
    this->err = val;
}

void configuration_update_app_env_response::__set_hint_message(const std::string &val)
{
    this->hint_message = val;
}

uint32_t configuration_update_app_env_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->hint_message);
                this->__isset.hint_message = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t
configuration_update_app_env_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("configuration_update_app_env_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("hint_message", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->hint_message);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(configuration_update_app_env_response &a, configuration_update_app_env_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.hint_message, b.hint_message);
    swap(a.__isset, b.__isset);
}

configuration_update_app_env_response::configuration_update_app_env_response(
    const configuration_update_app_env_response &other518)
{
    err = other518.err;
    hint_message = other518.hint_message;
    __isset = other518.__isset;
}
configuration_update_app_env_response::configuration_update_app_env_response(
    configuration_update_app_env_response &&other519)
{
    err = std::move(other519.err);
    hint_message = std::move(other519.hint_message);
    __isset = std::move(other519.__isset);
}
configuration_update_app_env_response &configuration_update_app_env_response::
operator=(const configuration_update_app_env_response &other520)
{
    err = other520.err;
    hint_message = other520.hint_message;
    __isset = other520.__isset;
    return *this;
}
configuration_update_app_env_response &configuration_update_app_env_response::
operator=(configuration_update_app_env_response &&other521)
{
    err = std::move(other521.err);
    hint_message = std::move(other521.hint_message);
    __isset = std::move(other521.__isset);
    return *this;
}
void configuration_update_app_env_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "configuration_update_app_env_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "hint_message=" << to_string(hint_message);
    out << ")";
}

duplication_add_request::~duplication_add_request() throw() {}

void duplication_add_request::__set_app_name(const std::string &val) { this->app_name = val; }

void duplication_add_request::__set_remote_cluster_name(const std::string &val)
{
    this->remote_cluster_name = val;
}

void duplication_add_request::__set_freezed(const bool val) { this->freezed = val; }

uint32_t duplication_add_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->remote_cluster_name);
                this->__isset.remote_cluster_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->freezed);
                this->__isset.freezed = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t duplication_add_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("duplication_add_request");

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("remote_cluster_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->remote_cluster_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("freezed", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->freezed);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(duplication_add_request &a, duplication_add_request &b)
{
    using ::std::swap;
    swap(a.app_name, b.app_name);
    swap(a.remote_cluster_name, b.remote_cluster_name);
    swap(a.freezed, b.freezed);
    swap(a.__isset, b.__isset);
}

duplication_add_request::duplication_add_request(const duplication_add_request &other522)
{
    app_name = other522.app_name;
    remote_cluster_name = other522.remote_cluster_name;
    freezed = other522.freezed;
    __isset = other522.__isset;
}
duplication_add_request::duplication_add_request(duplication_add_request &&other523)
{
    app_name = std::move(other523.app_name);
    remote_cluster_name = std::move(other523.remote_cluster_name);
    freezed = std::move(other523.freezed);
    __isset = std::move(other523.__isset);
}
duplication_add_request &duplication_add_request::operator=(const duplication_add_request &other524)
{
    app_name = other524.app_name;
    remote_cluster_name = other524.remote_cluster_name;
    freezed = other524.freezed;
    __isset = other524.__isset;
    return *this;
}
duplication_add_request &duplication_add_request::operator=(duplication_add_request &&other525)
{
    app_name = std::move(other525.app_name);
    remote_cluster_name = std::move(other525.remote_cluster_name);
    freezed = std::move(other525.freezed);
    __isset = std::move(other525.__isset);
    return *this;
}
void duplication_add_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "duplication_add_request(";
    out << "app_name=" << to_string(app_name);
    out << ", "
        << "remote_cluster_name=" << to_string(remote_cluster_name);
    out << ", "
        << "freezed=" << to_string(freezed);
    out << ")";
}

duplication_add_response::~duplication_add_response() throw() {}

void duplication_add_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void duplication_add_response::__set_appid(const int32_t val) { this->appid = val; }

void duplication_add_response::__set_dupid(const int32_t val) { this->dupid = val; }

void duplication_add_response::__set_hint(const std::string &val)
{
    this->hint = val;
    __isset.hint = true;
}

uint32_t duplication_add_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->appid);
                this->__isset.appid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->dupid);
                this->__isset.dupid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->hint);
                this->__isset.hint = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t duplication_add_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("duplication_add_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("appid", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->appid);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("dupid", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->dupid);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.hint) {
        xfer += oprot->writeFieldBegin("hint", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->hint);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(duplication_add_response &a, duplication_add_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.appid, b.appid);
    swap(a.dupid, b.dupid);
    swap(a.hint, b.hint);
    swap(a.__isset, b.__isset);
}

duplication_add_response::duplication_add_response(const duplication_add_response &other526)
{
    err = other526.err;
    appid = other526.appid;
    dupid = other526.dupid;
    hint = other526.hint;
    __isset = other526.__isset;
}
duplication_add_response::duplication_add_response(duplication_add_response &&other527)
{
    err = std::move(other527.err);
    appid = std::move(other527.appid);
    dupid = std::move(other527.dupid);
    hint = std::move(other527.hint);
    __isset = std::move(other527.__isset);
}
duplication_add_response &duplication_add_response::
operator=(const duplication_add_response &other528)
{
    err = other528.err;
    appid = other528.appid;
    dupid = other528.dupid;
    hint = other528.hint;
    __isset = other528.__isset;
    return *this;
}
duplication_add_response &duplication_add_response::operator=(duplication_add_response &&other529)
{
    err = std::move(other529.err);
    appid = std::move(other529.appid);
    dupid = std::move(other529.dupid);
    hint = std::move(other529.hint);
    __isset = std::move(other529.__isset);
    return *this;
}
void duplication_add_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "duplication_add_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "appid=" << to_string(appid);
    out << ", "
        << "dupid=" << to_string(dupid);
    out << ", "
        << "hint=";
    (__isset.hint ? (out << to_string(hint)) : (out << "<null>"));
    out << ")";
}

duplication_modify_request::~duplication_modify_request() throw() {}

void duplication_modify_request::__set_app_name(const std::string &val) { this->app_name = val; }

void duplication_modify_request::__set_dupid(const int32_t val) { this->dupid = val; }

void duplication_modify_request::__set_status(const duplication_status::type val)
{
    this->status = val;
    __isset.status = true;
}

void duplication_modify_request::__set_fail_mode(const duplication_fail_mode::type val)
{
    this->fail_mode = val;
    __isset.fail_mode = true;
}

uint32_t duplication_modify_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->dupid);
                this->__isset.dupid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast530;
                xfer += iprot->readI32(ecast530);
                this->status = (duplication_status::type)ecast530;
                this->__isset.status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast531;
                xfer += iprot->readI32(ecast531);
                this->fail_mode = (duplication_fail_mode::type)ecast531;
                this->__isset.fail_mode = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t duplication_modify_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("duplication_modify_request");

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("dupid", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->dupid);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.status) {
        xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 3);
        xfer += oprot->writeI32((int32_t)this->status);
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.fail_mode) {
        xfer += oprot->writeFieldBegin("fail_mode", ::apache::thrift::protocol::T_I32, 4);
        xfer += oprot->writeI32((int32_t)this->fail_mode);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(duplication_modify_request &a, duplication_modify_request &b)
{
    using ::std::swap;
    swap(a.app_name, b.app_name);
    swap(a.dupid, b.dupid);
    swap(a.status, b.status);
    swap(a.fail_mode, b.fail_mode);
    swap(a.__isset, b.__isset);
}

duplication_modify_request::duplication_modify_request(const duplication_modify_request &other532)
{
    app_name = other532.app_name;
    dupid = other532.dupid;
    status = other532.status;
    fail_mode = other532.fail_mode;
    __isset = other532.__isset;
}
duplication_modify_request::duplication_modify_request(duplication_modify_request &&other533)
{
    app_name = std::move(other533.app_name);
    dupid = std::move(other533.dupid);
    status = std::move(other533.status);
    fail_mode = std::move(other533.fail_mode);
    __isset = std::move(other533.__isset);
}
duplication_modify_request &duplication_modify_request::
operator=(const duplication_modify_request &other534)
{
    app_name = other534.app_name;
    dupid = other534.dupid;
    status = other534.status;
    fail_mode = other534.fail_mode;
    __isset = other534.__isset;
    return *this;
}
duplication_modify_request &duplication_modify_request::
operator=(duplication_modify_request &&other535)
{
    app_name = std::move(other535.app_name);
    dupid = std::move(other535.dupid);
    status = std::move(other535.status);
    fail_mode = std::move(other535.fail_mode);
    __isset = std::move(other535.__isset);
    return *this;
}
void duplication_modify_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "duplication_modify_request(";
    out << "app_name=" << to_string(app_name);
    out << ", "
        << "dupid=" << to_string(dupid);
    out << ", "
        << "status=";
    (__isset.status ? (out << to_string(status)) : (out << "<null>"));
    out << ", "
        << "fail_mode=";
    (__isset.fail_mode ? (out << to_string(fail_mode)) : (out << "<null>"));
    out << ")";
}

duplication_modify_response::~duplication_modify_response() throw() {}

void duplication_modify_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void duplication_modify_response::__set_appid(const int32_t val) { this->appid = val; }

uint32_t duplication_modify_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->appid);
                this->__isset.appid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t duplication_modify_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("duplication_modify_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("appid", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->appid);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(duplication_modify_response &a, duplication_modify_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.appid, b.appid);
    swap(a.__isset, b.__isset);
}

duplication_modify_response::duplication_modify_response(
    const duplication_modify_response &other536)
{
    err = other536.err;
    appid = other536.appid;
    __isset = other536.__isset;
}
duplication_modify_response::duplication_modify_response(duplication_modify_response &&other537)
{
    err = std::move(other537.err);
    appid = std::move(other537.appid);
    __isset = std::move(other537.__isset);
}
duplication_modify_response &duplication_modify_response::
operator=(const duplication_modify_response &other538)
{
    err = other538.err;
    appid = other538.appid;
    __isset = other538.__isset;
    return *this;
}
duplication_modify_response &duplication_modify_response::
operator=(duplication_modify_response &&other539)
{
    err = std::move(other539.err);
    appid = std::move(other539.appid);
    __isset = std::move(other539.__isset);
    return *this;
}
void duplication_modify_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "duplication_modify_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "appid=" << to_string(appid);
    out << ")";
}

duplication_entry::~duplication_entry() throw() {}

void duplication_entry::__set_dupid(const int32_t val) { this->dupid = val; }

void duplication_entry::__set_status(const duplication_status::type val) { this->status = val; }

void duplication_entry::__set_remote(const std::string &val) { this->remote = val; }

void duplication_entry::__set_create_ts(const int64_t val) { this->create_ts = val; }

void duplication_entry::__set_progress(const std::map<int32_t, int64_t> &val)
{
    this->progress = val;
    __isset.progress = true;
}

void duplication_entry::__set_fail_mode(const duplication_fail_mode::type val)
{
    this->fail_mode = val;
    __isset.fail_mode = true;
}

uint32_t duplication_entry::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->dupid);
                this->__isset.dupid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast540;
                xfer += iprot->readI32(ecast540);
                this->status = (duplication_status::type)ecast540;
                this->__isset.status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->remote);
                this->__isset.remote = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->create_ts);
                this->__isset.create_ts = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_MAP) {
                {
                    this->progress.clear();
                    uint32_t _size541;
                    ::apache::thrift::protocol::TType _ktype542;
                    ::apache::thrift::protocol::TType _vtype543;
                    xfer += iprot->readMapBegin(_ktype542, _vtype543, _size541);
                    uint32_t _i545;
                    for (_i545 = 0; _i545 < _size541; ++_i545) {
                        int32_t _key546;
                        xfer += iprot->readI32(_key546);
                        int64_t &_val547 = this->progress[_key546];
                        xfer += iprot->readI64(_val547);
                    }
                    xfer += iprot->readMapEnd();
                }
                this->__isset.progress = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 7:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast548;
                xfer += iprot->readI32(ecast548);
                this->fail_mode = (duplication_fail_mode::type)ecast548;
                this->__isset.fail_mode = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t duplication_entry::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("duplication_entry");

    xfer += oprot->writeFieldBegin("dupid", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->dupid);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("remote", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->remote);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("create_ts", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->create_ts);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.progress) {
        xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_MAP, 5);
        {
            xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32,
                                         ::apache::thrift::protocol::T_I64,
                                         static_cast<uint32_t>(this->progress.size()));
            std::map<int32_t, int64_t>::const_iterator _iter549;
            for (_iter549 = this->progress.begin(); _iter549 != this->progress.end(); ++_iter549) {
                xfer += oprot->writeI32(_iter549->first);
                xfer += oprot->writeI64(_iter549->second);
            }
            xfer += oprot->writeMapEnd();
        }
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.fail_mode) {
        xfer += oprot->writeFieldBegin("fail_mode", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32((int32_t)this->fail_mode);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(duplication_entry &a, duplication_entry &b)
{
    using ::std::swap;
    swap(a.dupid, b.dupid);
    swap(a.status, b.status);
    swap(a.remote, b.remote);
    swap(a.create_ts, b.create_ts);
    swap(a.progress, b.progress);
    swap(a.fail_mode, b.fail_mode);
    swap(a.__isset, b.__isset);
}

duplication_entry::duplication_entry(const duplication_entry &other550)
{
    dupid = other550.dupid;
    status = other550.status;
    remote = other550.remote;
    create_ts = other550.create_ts;
    progress = other550.progress;
    fail_mode = other550.fail_mode;
    __isset = other550.__isset;
}
duplication_entry::duplication_entry(duplication_entry &&other551)
{
    dupid = std::move(other551.dupid);
    status = std::move(other551.status);
    remote = std::move(other551.remote);
    create_ts = std::move(other551.create_ts);
    progress = std::move(other551.progress);
    fail_mode = std::move(other551.fail_mode);
    __isset = std::move(other551.__isset);
}
duplication_entry &duplication_entry::operator=(const duplication_entry &other552)
{
    dupid = other552.dupid;
    status = other552.status;
    remote = other552.remote;
    create_ts = other552.create_ts;
    progress = other552.progress;
    fail_mode = other552.fail_mode;
    __isset = other552.__isset;
    return *this;
}
duplication_entry &duplication_entry::operator=(duplication_entry &&other553)
{
    dupid = std::move(other553.dupid);
    status = std::move(other553.status);
    remote = std::move(other553.remote);
    create_ts = std::move(other553.create_ts);
    progress = std::move(other553.progress);
    fail_mode = std::move(other553.fail_mode);
    __isset = std::move(other553.__isset);
    return *this;
}
void duplication_entry::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "duplication_entry(";
    out << "dupid=" << to_string(dupid);
    out << ", "
        << "status=" << to_string(status);
    out << ", "
        << "remote=" << to_string(remote);
    out << ", "
        << "create_ts=" << to_string(create_ts);
    out << ", "
        << "progress=";
    (__isset.progress ? (out << to_string(progress)) : (out << "<null>"));
    out << ", "
        << "fail_mode=";
    (__isset.fail_mode ? (out << to_string(fail_mode)) : (out << "<null>"));
    out << ")";
}

duplication_query_request::~duplication_query_request() throw() {}

void duplication_query_request::__set_app_name(const std::string &val) { this->app_name = val; }

uint32_t duplication_query_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t duplication_query_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("duplication_query_request");

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(duplication_query_request &a, duplication_query_request &b)
{
    using ::std::swap;
    swap(a.app_name, b.app_name);
    swap(a.__isset, b.__isset);
}

duplication_query_request::duplication_query_request(const duplication_query_request &other554)
{
    app_name = other554.app_name;
    __isset = other554.__isset;
}
duplication_query_request::duplication_query_request(duplication_query_request &&other555)
{
    app_name = std::move(other555.app_name);
    __isset = std::move(other555.__isset);
}
duplication_query_request &duplication_query_request::
operator=(const duplication_query_request &other556)
{
    app_name = other556.app_name;
    __isset = other556.__isset;
    return *this;
}
duplication_query_request &duplication_query_request::
operator=(duplication_query_request &&other557)
{
    app_name = std::move(other557.app_name);
    __isset = std::move(other557.__isset);
    return *this;
}
void duplication_query_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "duplication_query_request(";
    out << "app_name=" << to_string(app_name);
    out << ")";
}

duplication_query_response::~duplication_query_response() throw() {}

void duplication_query_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void duplication_query_response::__set_appid(const int32_t val) { this->appid = val; }

void duplication_query_response::__set_entry_list(const std::vector<duplication_entry> &val)
{
    this->entry_list = val;
}

uint32_t duplication_query_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->appid);
                this->__isset.appid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->entry_list.clear();
                    uint32_t _size558;
                    ::apache::thrift::protocol::TType _etype561;
                    xfer += iprot->readListBegin(_etype561, _size558);
                    this->entry_list.resize(_size558);
                    uint32_t _i562;
                    for (_i562 = 0; _i562 < _size558; ++_i562) {
                        xfer += this->entry_list[_i562].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.entry_list = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t duplication_query_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("duplication_query_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("appid", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->appid);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("entry_list", ::apache::thrift::protocol::T_LIST, 4);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                      static_cast<uint32_t>(this->entry_list.size()));
        std::vector<duplication_entry>::const_iterator _iter563;
        for (_iter563 = this->entry_list.begin(); _iter563 != this->entry_list.end(); ++_iter563) {
            xfer += (*_iter563).write(oprot);
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(duplication_query_response &a, duplication_query_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.appid, b.appid);
    swap(a.entry_list, b.entry_list);
    swap(a.__isset, b.__isset);
}

duplication_query_response::duplication_query_response(const duplication_query_response &other564)
{
    err = other564.err;
    appid = other564.appid;
    entry_list = other564.entry_list;
    __isset = other564.__isset;
}
duplication_query_response::duplication_query_response(duplication_query_response &&other565)
{
    err = std::move(other565.err);
    appid = std::move(other565.appid);
    entry_list = std::move(other565.entry_list);
    __isset = std::move(other565.__isset);
}
duplication_query_response &duplication_query_response::
operator=(const duplication_query_response &other566)
{
    err = other566.err;
    appid = other566.appid;
    entry_list = other566.entry_list;
    __isset = other566.__isset;
    return *this;
}
duplication_query_response &duplication_query_response::
operator=(duplication_query_response &&other567)
{
    err = std::move(other567.err);
    appid = std::move(other567.appid);
    entry_list = std::move(other567.entry_list);
    __isset = std::move(other567.__isset);
    return *this;
}
void duplication_query_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "duplication_query_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "appid=" << to_string(appid);
    out << ", "
        << "entry_list=" << to_string(entry_list);
    out << ")";
}

duplication_confirm_entry::~duplication_confirm_entry() throw() {}

void duplication_confirm_entry::__set_dupid(const int32_t val) { this->dupid = val; }

void duplication_confirm_entry::__set_confirmed_decree(const int64_t val)
{
    this->confirmed_decree = val;
}

uint32_t duplication_confirm_entry::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->dupid);
                this->__isset.dupid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->confirmed_decree);
                this->__isset.confirmed_decree = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t duplication_confirm_entry::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("duplication_confirm_entry");

    xfer += oprot->writeFieldBegin("dupid", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->dupid);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("confirmed_decree", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->confirmed_decree);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(duplication_confirm_entry &a, duplication_confirm_entry &b)
{
    using ::std::swap;
    swap(a.dupid, b.dupid);
    swap(a.confirmed_decree, b.confirmed_decree);
    swap(a.__isset, b.__isset);
}

duplication_confirm_entry::duplication_confirm_entry(const duplication_confirm_entry &other568)
{
    dupid = other568.dupid;
    confirmed_decree = other568.confirmed_decree;
    __isset = other568.__isset;
}
duplication_confirm_entry::duplication_confirm_entry(duplication_confirm_entry &&other569)
{
    dupid = std::move(other569.dupid);
    confirmed_decree = std::move(other569.confirmed_decree);
    __isset = std::move(other569.__isset);
}
duplication_confirm_entry &duplication_confirm_entry::
operator=(const duplication_confirm_entry &other570)
{
    dupid = other570.dupid;
    confirmed_decree = other570.confirmed_decree;
    __isset = other570.__isset;
    return *this;
}
duplication_confirm_entry &duplication_confirm_entry::
operator=(duplication_confirm_entry &&other571)
{
    dupid = std::move(other571.dupid);
    confirmed_decree = std::move(other571.confirmed_decree);
    __isset = std::move(other571.__isset);
    return *this;
}
void duplication_confirm_entry::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "duplication_confirm_entry(";
    out << "dupid=" << to_string(dupid);
    out << ", "
        << "confirmed_decree=" << to_string(confirmed_decree);
    out << ")";
}

duplication_sync_request::~duplication_sync_request() throw() {}

void duplication_sync_request::__set_node(const ::dsn::rpc_address &val) { this->node = val; }

void duplication_sync_request::__set_confirm_list(
    const std::map<::dsn::gpid, std::vector<duplication_confirm_entry>> &val)
{
    this->confirm_list = val;
}

uint32_t duplication_sync_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->node.read(iprot);
                this->__isset.node = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_MAP) {
                {
                    this->confirm_list.clear();
                    uint32_t _size572;
                    ::apache::thrift::protocol::TType _ktype573;
                    ::apache::thrift::protocol::TType _vtype574;
                    xfer += iprot->readMapBegin(_ktype573, _vtype574, _size572);
                    uint32_t _i576;
                    for (_i576 = 0; _i576 < _size572; ++_i576) {
                        ::dsn::gpid _key577;
                        xfer += _key577.read(iprot);
                        std::vector<duplication_confirm_entry> &_val578 =
                            this->confirm_list[_key577];
                        {
                            _val578.clear();
                            uint32_t _size579;
                            ::apache::thrift::protocol::TType _etype582;
                            xfer += iprot->readListBegin(_etype582, _size579);
                            _val578.resize(_size579);
                            uint32_t _i583;
                            for (_i583 = 0; _i583 < _size579; ++_i583) {
                                xfer += _val578[_i583].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                    }
                    xfer += iprot->readMapEnd();
                }
                this->__isset.confirm_list = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t duplication_sync_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("duplication_sync_request");

    xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->node.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("confirm_list", ::apache::thrift::protocol::T_MAP, 2);
    {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT,
                                     ::apache::thrift::protocol::T_LIST,
                                     static_cast<uint32_t>(this->confirm_list.size()));
        std::map<::dsn::gpid, std::vector<duplication_confirm_entry>>::const_iterator _iter584;
        for (_iter584 = this->confirm_list.begin(); _iter584 != this->confirm_list.end();
             ++_iter584) {
            xfer += _iter584->first.write(oprot);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                              static_cast<uint32_t>(_iter584->second.size()));
                std::vector<duplication_confirm_entry>::const_iterator _iter585;
                for (_iter585 = _iter584->second.begin(); _iter585 != _iter584->second.end();
                     ++_iter585) {
                    xfer += (*_iter585).write(oprot);
                }
                xfer += oprot->writeListEnd();
            }
        }
        xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(duplication_sync_request &a, duplication_sync_request &b)
{
    using ::std::swap;
    swap(a.node, b.node);
    swap(a.confirm_list, b.confirm_list);
    swap(a.__isset, b.__isset);
}

duplication_sync_request::duplication_sync_request(const duplication_sync_request &other586)
{
    node = other586.node;
    confirm_list = other586.confirm_list;
    __isset = other586.__isset;
}
duplication_sync_request::duplication_sync_request(duplication_sync_request &&other587)
{
    node = std::move(other587.node);
    confirm_list = std::move(other587.confirm_list);
    __isset = std::move(other587.__isset);
}
duplication_sync_request &duplication_sync_request::
operator=(const duplication_sync_request &other588)
{
    node = other588.node;
    confirm_list = other588.confirm_list;
    __isset = other588.__isset;
    return *this;
}
duplication_sync_request &duplication_sync_request::operator=(duplication_sync_request &&other589)
{
    node = std::move(other589.node);
    confirm_list = std::move(other589.confirm_list);
    __isset = std::move(other589.__isset);
    return *this;
}
void duplication_sync_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "duplication_sync_request(";
    out << "node=" << to_string(node);
    out << ", "
        << "confirm_list=" << to_string(confirm_list);
    out << ")";
}

duplication_sync_response::~duplication_sync_response() throw() {}

void duplication_sync_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void duplication_sync_response::__set_dup_map(
    const std::map<int32_t, std::map<int32_t, duplication_entry>> &val)
{
    this->dup_map = val;
}

uint32_t duplication_sync_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_MAP) {
                {
                    this->dup_map.clear();
                    uint32_t _size590;
                    ::apache::thrift::protocol::TType _ktype591;
                    ::apache::thrift::protocol::TType _vtype592;
                    xfer += iprot->readMapBegin(_ktype591, _vtype592, _size590);
                    uint32_t _i594;
                    for (_i594 = 0; _i594 < _size590; ++_i594) {
                        int32_t _key595;
                        xfer += iprot->readI32(_key595);
                        std::map<int32_t, duplication_entry> &_val596 = this->dup_map[_key595];
                        {
                            _val596.clear();
                            uint32_t _size597;
                            ::apache::thrift::protocol::TType _ktype598;
                            ::apache::thrift::protocol::TType _vtype599;
                            xfer += iprot->readMapBegin(_ktype598, _vtype599, _size597);
                            uint32_t _i601;
                            for (_i601 = 0; _i601 < _size597; ++_i601) {
                                int32_t _key602;
                                xfer += iprot->readI32(_key602);
                                duplication_entry &_val603 = _val596[_key602];
                                xfer += _val603.read(iprot);
                            }
                            xfer += iprot->readMapEnd();
                        }
                    }
                    xfer += iprot->readMapEnd();
                }
                this->__isset.dup_map = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t duplication_sync_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("duplication_sync_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("dup_map", ::apache::thrift::protocol::T_MAP, 2);
    {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32,
                                     ::apache::thrift::protocol::T_MAP,
                                     static_cast<uint32_t>(this->dup_map.size()));
        std::map<int32_t, std::map<int32_t, duplication_entry>>::const_iterator _iter604;
        for (_iter604 = this->dup_map.begin(); _iter604 != this->dup_map.end(); ++_iter604) {
            xfer += oprot->writeI32(_iter604->first);
            {
                xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32,
                                             ::apache::thrift::protocol::T_STRUCT,
                                             static_cast<uint32_t>(_iter604->second.size()));
                std::map<int32_t, duplication_entry>::const_iterator _iter605;
                for (_iter605 = _iter604->second.begin(); _iter605 != _iter604->second.end();
                     ++_iter605) {
                    xfer += oprot->writeI32(_iter605->first);
                    xfer += _iter605->second.write(oprot);
                }
                xfer += oprot->writeMapEnd();
            }
        }
        xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(duplication_sync_response &a, duplication_sync_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.dup_map, b.dup_map);
    swap(a.__isset, b.__isset);
}

duplication_sync_response::duplication_sync_response(const duplication_sync_response &other606)
{
    err = other606.err;
    dup_map = other606.dup_map;
    __isset = other606.__isset;
}
duplication_sync_response::duplication_sync_response(duplication_sync_response &&other607)
{
    err = std::move(other607.err);
    dup_map = std::move(other607.dup_map);
    __isset = std::move(other607.__isset);
}
duplication_sync_response &duplication_sync_response::
operator=(const duplication_sync_response &other608)
{
    err = other608.err;
    dup_map = other608.dup_map;
    __isset = other608.__isset;
    return *this;
}
duplication_sync_response &duplication_sync_response::
operator=(duplication_sync_response &&other609)
{
    err = std::move(other609.err);
    dup_map = std::move(other609.dup_map);
    __isset = std::move(other609.__isset);
    return *this;
}
void duplication_sync_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "duplication_sync_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "dup_map=" << to_string(dup_map);
    out << ")";
}

ddd_diagnose_request::~ddd_diagnose_request() throw() {}

void ddd_diagnose_request::__set_pid(const ::dsn::gpid &val) { this->pid = val; }

uint32_t ddd_diagnose_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t ddd_diagnose_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("ddd_diagnose_request");

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(ddd_diagnose_request &a, ddd_diagnose_request &b)
{
    using ::std::swap;
    swap(a.pid, b.pid);
    swap(a.__isset, b.__isset);
}

ddd_diagnose_request::ddd_diagnose_request(const ddd_diagnose_request &other610)
{
    pid = other610.pid;
    __isset = other610.__isset;
}
ddd_diagnose_request::ddd_diagnose_request(ddd_diagnose_request &&other611)
{
    pid = std::move(other611.pid);
    __isset = std::move(other611.__isset);
}
ddd_diagnose_request &ddd_diagnose_request::operator=(const ddd_diagnose_request &other612)
{
    pid = other612.pid;
    __isset = other612.__isset;
    return *this;
}
ddd_diagnose_request &ddd_diagnose_request::operator=(ddd_diagnose_request &&other613)
{
    pid = std::move(other613.pid);
    __isset = std::move(other613.__isset);
    return *this;
}
void ddd_diagnose_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "ddd_diagnose_request(";
    out << "pid=" << to_string(pid);
    out << ")";
}

ddd_node_info::~ddd_node_info() throw() {}

void ddd_node_info::__set_node(const ::dsn::rpc_address &val) { this->node = val; }

void ddd_node_info::__set_drop_time_ms(const int64_t val) { this->drop_time_ms = val; }

void ddd_node_info::__set_is_alive(const bool val) { this->is_alive = val; }

void ddd_node_info::__set_is_collected(const bool val) { this->is_collected = val; }

void ddd_node_info::__set_ballot(const int64_t val) { this->ballot = val; }

void ddd_node_info::__set_last_committed_decree(const int64_t val)
{
    this->last_committed_decree = val;
}

void ddd_node_info::__set_last_prepared_decree(const int64_t val)
{
    this->last_prepared_decree = val;
}

uint32_t ddd_node_info::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->node.read(iprot);
                this->__isset.node = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->drop_time_ms);
                this->__isset.drop_time_ms = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->is_alive);
                this->__isset.is_alive = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->is_collected);
                this->__isset.is_collected = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->ballot);
                this->__isset.ballot = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->last_committed_decree);
                this->__isset.last_committed_decree = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 7:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->last_prepared_decree);
                this->__isset.last_prepared_decree = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t ddd_node_info::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("ddd_node_info");

    xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->node.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("drop_time_ms", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->drop_time_ms);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("is_alive", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->is_alive);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("is_collected", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->is_collected);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->ballot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("last_committed_decree", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->last_committed_decree);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("last_prepared_decree", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->last_prepared_decree);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(ddd_node_info &a, ddd_node_info &b)
{
    using ::std::swap;
    swap(a.node, b.node);
    swap(a.drop_time_ms, b.drop_time_ms);
    swap(a.is_alive, b.is_alive);
    swap(a.is_collected, b.is_collected);
    swap(a.ballot, b.ballot);
    swap(a.last_committed_decree, b.last_committed_decree);
    swap(a.last_prepared_decree, b.last_prepared_decree);
    swap(a.__isset, b.__isset);
}

ddd_node_info::ddd_node_info(const ddd_node_info &other614)
{
    node = other614.node;
    drop_time_ms = other614.drop_time_ms;
    is_alive = other614.is_alive;
    is_collected = other614.is_collected;
    ballot = other614.ballot;
    last_committed_decree = other614.last_committed_decree;
    last_prepared_decree = other614.last_prepared_decree;
    __isset = other614.__isset;
}
ddd_node_info::ddd_node_info(ddd_node_info &&other615)
{
    node = std::move(other615.node);
    drop_time_ms = std::move(other615.drop_time_ms);
    is_alive = std::move(other615.is_alive);
    is_collected = std::move(other615.is_collected);
    ballot = std::move(other615.ballot);
    last_committed_decree = std::move(other615.last_committed_decree);
    last_prepared_decree = std::move(other615.last_prepared_decree);
    __isset = std::move(other615.__isset);
}
ddd_node_info &ddd_node_info::operator=(const ddd_node_info &other616)
{
    node = other616.node;
    drop_time_ms = other616.drop_time_ms;
    is_alive = other616.is_alive;
    is_collected = other616.is_collected;
    ballot = other616.ballot;
    last_committed_decree = other616.last_committed_decree;
    last_prepared_decree = other616.last_prepared_decree;
    __isset = other616.__isset;
    return *this;
}
ddd_node_info &ddd_node_info::operator=(ddd_node_info &&other617)
{
    node = std::move(other617.node);
    drop_time_ms = std::move(other617.drop_time_ms);
    is_alive = std::move(other617.is_alive);
    is_collected = std::move(other617.is_collected);
    ballot = std::move(other617.ballot);
    last_committed_decree = std::move(other617.last_committed_decree);
    last_prepared_decree = std::move(other617.last_prepared_decree);
    __isset = std::move(other617.__isset);
    return *this;
}
void ddd_node_info::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "ddd_node_info(";
    out << "node=" << to_string(node);
    out << ", "
        << "drop_time_ms=" << to_string(drop_time_ms);
    out << ", "
        << "is_alive=" << to_string(is_alive);
    out << ", "
        << "is_collected=" << to_string(is_collected);
    out << ", "
        << "ballot=" << to_string(ballot);
    out << ", "
        << "last_committed_decree=" << to_string(last_committed_decree);
    out << ", "
        << "last_prepared_decree=" << to_string(last_prepared_decree);
    out << ")";
}

ddd_partition_info::~ddd_partition_info() throw() {}

void ddd_partition_info::__set_config(const ::dsn::partition_configuration &val)
{
    this->config = val;
}

void ddd_partition_info::__set_dropped(const std::vector<ddd_node_info> &val)
{
    this->dropped = val;
}

void ddd_partition_info::__set_reason(const std::string &val) { this->reason = val; }

uint32_t ddd_partition_info::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->config.read(iprot);
                this->__isset.config = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->dropped.clear();
                    uint32_t _size618;
                    ::apache::thrift::protocol::TType _etype621;
                    xfer += iprot->readListBegin(_etype621, _size618);
                    this->dropped.resize(_size618);
                    uint32_t _i622;
                    for (_i622 = 0; _i622 < _size618; ++_i622) {
                        xfer += this->dropped[_i622].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.dropped = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->reason);
                this->__isset.reason = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t ddd_partition_info::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("ddd_partition_info");

    xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->config.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("dropped", ::apache::thrift::protocol::T_LIST, 2);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                      static_cast<uint32_t>(this->dropped.size()));
        std::vector<ddd_node_info>::const_iterator _iter623;
        for (_iter623 = this->dropped.begin(); _iter623 != this->dropped.end(); ++_iter623) {
            xfer += (*_iter623).write(oprot);
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->reason);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(ddd_partition_info &a, ddd_partition_info &b)
{
    using ::std::swap;
    swap(a.config, b.config);
    swap(a.dropped, b.dropped);
    swap(a.reason, b.reason);
    swap(a.__isset, b.__isset);
}

ddd_partition_info::ddd_partition_info(const ddd_partition_info &other624)
{
    config = other624.config;
    dropped = other624.dropped;
    reason = other624.reason;
    __isset = other624.__isset;
}
ddd_partition_info::ddd_partition_info(ddd_partition_info &&other625)
{
    config = std::move(other625.config);
    dropped = std::move(other625.dropped);
    reason = std::move(other625.reason);
    __isset = std::move(other625.__isset);
}
ddd_partition_info &ddd_partition_info::operator=(const ddd_partition_info &other626)
{
    config = other626.config;
    dropped = other626.dropped;
    reason = other626.reason;
    __isset = other626.__isset;
    return *this;
}
ddd_partition_info &ddd_partition_info::operator=(ddd_partition_info &&other627)
{
    config = std::move(other627.config);
    dropped = std::move(other627.dropped);
    reason = std::move(other627.reason);
    __isset = std::move(other627.__isset);
    return *this;
}
void ddd_partition_info::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "ddd_partition_info(";
    out << "config=" << to_string(config);
    out << ", "
        << "dropped=" << to_string(dropped);
    out << ", "
        << "reason=" << to_string(reason);
    out << ")";
}

ddd_diagnose_response::~ddd_diagnose_response() throw() {}

void ddd_diagnose_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void ddd_diagnose_response::__set_partitions(const std::vector<ddd_partition_info> &val)
{
    this->partitions = val;
}

uint32_t ddd_diagnose_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->partitions.clear();
                    uint32_t _size628;
                    ::apache::thrift::protocol::TType _etype631;
                    xfer += iprot->readListBegin(_etype631, _size628);
                    this->partitions.resize(_size628);
                    uint32_t _i632;
                    for (_i632 = 0; _i632 < _size628; ++_i632) {
                        xfer += this->partitions[_i632].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.partitions = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t ddd_diagnose_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("ddd_diagnose_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 2);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                      static_cast<uint32_t>(this->partitions.size()));
        std::vector<ddd_partition_info>::const_iterator _iter633;
        for (_iter633 = this->partitions.begin(); _iter633 != this->partitions.end(); ++_iter633) {
            xfer += (*_iter633).write(oprot);
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(ddd_diagnose_response &a, ddd_diagnose_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.partitions, b.partitions);
    swap(a.__isset, b.__isset);
}

ddd_diagnose_response::ddd_diagnose_response(const ddd_diagnose_response &other634)
{
    err = other634.err;
    partitions = other634.partitions;
    __isset = other634.__isset;
}
ddd_diagnose_response::ddd_diagnose_response(ddd_diagnose_response &&other635)
{
    err = std::move(other635.err);
    partitions = std::move(other635.partitions);
    __isset = std::move(other635.__isset);
}
ddd_diagnose_response &ddd_diagnose_response::operator=(const ddd_diagnose_response &other636)
{
    err = other636.err;
    partitions = other636.partitions;
    __isset = other636.__isset;
    return *this;
}
ddd_diagnose_response &ddd_diagnose_response::operator=(ddd_diagnose_response &&other637)
{
    err = std::move(other637.err);
    partitions = std::move(other637.partitions);
    __isset = std::move(other637.__isset);
    return *this;
}
void ddd_diagnose_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "ddd_diagnose_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "partitions=" << to_string(partitions);
    out << ")";
}

start_partition_split_request::~start_partition_split_request() throw() {}

void start_partition_split_request::__set_app_name(const std::string &val) { this->app_name = val; }

void start_partition_split_request::__set_new_partition_count(const int32_t val)
{
    this->new_partition_count = val;
}

uint32_t start_partition_split_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->new_partition_count);
                this->__isset.new_partition_count = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t start_partition_split_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("start_partition_split_request");

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("new_partition_count", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->new_partition_count);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(start_partition_split_request &a, start_partition_split_request &b)
{
    using ::std::swap;
    swap(a.app_name, b.app_name);
    swap(a.new_partition_count, b.new_partition_count);
    swap(a.__isset, b.__isset);
}

start_partition_split_request::start_partition_split_request(
    const start_partition_split_request &other638)
{
    app_name = other638.app_name;
    new_partition_count = other638.new_partition_count;
    __isset = other638.__isset;
}
start_partition_split_request::start_partition_split_request(
    start_partition_split_request &&other639)
{
    app_name = std::move(other639.app_name);
    new_partition_count = std::move(other639.new_partition_count);
    __isset = std::move(other639.__isset);
}
start_partition_split_request &start_partition_split_request::
operator=(const start_partition_split_request &other640)
{
    app_name = other640.app_name;
    new_partition_count = other640.new_partition_count;
    __isset = other640.__isset;
    return *this;
}
start_partition_split_request &start_partition_split_request::
operator=(start_partition_split_request &&other641)
{
    app_name = std::move(other641.app_name);
    new_partition_count = std::move(other641.new_partition_count);
    __isset = std::move(other641.__isset);
    return *this;
}
void start_partition_split_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "start_partition_split_request(";
    out << "app_name=" << to_string(app_name);
    out << ", "
        << "new_partition_count=" << to_string(new_partition_count);
    out << ")";
}

start_partition_split_response::~start_partition_split_response() throw() {}

void start_partition_split_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void start_partition_split_response::__set_hint_msg(const std::string &val)
{
    this->hint_msg = val;
}

uint32_t start_partition_split_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->hint_msg);
                this->__isset.hint_msg = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t start_partition_split_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("start_partition_split_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("hint_msg", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->hint_msg);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(start_partition_split_response &a, start_partition_split_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.hint_msg, b.hint_msg);
    swap(a.__isset, b.__isset);
}

start_partition_split_response::start_partition_split_response(
    const start_partition_split_response &other642)
{
    err = other642.err;
    hint_msg = other642.hint_msg;
    __isset = other642.__isset;
}
start_partition_split_response::start_partition_split_response(
    start_partition_split_response &&other643)
{
    err = std::move(other643.err);
    hint_msg = std::move(other643.hint_msg);
    __isset = std::move(other643.__isset);
}
start_partition_split_response &start_partition_split_response::
operator=(const start_partition_split_response &other644)
{
    err = other644.err;
    hint_msg = other644.hint_msg;
    __isset = other644.__isset;
    return *this;
}
start_partition_split_response &start_partition_split_response::
operator=(start_partition_split_response &&other645)
{
    err = std::move(other645.err);
    hint_msg = std::move(other645.hint_msg);
    __isset = std::move(other645.__isset);
    return *this;
}
void start_partition_split_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "start_partition_split_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "hint_msg=" << to_string(hint_msg);
    out << ")";
}

control_split_request::~control_split_request() throw() {}

void control_split_request::__set_app_name(const std::string &val) { this->app_name = val; }

void control_split_request::__set_control_type(const split_control_type::type val)
{
    this->control_type = val;
}

void control_split_request::__set_parent_pidx(const int32_t val) { this->parent_pidx = val; }

void control_split_request::__set_old_partition_count(const int32_t val)
{
    this->old_partition_count = val;
    __isset.old_partition_count = true;
}

uint32_t control_split_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast646;
                xfer += iprot->readI32(ecast646);
                this->control_type = (split_control_type::type)ecast646;
                this->__isset.control_type = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->parent_pidx);
                this->__isset.parent_pidx = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->old_partition_count);
                this->__isset.old_partition_count = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t control_split_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("control_split_request");

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("control_type", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->control_type);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("parent_pidx", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->parent_pidx);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.old_partition_count) {
        xfer += oprot->writeFieldBegin("old_partition_count", ::apache::thrift::protocol::T_I32, 4);
        xfer += oprot->writeI32(this->old_partition_count);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(control_split_request &a, control_split_request &b)
{
    using ::std::swap;
    swap(a.app_name, b.app_name);
    swap(a.control_type, b.control_type);
    swap(a.parent_pidx, b.parent_pidx);
    swap(a.old_partition_count, b.old_partition_count);
    swap(a.__isset, b.__isset);
}

control_split_request::control_split_request(const control_split_request &other647)
{
    app_name = other647.app_name;
    control_type = other647.control_type;
    parent_pidx = other647.parent_pidx;
    old_partition_count = other647.old_partition_count;
    __isset = other647.__isset;
}
control_split_request::control_split_request(control_split_request &&other648)
{
    app_name = std::move(other648.app_name);
    control_type = std::move(other648.control_type);
    parent_pidx = std::move(other648.parent_pidx);
    old_partition_count = std::move(other648.old_partition_count);
    __isset = std::move(other648.__isset);
}
control_split_request &control_split_request::operator=(const control_split_request &other649)
{
    app_name = other649.app_name;
    control_type = other649.control_type;
    parent_pidx = other649.parent_pidx;
    old_partition_count = other649.old_partition_count;
    __isset = other649.__isset;
    return *this;
}
control_split_request &control_split_request::operator=(control_split_request &&other650)
{
    app_name = std::move(other650.app_name);
    control_type = std::move(other650.control_type);
    parent_pidx = std::move(other650.parent_pidx);
    old_partition_count = std::move(other650.old_partition_count);
    __isset = std::move(other650.__isset);
    return *this;
}
void control_split_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "control_split_request(";
    out << "app_name=" << to_string(app_name);
    out << ", "
        << "control_type=" << to_string(control_type);
    out << ", "
        << "parent_pidx=" << to_string(parent_pidx);
    out << ", "
        << "old_partition_count=";
    (__isset.old_partition_count ? (out << to_string(old_partition_count)) : (out << "<null>"));
    out << ")";
}

control_split_response::~control_split_response() throw() {}

void control_split_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void control_split_response::__set_hint_msg(const std::string &val)
{
    this->hint_msg = val;
    __isset.hint_msg = true;
}

uint32_t control_split_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->hint_msg);
                this->__isset.hint_msg = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t control_split_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("control_split_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.hint_msg) {
        xfer += oprot->writeFieldBegin("hint_msg", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->hint_msg);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(control_split_response &a, control_split_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.hint_msg, b.hint_msg);
    swap(a.__isset, b.__isset);
}

control_split_response::control_split_response(const control_split_response &other651)
{
    err = other651.err;
    hint_msg = other651.hint_msg;
    __isset = other651.__isset;
}
control_split_response::control_split_response(control_split_response &&other652)
{
    err = std::move(other652.err);
    hint_msg = std::move(other652.hint_msg);
    __isset = std::move(other652.__isset);
}
control_split_response &control_split_response::operator=(const control_split_response &other653)
{
    err = other653.err;
    hint_msg = other653.hint_msg;
    __isset = other653.__isset;
    return *this;
}
control_split_response &control_split_response::operator=(control_split_response &&other654)
{
    err = std::move(other654.err);
    hint_msg = std::move(other654.hint_msg);
    __isset = std::move(other654.__isset);
    return *this;
}
void control_split_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "control_split_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "hint_msg=";
    (__isset.hint_msg ? (out << to_string(hint_msg)) : (out << "<null>"));
    out << ")";
}

query_split_request::~query_split_request() throw() {}

void query_split_request::__set_app_name(const std::string &val) { this->app_name = val; }

uint32_t query_split_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t query_split_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("query_split_request");

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(query_split_request &a, query_split_request &b)
{
    using ::std::swap;
    swap(a.app_name, b.app_name);
    swap(a.__isset, b.__isset);
}

query_split_request::query_split_request(const query_split_request &other655)
{
    app_name = other655.app_name;
    __isset = other655.__isset;
}
query_split_request::query_split_request(query_split_request &&other656)
{
    app_name = std::move(other656.app_name);
    __isset = std::move(other656.__isset);
}
query_split_request &query_split_request::operator=(const query_split_request &other657)
{
    app_name = other657.app_name;
    __isset = other657.__isset;
    return *this;
}
query_split_request &query_split_request::operator=(query_split_request &&other658)
{
    app_name = std::move(other658.app_name);
    __isset = std::move(other658.__isset);
    return *this;
}
void query_split_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "query_split_request(";
    out << "app_name=" << to_string(app_name);
    out << ")";
}

query_split_response::~query_split_response() throw() {}

void query_split_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void query_split_response::__set_new_partition_count(const int32_t val)
{
    this->new_partition_count = val;
}

void query_split_response::__set_status(const std::map<int32_t, split_status::type> &val)
{
    this->status = val;
}

void query_split_response::__set_hint_msg(const std::string &val)
{
    this->hint_msg = val;
    __isset.hint_msg = true;
}

uint32_t query_split_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->new_partition_count);
                this->__isset.new_partition_count = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_MAP) {
                {
                    this->status.clear();
                    uint32_t _size659;
                    ::apache::thrift::protocol::TType _ktype660;
                    ::apache::thrift::protocol::TType _vtype661;
                    xfer += iprot->readMapBegin(_ktype660, _vtype661, _size659);
                    uint32_t _i663;
                    for (_i663 = 0; _i663 < _size659; ++_i663) {
                        int32_t _key664;
                        xfer += iprot->readI32(_key664);
                        split_status::type &_val665 = this->status[_key664];
                        int32_t ecast666;
                        xfer += iprot->readI32(ecast666);
                        _val665 = (split_status::type)ecast666;
                    }
                    xfer += iprot->readMapEnd();
                }
                this->__isset.status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->hint_msg);
                this->__isset.hint_msg = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t query_split_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("query_split_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("new_partition_count", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->new_partition_count);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_MAP, 3);
    {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32,
                                     ::apache::thrift::protocol::T_I32,
                                     static_cast<uint32_t>(this->status.size()));
        std::map<int32_t, split_status::type>::const_iterator _iter667;
        for (_iter667 = this->status.begin(); _iter667 != this->status.end(); ++_iter667) {
            xfer += oprot->writeI32(_iter667->first);
            xfer += oprot->writeI32((int32_t)_iter667->second);
        }
        xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();

    if (this->__isset.hint_msg) {
        xfer += oprot->writeFieldBegin("hint_msg", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->hint_msg);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(query_split_response &a, query_split_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.new_partition_count, b.new_partition_count);
    swap(a.status, b.status);
    swap(a.hint_msg, b.hint_msg);
    swap(a.__isset, b.__isset);
}

query_split_response::query_split_response(const query_split_response &other668)
{
    err = other668.err;
    new_partition_count = other668.new_partition_count;
    status = other668.status;
    hint_msg = other668.hint_msg;
    __isset = other668.__isset;
}
query_split_response::query_split_response(query_split_response &&other669)
{
    err = std::move(other669.err);
    new_partition_count = std::move(other669.new_partition_count);
    status = std::move(other669.status);
    hint_msg = std::move(other669.hint_msg);
    __isset = std::move(other669.__isset);
}
query_split_response &query_split_response::operator=(const query_split_response &other670)
{
    err = other670.err;
    new_partition_count = other670.new_partition_count;
    status = other670.status;
    hint_msg = other670.hint_msg;
    __isset = other670.__isset;
    return *this;
}
query_split_response &query_split_response::operator=(query_split_response &&other671)
{
    err = std::move(other671.err);
    new_partition_count = std::move(other671.new_partition_count);
    status = std::move(other671.status);
    hint_msg = std::move(other671.hint_msg);
    __isset = std::move(other671.__isset);
    return *this;
}
void query_split_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "query_split_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "new_partition_count=" << to_string(new_partition_count);
    out << ", "
        << "status=" << to_string(status);
    out << ", "
        << "hint_msg=";
    (__isset.hint_msg ? (out << to_string(hint_msg)) : (out << "<null>"));
    out << ")";
}

notify_catch_up_request::~notify_catch_up_request() throw() {}

void notify_catch_up_request::__set_parent_gpid(const ::dsn::gpid &val) { this->parent_gpid = val; }

void notify_catch_up_request::__set_child_gpid(const ::dsn::gpid &val) { this->child_gpid = val; }

void notify_catch_up_request::__set_child_ballot(const int64_t val) { this->child_ballot = val; }

void notify_catch_up_request::__set_child_address(const ::dsn::rpc_address &val)
{
    this->child_address = val;
}

uint32_t notify_catch_up_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->parent_gpid.read(iprot);
                this->__isset.parent_gpid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->child_gpid.read(iprot);
                this->__isset.child_gpid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->child_ballot);
                this->__isset.child_ballot = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->child_address.read(iprot);
                this->__isset.child_address = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t notify_catch_up_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("notify_catch_up_request");

    xfer += oprot->writeFieldBegin("parent_gpid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->parent_gpid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("child_gpid", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->child_gpid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("child_ballot", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->child_ballot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("child_address", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->child_address.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(notify_catch_up_request &a, notify_catch_up_request &b)
{
    using ::std::swap;
    swap(a.parent_gpid, b.parent_gpid);
    swap(a.child_gpid, b.child_gpid);
    swap(a.child_ballot, b.child_ballot);
    swap(a.child_address, b.child_address);
    swap(a.__isset, b.__isset);
}

notify_catch_up_request::notify_catch_up_request(const notify_catch_up_request &other672)
{
    parent_gpid = other672.parent_gpid;
    child_gpid = other672.child_gpid;
    child_ballot = other672.child_ballot;
    child_address = other672.child_address;
    __isset = other672.__isset;
}
notify_catch_up_request::notify_catch_up_request(notify_catch_up_request &&other673)
{
    parent_gpid = std::move(other673.parent_gpid);
    child_gpid = std::move(other673.child_gpid);
    child_ballot = std::move(other673.child_ballot);
    child_address = std::move(other673.child_address);
    __isset = std::move(other673.__isset);
}
notify_catch_up_request &notify_catch_up_request::operator=(const notify_catch_up_request &other674)
{
    parent_gpid = other674.parent_gpid;
    child_gpid = other674.child_gpid;
    child_ballot = other674.child_ballot;
    child_address = other674.child_address;
    __isset = other674.__isset;
    return *this;
}
notify_catch_up_request &notify_catch_up_request::operator=(notify_catch_up_request &&other675)
{
    parent_gpid = std::move(other675.parent_gpid);
    child_gpid = std::move(other675.child_gpid);
    child_ballot = std::move(other675.child_ballot);
    child_address = std::move(other675.child_address);
    __isset = std::move(other675.__isset);
    return *this;
}
void notify_catch_up_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "notify_catch_up_request(";
    out << "parent_gpid=" << to_string(parent_gpid);
    out << ", "
        << "child_gpid=" << to_string(child_gpid);
    out << ", "
        << "child_ballot=" << to_string(child_ballot);
    out << ", "
        << "child_address=" << to_string(child_address);
    out << ")";
}

notify_cacth_up_response::~notify_cacth_up_response() throw() {}

void notify_cacth_up_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

uint32_t notify_cacth_up_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t notify_cacth_up_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("notify_cacth_up_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(notify_cacth_up_response &a, notify_cacth_up_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.__isset, b.__isset);
}

notify_cacth_up_response::notify_cacth_up_response(const notify_cacth_up_response &other676)
{
    err = other676.err;
    __isset = other676.__isset;
}
notify_cacth_up_response::notify_cacth_up_response(notify_cacth_up_response &&other677)
{
    err = std::move(other677.err);
    __isset = std::move(other677.__isset);
}
notify_cacth_up_response &notify_cacth_up_response::
operator=(const notify_cacth_up_response &other678)
{
    err = other678.err;
    __isset = other678.__isset;
    return *this;
}
notify_cacth_up_response &notify_cacth_up_response::operator=(notify_cacth_up_response &&other679)
{
    err = std::move(other679.err);
    __isset = std::move(other679.__isset);
    return *this;
}
void notify_cacth_up_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "notify_cacth_up_response(";
    out << "err=" << to_string(err);
    out << ")";
}

update_child_group_partition_count_request::~update_child_group_partition_count_request() throw() {}

void update_child_group_partition_count_request::__set_target_address(const ::dsn::rpc_address &val)
{
    this->target_address = val;
}

void update_child_group_partition_count_request::__set_new_partition_count(const int32_t val)
{
    this->new_partition_count = val;
}

void update_child_group_partition_count_request::__set_child_pid(const ::dsn::gpid &val)
{
    this->child_pid = val;
}

void update_child_group_partition_count_request::__set_ballot(const int64_t val)
{
    this->ballot = val;
}

uint32_t
update_child_group_partition_count_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->target_address.read(iprot);
                this->__isset.target_address = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->new_partition_count);
                this->__isset.new_partition_count = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->child_pid.read(iprot);
                this->__isset.child_pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->ballot);
                this->__isset.ballot = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t update_child_group_partition_count_request::write(
    ::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("update_child_group_partition_count_request");

    xfer += oprot->writeFieldBegin("target_address", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->target_address.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("new_partition_count", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->new_partition_count);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("child_pid", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->child_pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->ballot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(update_child_group_partition_count_request &a,
          update_child_group_partition_count_request &b)
{
    using ::std::swap;
    swap(a.target_address, b.target_address);
    swap(a.new_partition_count, b.new_partition_count);
    swap(a.child_pid, b.child_pid);
    swap(a.ballot, b.ballot);
    swap(a.__isset, b.__isset);
}

update_child_group_partition_count_request::update_child_group_partition_count_request(
    const update_child_group_partition_count_request &other680)
{
    target_address = other680.target_address;
    new_partition_count = other680.new_partition_count;
    child_pid = other680.child_pid;
    ballot = other680.ballot;
    __isset = other680.__isset;
}
update_child_group_partition_count_request::update_child_group_partition_count_request(
    update_child_group_partition_count_request &&other681)
{
    target_address = std::move(other681.target_address);
    new_partition_count = std::move(other681.new_partition_count);
    child_pid = std::move(other681.child_pid);
    ballot = std::move(other681.ballot);
    __isset = std::move(other681.__isset);
}
update_child_group_partition_count_request &update_child_group_partition_count_request::
operator=(const update_child_group_partition_count_request &other682)
{
    target_address = other682.target_address;
    new_partition_count = other682.new_partition_count;
    child_pid = other682.child_pid;
    ballot = other682.ballot;
    __isset = other682.__isset;
    return *this;
}
update_child_group_partition_count_request &update_child_group_partition_count_request::
operator=(update_child_group_partition_count_request &&other683)
{
    target_address = std::move(other683.target_address);
    new_partition_count = std::move(other683.new_partition_count);
    child_pid = std::move(other683.child_pid);
    ballot = std::move(other683.ballot);
    __isset = std::move(other683.__isset);
    return *this;
}
void update_child_group_partition_count_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "update_child_group_partition_count_request(";
    out << "target_address=" << to_string(target_address);
    out << ", "
        << "new_partition_count=" << to_string(new_partition_count);
    out << ", "
        << "child_pid=" << to_string(child_pid);
    out << ", "
        << "ballot=" << to_string(ballot);
    out << ")";
}

update_child_group_partition_count_response::~update_child_group_partition_count_response() throw()
{
}

void update_child_group_partition_count_response::__set_err(const ::dsn::error_code &val)
{
    this->err = val;
}

uint32_t
update_child_group_partition_count_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t update_child_group_partition_count_response::write(
    ::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("update_child_group_partition_count_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(update_child_group_partition_count_response &a,
          update_child_group_partition_count_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.__isset, b.__isset);
}

update_child_group_partition_count_response::update_child_group_partition_count_response(
    const update_child_group_partition_count_response &other684)
{
    err = other684.err;
    __isset = other684.__isset;
}
update_child_group_partition_count_response::update_child_group_partition_count_response(
    update_child_group_partition_count_response &&other685)
{
    err = std::move(other685.err);
    __isset = std::move(other685.__isset);
}
update_child_group_partition_count_response &update_child_group_partition_count_response::
operator=(const update_child_group_partition_count_response &other686)
{
    err = other686.err;
    __isset = other686.__isset;
    return *this;
}
update_child_group_partition_count_response &update_child_group_partition_count_response::
operator=(update_child_group_partition_count_response &&other687)
{
    err = std::move(other687.err);
    __isset = std::move(other687.__isset);
    return *this;
}
void update_child_group_partition_count_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "update_child_group_partition_count_response(";
    out << "err=" << to_string(err);
    out << ")";
}

register_child_request::~register_child_request() throw() {}

void register_child_request::__set_app(const ::dsn::app_info &val) { this->app = val; }

void register_child_request::__set_parent_config(const ::dsn::partition_configuration &val)
{
    this->parent_config = val;
}

void register_child_request::__set_child_config(const ::dsn::partition_configuration &val)
{
    this->child_config = val;
}

void register_child_request::__set_primary_address(const ::dsn::rpc_address &val)
{
    this->primary_address = val;
}

uint32_t register_child_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->app.read(iprot);
                this->__isset.app = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->parent_config.read(iprot);
                this->__isset.parent_config = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->child_config.read(iprot);
                this->__isset.child_config = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->primary_address.read(iprot);
                this->__isset.primary_address = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t register_child_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("register_child_request");

    xfer += oprot->writeFieldBegin("app", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->app.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("parent_config", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->parent_config.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("child_config", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->child_config.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("primary_address", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->primary_address.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(register_child_request &a, register_child_request &b)
{
    using ::std::swap;
    swap(a.app, b.app);
    swap(a.parent_config, b.parent_config);
    swap(a.child_config, b.child_config);
    swap(a.primary_address, b.primary_address);
    swap(a.__isset, b.__isset);
}

register_child_request::register_child_request(const register_child_request &other688)
{
    app = other688.app;
    parent_config = other688.parent_config;
    child_config = other688.child_config;
    primary_address = other688.primary_address;
    __isset = other688.__isset;
}
register_child_request::register_child_request(register_child_request &&other689)
{
    app = std::move(other689.app);
    parent_config = std::move(other689.parent_config);
    child_config = std::move(other689.child_config);
    primary_address = std::move(other689.primary_address);
    __isset = std::move(other689.__isset);
}
register_child_request &register_child_request::operator=(const register_child_request &other690)
{
    app = other690.app;
    parent_config = other690.parent_config;
    child_config = other690.child_config;
    primary_address = other690.primary_address;
    __isset = other690.__isset;
    return *this;
}
register_child_request &register_child_request::operator=(register_child_request &&other691)
{
    app = std::move(other691.app);
    parent_config = std::move(other691.parent_config);
    child_config = std::move(other691.child_config);
    primary_address = std::move(other691.primary_address);
    __isset = std::move(other691.__isset);
    return *this;
}
void register_child_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "register_child_request(";
    out << "app=" << to_string(app);
    out << ", "
        << "parent_config=" << to_string(parent_config);
    out << ", "
        << "child_config=" << to_string(child_config);
    out << ", "
        << "primary_address=" << to_string(primary_address);
    out << ")";
}

register_child_response::~register_child_response() throw() {}

void register_child_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void register_child_response::__set_app(const ::dsn::app_info &val) { this->app = val; }

void register_child_response::__set_parent_config(const ::dsn::partition_configuration &val)
{
    this->parent_config = val;
}

void register_child_response::__set_child_config(const ::dsn::partition_configuration &val)
{
    this->child_config = val;
}

uint32_t register_child_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->app.read(iprot);
                this->__isset.app = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->parent_config.read(iprot);
                this->__isset.parent_config = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->child_config.read(iprot);
                this->__isset.child_config = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t register_child_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("register_child_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("app", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->app.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("parent_config", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->parent_config.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("child_config", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->child_config.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(register_child_response &a, register_child_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.app, b.app);
    swap(a.parent_config, b.parent_config);
    swap(a.child_config, b.child_config);
    swap(a.__isset, b.__isset);
}

register_child_response::register_child_response(const register_child_response &other692)
{
    err = other692.err;
    app = other692.app;
    parent_config = other692.parent_config;
    child_config = other692.child_config;
    __isset = other692.__isset;
}
register_child_response::register_child_response(register_child_response &&other693)
{
    err = std::move(other693.err);
    app = std::move(other693.app);
    parent_config = std::move(other693.parent_config);
    child_config = std::move(other693.child_config);
    __isset = std::move(other693.__isset);
}
register_child_response &register_child_response::operator=(const register_child_response &other694)
{
    err = other694.err;
    app = other694.app;
    parent_config = other694.parent_config;
    child_config = other694.child_config;
    __isset = other694.__isset;
    return *this;
}
register_child_response &register_child_response::operator=(register_child_response &&other695)
{
    err = std::move(other695.err);
    app = std::move(other695.app);
    parent_config = std::move(other695.parent_config);
    child_config = std::move(other695.child_config);
    __isset = std::move(other695.__isset);
    return *this;
}
void register_child_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "register_child_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "app=" << to_string(app);
    out << ", "
        << "parent_config=" << to_string(parent_config);
    out << ", "
        << "child_config=" << to_string(child_config);
    out << ")";
}

notify_stop_split_request::~notify_stop_split_request() throw() {}

void notify_stop_split_request::__set_app_name(const std::string &val) { this->app_name = val; }

void notify_stop_split_request::__set_parent_gpid(const ::dsn::gpid &val)
{
    this->parent_gpid = val;
}

void notify_stop_split_request::__set_meta_split_status(const split_status::type val)
{
    this->meta_split_status = val;
}

void notify_stop_split_request::__set_partition_count(const int32_t val)
{
    this->partition_count = val;
}

uint32_t notify_stop_split_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->parent_gpid.read(iprot);
                this->__isset.parent_gpid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast696;
                xfer += iprot->readI32(ecast696);
                this->meta_split_status = (split_status::type)ecast696;
                this->__isset.meta_split_status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->partition_count);
                this->__isset.partition_count = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t notify_stop_split_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("notify_stop_split_request");

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("parent_gpid", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->parent_gpid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("meta_split_status", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->meta_split_status);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("partition_count", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->partition_count);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(notify_stop_split_request &a, notify_stop_split_request &b)
{
    using ::std::swap;
    swap(a.app_name, b.app_name);
    swap(a.parent_gpid, b.parent_gpid);
    swap(a.meta_split_status, b.meta_split_status);
    swap(a.partition_count, b.partition_count);
    swap(a.__isset, b.__isset);
}

notify_stop_split_request::notify_stop_split_request(const notify_stop_split_request &other697)
{
    app_name = other697.app_name;
    parent_gpid = other697.parent_gpid;
    meta_split_status = other697.meta_split_status;
    partition_count = other697.partition_count;
    __isset = other697.__isset;
}
notify_stop_split_request::notify_stop_split_request(notify_stop_split_request &&other698)
{
    app_name = std::move(other698.app_name);
    parent_gpid = std::move(other698.parent_gpid);
    meta_split_status = std::move(other698.meta_split_status);
    partition_count = std::move(other698.partition_count);
    __isset = std::move(other698.__isset);
}
notify_stop_split_request &notify_stop_split_request::
operator=(const notify_stop_split_request &other699)
{
    app_name = other699.app_name;
    parent_gpid = other699.parent_gpid;
    meta_split_status = other699.meta_split_status;
    partition_count = other699.partition_count;
    __isset = other699.__isset;
    return *this;
}
notify_stop_split_request &notify_stop_split_request::
operator=(notify_stop_split_request &&other700)
{
    app_name = std::move(other700.app_name);
    parent_gpid = std::move(other700.parent_gpid);
    meta_split_status = std::move(other700.meta_split_status);
    partition_count = std::move(other700.partition_count);
    __isset = std::move(other700.__isset);
    return *this;
}
void notify_stop_split_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "notify_stop_split_request(";
    out << "app_name=" << to_string(app_name);
    out << ", "
        << "parent_gpid=" << to_string(parent_gpid);
    out << ", "
        << "meta_split_status=" << to_string(meta_split_status);
    out << ", "
        << "partition_count=" << to_string(partition_count);
    out << ")";
}

notify_stop_split_response::~notify_stop_split_response() throw() {}

void notify_stop_split_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

uint32_t notify_stop_split_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t notify_stop_split_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("notify_stop_split_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(notify_stop_split_response &a, notify_stop_split_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.__isset, b.__isset);
}

notify_stop_split_response::notify_stop_split_response(const notify_stop_split_response &other701)
{
    err = other701.err;
    __isset = other701.__isset;
}
notify_stop_split_response::notify_stop_split_response(notify_stop_split_response &&other702)
{
    err = std::move(other702.err);
    __isset = std::move(other702.__isset);
}
notify_stop_split_response &notify_stop_split_response::
operator=(const notify_stop_split_response &other703)
{
    err = other703.err;
    __isset = other703.__isset;
    return *this;
}
notify_stop_split_response &notify_stop_split_response::
operator=(notify_stop_split_response &&other704)
{
    err = std::move(other704.err);
    __isset = std::move(other704.__isset);
    return *this;
}
void notify_stop_split_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "notify_stop_split_response(";
    out << "err=" << to_string(err);
    out << ")";
}

bulk_load_metadata::~bulk_load_metadata() throw() {}

void bulk_load_metadata::__set_files(const std::vector<file_meta> &val) { this->files = val; }

void bulk_load_metadata::__set_file_total_size(const int64_t val) { this->file_total_size = val; }

uint32_t bulk_load_metadata::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->files.clear();
                    uint32_t _size705;
                    ::apache::thrift::protocol::TType _etype708;
                    xfer += iprot->readListBegin(_etype708, _size705);
                    this->files.resize(_size705);
                    uint32_t _i709;
                    for (_i709 = 0; _i709 < _size705; ++_i709) {
                        xfer += this->files[_i709].read(iprot);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.files = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->file_total_size);
                this->__isset.file_total_size = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t bulk_load_metadata::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("bulk_load_metadata");

    xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_LIST, 1);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                      static_cast<uint32_t>(this->files.size()));
        std::vector<file_meta>::const_iterator _iter710;
        for (_iter710 = this->files.begin(); _iter710 != this->files.end(); ++_iter710) {
            xfer += (*_iter710).write(oprot);
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("file_total_size", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->file_total_size);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(bulk_load_metadata &a, bulk_load_metadata &b)
{
    using ::std::swap;
    swap(a.files, b.files);
    swap(a.file_total_size, b.file_total_size);
    swap(a.__isset, b.__isset);
}

bulk_load_metadata::bulk_load_metadata(const bulk_load_metadata &other711)
{
    files = other711.files;
    file_total_size = other711.file_total_size;
    __isset = other711.__isset;
}
bulk_load_metadata::bulk_load_metadata(bulk_load_metadata &&other712)
{
    files = std::move(other712.files);
    file_total_size = std::move(other712.file_total_size);
    __isset = std::move(other712.__isset);
}
bulk_load_metadata &bulk_load_metadata::operator=(const bulk_load_metadata &other713)
{
    files = other713.files;
    file_total_size = other713.file_total_size;
    __isset = other713.__isset;
    return *this;
}
bulk_load_metadata &bulk_load_metadata::operator=(bulk_load_metadata &&other714)
{
    files = std::move(other714.files);
    file_total_size = std::move(other714.file_total_size);
    __isset = std::move(other714.__isset);
    return *this;
}
void bulk_load_metadata::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "bulk_load_metadata(";
    out << "files=" << to_string(files);
    out << ", "
        << "file_total_size=" << to_string(file_total_size);
    out << ")";
}

start_bulk_load_request::~start_bulk_load_request() throw() {}

void start_bulk_load_request::__set_app_name(const std::string &val) { this->app_name = val; }

void start_bulk_load_request::__set_cluster_name(const std::string &val)
{
    this->cluster_name = val;
}

void start_bulk_load_request::__set_file_provider_type(const std::string &val)
{
    this->file_provider_type = val;
}

void start_bulk_load_request::__set_remote_root_path(const std::string &val)
{
    this->remote_root_path = val;
}

uint32_t start_bulk_load_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->cluster_name);
                this->__isset.cluster_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->file_provider_type);
                this->__isset.file_provider_type = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->remote_root_path);
                this->__isset.remote_root_path = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t start_bulk_load_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("start_bulk_load_request");

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("cluster_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->cluster_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("file_provider_type", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->file_provider_type);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("remote_root_path", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->remote_root_path);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(start_bulk_load_request &a, start_bulk_load_request &b)
{
    using ::std::swap;
    swap(a.app_name, b.app_name);
    swap(a.cluster_name, b.cluster_name);
    swap(a.file_provider_type, b.file_provider_type);
    swap(a.remote_root_path, b.remote_root_path);
    swap(a.__isset, b.__isset);
}

start_bulk_load_request::start_bulk_load_request(const start_bulk_load_request &other715)
{
    app_name = other715.app_name;
    cluster_name = other715.cluster_name;
    file_provider_type = other715.file_provider_type;
    remote_root_path = other715.remote_root_path;
    __isset = other715.__isset;
}
start_bulk_load_request::start_bulk_load_request(start_bulk_load_request &&other716)
{
    app_name = std::move(other716.app_name);
    cluster_name = std::move(other716.cluster_name);
    file_provider_type = std::move(other716.file_provider_type);
    remote_root_path = std::move(other716.remote_root_path);
    __isset = std::move(other716.__isset);
}
start_bulk_load_request &start_bulk_load_request::operator=(const start_bulk_load_request &other717)
{
    app_name = other717.app_name;
    cluster_name = other717.cluster_name;
    file_provider_type = other717.file_provider_type;
    remote_root_path = other717.remote_root_path;
    __isset = other717.__isset;
    return *this;
}
start_bulk_load_request &start_bulk_load_request::operator=(start_bulk_load_request &&other718)
{
    app_name = std::move(other718.app_name);
    cluster_name = std::move(other718.cluster_name);
    file_provider_type = std::move(other718.file_provider_type);
    remote_root_path = std::move(other718.remote_root_path);
    __isset = std::move(other718.__isset);
    return *this;
}
void start_bulk_load_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "start_bulk_load_request(";
    out << "app_name=" << to_string(app_name);
    out << ", "
        << "cluster_name=" << to_string(cluster_name);
    out << ", "
        << "file_provider_type=" << to_string(file_provider_type);
    out << ", "
        << "remote_root_path=" << to_string(remote_root_path);
    out << ")";
}

start_bulk_load_response::~start_bulk_load_response() throw() {}

void start_bulk_load_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void start_bulk_load_response::__set_hint_msg(const std::string &val) { this->hint_msg = val; }

uint32_t start_bulk_load_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->hint_msg);
                this->__isset.hint_msg = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t start_bulk_load_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("start_bulk_load_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("hint_msg", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->hint_msg);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(start_bulk_load_response &a, start_bulk_load_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.hint_msg, b.hint_msg);
    swap(a.__isset, b.__isset);
}

start_bulk_load_response::start_bulk_load_response(const start_bulk_load_response &other719)
{
    err = other719.err;
    hint_msg = other719.hint_msg;
    __isset = other719.__isset;
}
start_bulk_load_response::start_bulk_load_response(start_bulk_load_response &&other720)
{
    err = std::move(other720.err);
    hint_msg = std::move(other720.hint_msg);
    __isset = std::move(other720.__isset);
}
start_bulk_load_response &start_bulk_load_response::
operator=(const start_bulk_load_response &other721)
{
    err = other721.err;
    hint_msg = other721.hint_msg;
    __isset = other721.__isset;
    return *this;
}
start_bulk_load_response &start_bulk_load_response::operator=(start_bulk_load_response &&other722)
{
    err = std::move(other722.err);
    hint_msg = std::move(other722.hint_msg);
    __isset = std::move(other722.__isset);
    return *this;
}
void start_bulk_load_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "start_bulk_load_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "hint_msg=" << to_string(hint_msg);
    out << ")";
}

partition_bulk_load_state::~partition_bulk_load_state() throw() {}

void partition_bulk_load_state::__set_download_progress(const int32_t val)
{
    this->download_progress = val;
    __isset.download_progress = true;
}

void partition_bulk_load_state::__set_download_status(const ::dsn::error_code &val)
{
    this->download_status = val;
    __isset.download_status = true;
}

void partition_bulk_load_state::__set_ingest_status(const ingestion_status::type val)
{
    this->ingest_status = val;
    __isset.ingest_status = true;
}

void partition_bulk_load_state::__set_is_cleaned_up(const bool val)
{
    this->is_cleaned_up = val;
    __isset.is_cleaned_up = true;
}

void partition_bulk_load_state::__set_is_paused(const bool val)
{
    this->is_paused = val;
    __isset.is_paused = true;
}

uint32_t partition_bulk_load_state::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->download_progress);
                this->__isset.download_progress = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->download_status.read(iprot);
                this->__isset.download_status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast723;
                xfer += iprot->readI32(ecast723);
                this->ingest_status = (ingestion_status::type)ecast723;
                this->__isset.ingest_status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->is_cleaned_up);
                this->__isset.is_cleaned_up = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->is_paused);
                this->__isset.is_paused = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t partition_bulk_load_state::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("partition_bulk_load_state");

    if (this->__isset.download_progress) {
        xfer += oprot->writeFieldBegin("download_progress", ::apache::thrift::protocol::T_I32, 1);
        xfer += oprot->writeI32(this->download_progress);
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.download_status) {
        xfer += oprot->writeFieldBegin("download_status", ::apache::thrift::protocol::T_STRUCT, 2);
        xfer += this->download_status.write(oprot);
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.ingest_status) {
        xfer += oprot->writeFieldBegin("ingest_status", ::apache::thrift::protocol::T_I32, 3);
        xfer += oprot->writeI32((int32_t)this->ingest_status);
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.is_cleaned_up) {
        xfer += oprot->writeFieldBegin("is_cleaned_up", ::apache::thrift::protocol::T_BOOL, 4);
        xfer += oprot->writeBool(this->is_cleaned_up);
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.is_paused) {
        xfer += oprot->writeFieldBegin("is_paused", ::apache::thrift::protocol::T_BOOL, 5);
        xfer += oprot->writeBool(this->is_paused);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(partition_bulk_load_state &a, partition_bulk_load_state &b)
{
    using ::std::swap;
    swap(a.download_progress, b.download_progress);
    swap(a.download_status, b.download_status);
    swap(a.ingest_status, b.ingest_status);
    swap(a.is_cleaned_up, b.is_cleaned_up);
    swap(a.is_paused, b.is_paused);
    swap(a.__isset, b.__isset);
}

partition_bulk_load_state::partition_bulk_load_state(const partition_bulk_load_state &other724)
{
    download_progress = other724.download_progress;
    download_status = other724.download_status;
    ingest_status = other724.ingest_status;
    is_cleaned_up = other724.is_cleaned_up;
    is_paused = other724.is_paused;
    __isset = other724.__isset;
}
partition_bulk_load_state::partition_bulk_load_state(partition_bulk_load_state &&other725)
{
    download_progress = std::move(other725.download_progress);
    download_status = std::move(other725.download_status);
    ingest_status = std::move(other725.ingest_status);
    is_cleaned_up = std::move(other725.is_cleaned_up);
    is_paused = std::move(other725.is_paused);
    __isset = std::move(other725.__isset);
}
partition_bulk_load_state &partition_bulk_load_state::
operator=(const partition_bulk_load_state &other726)
{
    download_progress = other726.download_progress;
    download_status = other726.download_status;
    ingest_status = other726.ingest_status;
    is_cleaned_up = other726.is_cleaned_up;
    is_paused = other726.is_paused;
    __isset = other726.__isset;
    return *this;
}
partition_bulk_load_state &partition_bulk_load_state::
operator=(partition_bulk_load_state &&other727)
{
    download_progress = std::move(other727.download_progress);
    download_status = std::move(other727.download_status);
    ingest_status = std::move(other727.ingest_status);
    is_cleaned_up = std::move(other727.is_cleaned_up);
    is_paused = std::move(other727.is_paused);
    __isset = std::move(other727.__isset);
    return *this;
}
void partition_bulk_load_state::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "partition_bulk_load_state(";
    out << "download_progress=";
    (__isset.download_progress ? (out << to_string(download_progress)) : (out << "<null>"));
    out << ", "
        << "download_status=";
    (__isset.download_status ? (out << to_string(download_status)) : (out << "<null>"));
    out << ", "
        << "ingest_status=";
    (__isset.ingest_status ? (out << to_string(ingest_status)) : (out << "<null>"));
    out << ", "
        << "is_cleaned_up=";
    (__isset.is_cleaned_up ? (out << to_string(is_cleaned_up)) : (out << "<null>"));
    out << ", "
        << "is_paused=";
    (__isset.is_paused ? (out << to_string(is_paused)) : (out << "<null>"));
    out << ")";
}

bulk_load_request::~bulk_load_request() throw() {}

void bulk_load_request::__set_pid(const ::dsn::gpid &val) { this->pid = val; }

void bulk_load_request::__set_app_name(const std::string &val) { this->app_name = val; }

void bulk_load_request::__set_primary_addr(const ::dsn::rpc_address &val)
{
    this->primary_addr = val;
}

void bulk_load_request::__set_remote_provider_name(const std::string &val)
{
    this->remote_provider_name = val;
}

void bulk_load_request::__set_cluster_name(const std::string &val) { this->cluster_name = val; }

void bulk_load_request::__set_ballot(const int64_t val) { this->ballot = val; }

void bulk_load_request::__set_meta_bulk_load_status(const bulk_load_status::type val)
{
    this->meta_bulk_load_status = val;
}

void bulk_load_request::__set_query_bulk_load_metadata(const bool val)
{
    this->query_bulk_load_metadata = val;
}

void bulk_load_request::__set_remote_root_path(const std::string &val)
{
    this->remote_root_path = val;
}

uint32_t bulk_load_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->primary_addr.read(iprot);
                this->__isset.primary_addr = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->remote_provider_name);
                this->__isset.remote_provider_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->cluster_name);
                this->__isset.cluster_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->ballot);
                this->__isset.ballot = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 7:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast728;
                xfer += iprot->readI32(ecast728);
                this->meta_bulk_load_status = (bulk_load_status::type)ecast728;
                this->__isset.meta_bulk_load_status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 8:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->query_bulk_load_metadata);
                this->__isset.query_bulk_load_metadata = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 9:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->remote_root_path);
                this->__isset.remote_root_path = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t bulk_load_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("bulk_load_request");

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("primary_addr", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->primary_addr.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("remote_provider_name", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->remote_provider_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("cluster_name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->cluster_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->ballot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("meta_bulk_load_status", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->meta_bulk_load_status);
    xfer += oprot->writeFieldEnd();

    xfer +=
        oprot->writeFieldBegin("query_bulk_load_metadata", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->query_bulk_load_metadata);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("remote_root_path", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->remote_root_path);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(bulk_load_request &a, bulk_load_request &b)
{
    using ::std::swap;
    swap(a.pid, b.pid);
    swap(a.app_name, b.app_name);
    swap(a.primary_addr, b.primary_addr);
    swap(a.remote_provider_name, b.remote_provider_name);
    swap(a.cluster_name, b.cluster_name);
    swap(a.ballot, b.ballot);
    swap(a.meta_bulk_load_status, b.meta_bulk_load_status);
    swap(a.query_bulk_load_metadata, b.query_bulk_load_metadata);
    swap(a.remote_root_path, b.remote_root_path);
    swap(a.__isset, b.__isset);
}

bulk_load_request::bulk_load_request(const bulk_load_request &other729)
{
    pid = other729.pid;
    app_name = other729.app_name;
    primary_addr = other729.primary_addr;
    remote_provider_name = other729.remote_provider_name;
    cluster_name = other729.cluster_name;
    ballot = other729.ballot;
    meta_bulk_load_status = other729.meta_bulk_load_status;
    query_bulk_load_metadata = other729.query_bulk_load_metadata;
    remote_root_path = other729.remote_root_path;
    __isset = other729.__isset;
}
bulk_load_request::bulk_load_request(bulk_load_request &&other730)
{
    pid = std::move(other730.pid);
    app_name = std::move(other730.app_name);
    primary_addr = std::move(other730.primary_addr);
    remote_provider_name = std::move(other730.remote_provider_name);
    cluster_name = std::move(other730.cluster_name);
    ballot = std::move(other730.ballot);
    meta_bulk_load_status = std::move(other730.meta_bulk_load_status);
    query_bulk_load_metadata = std::move(other730.query_bulk_load_metadata);
    remote_root_path = std::move(other730.remote_root_path);
    __isset = std::move(other730.__isset);
}
bulk_load_request &bulk_load_request::operator=(const bulk_load_request &other731)
{
    pid = other731.pid;
    app_name = other731.app_name;
    primary_addr = other731.primary_addr;
    remote_provider_name = other731.remote_provider_name;
    cluster_name = other731.cluster_name;
    ballot = other731.ballot;
    meta_bulk_load_status = other731.meta_bulk_load_status;
    query_bulk_load_metadata = other731.query_bulk_load_metadata;
    remote_root_path = other731.remote_root_path;
    __isset = other731.__isset;
    return *this;
}
bulk_load_request &bulk_load_request::operator=(bulk_load_request &&other732)
{
    pid = std::move(other732.pid);
    app_name = std::move(other732.app_name);
    primary_addr = std::move(other732.primary_addr);
    remote_provider_name = std::move(other732.remote_provider_name);
    cluster_name = std::move(other732.cluster_name);
    ballot = std::move(other732.ballot);
    meta_bulk_load_status = std::move(other732.meta_bulk_load_status);
    query_bulk_load_metadata = std::move(other732.query_bulk_load_metadata);
    remote_root_path = std::move(other732.remote_root_path);
    __isset = std::move(other732.__isset);
    return *this;
}
void bulk_load_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "bulk_load_request(";
    out << "pid=" << to_string(pid);
    out << ", "
        << "app_name=" << to_string(app_name);
    out << ", "
        << "primary_addr=" << to_string(primary_addr);
    out << ", "
        << "remote_provider_name=" << to_string(remote_provider_name);
    out << ", "
        << "cluster_name=" << to_string(cluster_name);
    out << ", "
        << "ballot=" << to_string(ballot);
    out << ", "
        << "meta_bulk_load_status=" << to_string(meta_bulk_load_status);
    out << ", "
        << "query_bulk_load_metadata=" << to_string(query_bulk_load_metadata);
    out << ", "
        << "remote_root_path=" << to_string(remote_root_path);
    out << ")";
}

bulk_load_response::~bulk_load_response() throw() {}

void bulk_load_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void bulk_load_response::__set_pid(const ::dsn::gpid &val) { this->pid = val; }

void bulk_load_response::__set_app_name(const std::string &val) { this->app_name = val; }

void bulk_load_response::__set_primary_bulk_load_status(const bulk_load_status::type val)
{
    this->primary_bulk_load_status = val;
}

void bulk_load_response::__set_group_bulk_load_state(
    const std::map<::dsn::rpc_address, partition_bulk_load_state> &val)
{
    this->group_bulk_load_state = val;
}

void bulk_load_response::__set_metadata(const bulk_load_metadata &val)
{
    this->metadata = val;
    __isset.metadata = true;
}

void bulk_load_response::__set_total_download_progress(const int32_t val)
{
    this->total_download_progress = val;
    __isset.total_download_progress = true;
}

void bulk_load_response::__set_is_group_ingestion_finished(const bool val)
{
    this->is_group_ingestion_finished = val;
    __isset.is_group_ingestion_finished = true;
}

void bulk_load_response::__set_is_group_bulk_load_context_cleaned_up(const bool val)
{
    this->is_group_bulk_load_context_cleaned_up = val;
    __isset.is_group_bulk_load_context_cleaned_up = true;
}

void bulk_load_response::__set_is_group_bulk_load_paused(const bool val)
{
    this->is_group_bulk_load_paused = val;
    __isset.is_group_bulk_load_paused = true;
}

uint32_t bulk_load_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast733;
                xfer += iprot->readI32(ecast733);
                this->primary_bulk_load_status = (bulk_load_status::type)ecast733;
                this->__isset.primary_bulk_load_status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_MAP) {
                {
                    this->group_bulk_load_state.clear();
                    uint32_t _size734;
                    ::apache::thrift::protocol::TType _ktype735;
                    ::apache::thrift::protocol::TType _vtype736;
                    xfer += iprot->readMapBegin(_ktype735, _vtype736, _size734);
                    uint32_t _i738;
                    for (_i738 = 0; _i738 < _size734; ++_i738) {
                        ::dsn::rpc_address _key739;
                        xfer += _key739.read(iprot);
                        partition_bulk_load_state &_val740 = this->group_bulk_load_state[_key739];
                        xfer += _val740.read(iprot);
                    }
                    xfer += iprot->readMapEnd();
                }
                this->__isset.group_bulk_load_state = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->metadata.read(iprot);
                this->__isset.metadata = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 7:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->total_download_progress);
                this->__isset.total_download_progress = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 8:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->is_group_ingestion_finished);
                this->__isset.is_group_ingestion_finished = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 9:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->is_group_bulk_load_context_cleaned_up);
                this->__isset.is_group_bulk_load_context_cleaned_up = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 10:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->is_group_bulk_load_paused);
                this->__isset.is_group_bulk_load_paused = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t bulk_load_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("bulk_load_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer +=
        oprot->writeFieldBegin("primary_bulk_load_status", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->primary_bulk_load_status);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("group_bulk_load_state", ::apache::thrift::protocol::T_MAP, 5);
    {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT,
                                     ::apache::thrift::protocol::T_STRUCT,
                                     static_cast<uint32_t>(this->group_bulk_load_state.size()));
        std::map<::dsn::rpc_address, partition_bulk_load_state>::const_iterator _iter741;
        for (_iter741 = this->group_bulk_load_state.begin();
             _iter741 != this->group_bulk_load_state.end();
             ++_iter741) {
            xfer += _iter741->first.write(oprot);
            xfer += _iter741->second.write(oprot);
        }
        xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();

    if (this->__isset.metadata) {
        xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRUCT, 6);
        xfer += this->metadata.write(oprot);
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.total_download_progress) {
        xfer +=
            oprot->writeFieldBegin("total_download_progress", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->total_download_progress);
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.is_group_ingestion_finished) {
        xfer += oprot->writeFieldBegin(
            "is_group_ingestion_finished", ::apache::thrift::protocol::T_BOOL, 8);
        xfer += oprot->writeBool(this->is_group_ingestion_finished);
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.is_group_bulk_load_context_cleaned_up) {
        xfer += oprot->writeFieldBegin(
            "is_group_bulk_load_context_cleaned_up", ::apache::thrift::protocol::T_BOOL, 9);
        xfer += oprot->writeBool(this->is_group_bulk_load_context_cleaned_up);
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.is_group_bulk_load_paused) {
        xfer += oprot->writeFieldBegin(
            "is_group_bulk_load_paused", ::apache::thrift::protocol::T_BOOL, 10);
        xfer += oprot->writeBool(this->is_group_bulk_load_paused);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(bulk_load_response &a, bulk_load_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.pid, b.pid);
    swap(a.app_name, b.app_name);
    swap(a.primary_bulk_load_status, b.primary_bulk_load_status);
    swap(a.group_bulk_load_state, b.group_bulk_load_state);
    swap(a.metadata, b.metadata);
    swap(a.total_download_progress, b.total_download_progress);
    swap(a.is_group_ingestion_finished, b.is_group_ingestion_finished);
    swap(a.is_group_bulk_load_context_cleaned_up, b.is_group_bulk_load_context_cleaned_up);
    swap(a.is_group_bulk_load_paused, b.is_group_bulk_load_paused);
    swap(a.__isset, b.__isset);
}

bulk_load_response::bulk_load_response(const bulk_load_response &other742)
{
    err = other742.err;
    pid = other742.pid;
    app_name = other742.app_name;
    primary_bulk_load_status = other742.primary_bulk_load_status;
    group_bulk_load_state = other742.group_bulk_load_state;
    metadata = other742.metadata;
    total_download_progress = other742.total_download_progress;
    is_group_ingestion_finished = other742.is_group_ingestion_finished;
    is_group_bulk_load_context_cleaned_up = other742.is_group_bulk_load_context_cleaned_up;
    is_group_bulk_load_paused = other742.is_group_bulk_load_paused;
    __isset = other742.__isset;
}
bulk_load_response::bulk_load_response(bulk_load_response &&other743)
{
    err = std::move(other743.err);
    pid = std::move(other743.pid);
    app_name = std::move(other743.app_name);
    primary_bulk_load_status = std::move(other743.primary_bulk_load_status);
    group_bulk_load_state = std::move(other743.group_bulk_load_state);
    metadata = std::move(other743.metadata);
    total_download_progress = std::move(other743.total_download_progress);
    is_group_ingestion_finished = std::move(other743.is_group_ingestion_finished);
    is_group_bulk_load_context_cleaned_up =
        std::move(other743.is_group_bulk_load_context_cleaned_up);
    is_group_bulk_load_paused = std::move(other743.is_group_bulk_load_paused);
    __isset = std::move(other743.__isset);
}
bulk_load_response &bulk_load_response::operator=(const bulk_load_response &other744)
{
    err = other744.err;
    pid = other744.pid;
    app_name = other744.app_name;
    primary_bulk_load_status = other744.primary_bulk_load_status;
    group_bulk_load_state = other744.group_bulk_load_state;
    metadata = other744.metadata;
    total_download_progress = other744.total_download_progress;
    is_group_ingestion_finished = other744.is_group_ingestion_finished;
    is_group_bulk_load_context_cleaned_up = other744.is_group_bulk_load_context_cleaned_up;
    is_group_bulk_load_paused = other744.is_group_bulk_load_paused;
    __isset = other744.__isset;
    return *this;
}
bulk_load_response &bulk_load_response::operator=(bulk_load_response &&other745)
{
    err = std::move(other745.err);
    pid = std::move(other745.pid);
    app_name = std::move(other745.app_name);
    primary_bulk_load_status = std::move(other745.primary_bulk_load_status);
    group_bulk_load_state = std::move(other745.group_bulk_load_state);
    metadata = std::move(other745.metadata);
    total_download_progress = std::move(other745.total_download_progress);
    is_group_ingestion_finished = std::move(other745.is_group_ingestion_finished);
    is_group_bulk_load_context_cleaned_up =
        std::move(other745.is_group_bulk_load_context_cleaned_up);
    is_group_bulk_load_paused = std::move(other745.is_group_bulk_load_paused);
    __isset = std::move(other745.__isset);
    return *this;
}
void bulk_load_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "bulk_load_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "pid=" << to_string(pid);
    out << ", "
        << "app_name=" << to_string(app_name);
    out << ", "
        << "primary_bulk_load_status=" << to_string(primary_bulk_load_status);
    out << ", "
        << "group_bulk_load_state=" << to_string(group_bulk_load_state);
    out << ", "
        << "metadata=";
    (__isset.metadata ? (out << to_string(metadata)) : (out << "<null>"));
    out << ", "
        << "total_download_progress=";
    (__isset.total_download_progress ? (out << to_string(total_download_progress))
                                     : (out << "<null>"));
    out << ", "
        << "is_group_ingestion_finished=";
    (__isset.is_group_ingestion_finished ? (out << to_string(is_group_ingestion_finished))
                                         : (out << "<null>"));
    out << ", "
        << "is_group_bulk_load_context_cleaned_up=";
    (__isset.is_group_bulk_load_context_cleaned_up
         ? (out << to_string(is_group_bulk_load_context_cleaned_up))
         : (out << "<null>"));
    out << ", "
        << "is_group_bulk_load_paused=";
    (__isset.is_group_bulk_load_paused ? (out << to_string(is_group_bulk_load_paused))
                                       : (out << "<null>"));
    out << ")";
}

group_bulk_load_request::~group_bulk_load_request() throw() {}

void group_bulk_load_request::__set_app_name(const std::string &val) { this->app_name = val; }

void group_bulk_load_request::__set_target_address(const ::dsn::rpc_address &val)
{
    this->target_address = val;
}

void group_bulk_load_request::__set_config(const replica_configuration &val) { this->config = val; }

void group_bulk_load_request::__set_provider_name(const std::string &val)
{
    this->provider_name = val;
}

void group_bulk_load_request::__set_cluster_name(const std::string &val)
{
    this->cluster_name = val;
}

void group_bulk_load_request::__set_meta_bulk_load_status(const bulk_load_status::type val)
{
    this->meta_bulk_load_status = val;
}

void group_bulk_load_request::__set_remote_root_path(const std::string &val)
{
    this->remote_root_path = val;
}

uint32_t group_bulk_load_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->target_address.read(iprot);
                this->__isset.target_address = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->config.read(iprot);
                this->__isset.config = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->provider_name);
                this->__isset.provider_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->cluster_name);
                this->__isset.cluster_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast746;
                xfer += iprot->readI32(ecast746);
                this->meta_bulk_load_status = (bulk_load_status::type)ecast746;
                this->__isset.meta_bulk_load_status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 7:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->remote_root_path);
                this->__isset.remote_root_path = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t group_bulk_load_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("group_bulk_load_request");

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("target_address", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->target_address.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->config.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("provider_name", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->provider_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("cluster_name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->cluster_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("meta_bulk_load_status", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->meta_bulk_load_status);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("remote_root_path", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->remote_root_path);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(group_bulk_load_request &a, group_bulk_load_request &b)
{
    using ::std::swap;
    swap(a.app_name, b.app_name);
    swap(a.target_address, b.target_address);
    swap(a.config, b.config);
    swap(a.provider_name, b.provider_name);
    swap(a.cluster_name, b.cluster_name);
    swap(a.meta_bulk_load_status, b.meta_bulk_load_status);
    swap(a.remote_root_path, b.remote_root_path);
    swap(a.__isset, b.__isset);
}

group_bulk_load_request::group_bulk_load_request(const group_bulk_load_request &other747)
{
    app_name = other747.app_name;
    target_address = other747.target_address;
    config = other747.config;
    provider_name = other747.provider_name;
    cluster_name = other747.cluster_name;
    meta_bulk_load_status = other747.meta_bulk_load_status;
    remote_root_path = other747.remote_root_path;
    __isset = other747.__isset;
}
group_bulk_load_request::group_bulk_load_request(group_bulk_load_request &&other748)
{
    app_name = std::move(other748.app_name);
    target_address = std::move(other748.target_address);
    config = std::move(other748.config);
    provider_name = std::move(other748.provider_name);
    cluster_name = std::move(other748.cluster_name);
    meta_bulk_load_status = std::move(other748.meta_bulk_load_status);
    remote_root_path = std::move(other748.remote_root_path);
    __isset = std::move(other748.__isset);
}
group_bulk_load_request &group_bulk_load_request::operator=(const group_bulk_load_request &other749)
{
    app_name = other749.app_name;
    target_address = other749.target_address;
    config = other749.config;
    provider_name = other749.provider_name;
    cluster_name = other749.cluster_name;
    meta_bulk_load_status = other749.meta_bulk_load_status;
    remote_root_path = other749.remote_root_path;
    __isset = other749.__isset;
    return *this;
}
group_bulk_load_request &group_bulk_load_request::operator=(group_bulk_load_request &&other750)
{
    app_name = std::move(other750.app_name);
    target_address = std::move(other750.target_address);
    config = std::move(other750.config);
    provider_name = std::move(other750.provider_name);
    cluster_name = std::move(other750.cluster_name);
    meta_bulk_load_status = std::move(other750.meta_bulk_load_status);
    remote_root_path = std::move(other750.remote_root_path);
    __isset = std::move(other750.__isset);
    return *this;
}
void group_bulk_load_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "group_bulk_load_request(";
    out << "app_name=" << to_string(app_name);
    out << ", "
        << "target_address=" << to_string(target_address);
    out << ", "
        << "config=" << to_string(config);
    out << ", "
        << "provider_name=" << to_string(provider_name);
    out << ", "
        << "cluster_name=" << to_string(cluster_name);
    out << ", "
        << "meta_bulk_load_status=" << to_string(meta_bulk_load_status);
    out << ", "
        << "remote_root_path=" << to_string(remote_root_path);
    out << ")";
}

group_bulk_load_response::~group_bulk_load_response() throw() {}

void group_bulk_load_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void group_bulk_load_response::__set_status(const bulk_load_status::type val)
{
    this->status = val;
}

void group_bulk_load_response::__set_bulk_load_state(const partition_bulk_load_state &val)
{
    this->bulk_load_state = val;
}

uint32_t group_bulk_load_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast751;
                xfer += iprot->readI32(ecast751);
                this->status = (bulk_load_status::type)ecast751;
                this->__isset.status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->bulk_load_state.read(iprot);
                this->__isset.bulk_load_state = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t group_bulk_load_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("group_bulk_load_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("bulk_load_state", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->bulk_load_state.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(group_bulk_load_response &a, group_bulk_load_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.status, b.status);
    swap(a.bulk_load_state, b.bulk_load_state);
    swap(a.__isset, b.__isset);
}

group_bulk_load_response::group_bulk_load_response(const group_bulk_load_response &other752)
{
    err = other752.err;
    status = other752.status;
    bulk_load_state = other752.bulk_load_state;
    __isset = other752.__isset;
}
group_bulk_load_response::group_bulk_load_response(group_bulk_load_response &&other753)
{
    err = std::move(other753.err);
    status = std::move(other753.status);
    bulk_load_state = std::move(other753.bulk_load_state);
    __isset = std::move(other753.__isset);
}
group_bulk_load_response &group_bulk_load_response::
operator=(const group_bulk_load_response &other754)
{
    err = other754.err;
    status = other754.status;
    bulk_load_state = other754.bulk_load_state;
    __isset = other754.__isset;
    return *this;
}
group_bulk_load_response &group_bulk_load_response::operator=(group_bulk_load_response &&other755)
{
    err = std::move(other755.err);
    status = std::move(other755.status);
    bulk_load_state = std::move(other755.bulk_load_state);
    __isset = std::move(other755.__isset);
    return *this;
}
void group_bulk_load_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "group_bulk_load_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "status=" << to_string(status);
    out << ", "
        << "bulk_load_state=" << to_string(bulk_load_state);
    out << ")";
}

ingestion_request::~ingestion_request() throw() {}

void ingestion_request::__set_app_name(const std::string &val) { this->app_name = val; }

void ingestion_request::__set_metadata(const bulk_load_metadata &val) { this->metadata = val; }

uint32_t ingestion_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->metadata.read(iprot);
                this->__isset.metadata = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t ingestion_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("ingestion_request");

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->metadata.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(ingestion_request &a, ingestion_request &b)
{
    using ::std::swap;
    swap(a.app_name, b.app_name);
    swap(a.metadata, b.metadata);
    swap(a.__isset, b.__isset);
}

ingestion_request::ingestion_request(const ingestion_request &other756)
{
    app_name = other756.app_name;
    metadata = other756.metadata;
    __isset = other756.__isset;
}
ingestion_request::ingestion_request(ingestion_request &&other757)
{
    app_name = std::move(other757.app_name);
    metadata = std::move(other757.metadata);
    __isset = std::move(other757.__isset);
}
ingestion_request &ingestion_request::operator=(const ingestion_request &other758)
{
    app_name = other758.app_name;
    metadata = other758.metadata;
    __isset = other758.__isset;
    return *this;
}
ingestion_request &ingestion_request::operator=(ingestion_request &&other759)
{
    app_name = std::move(other759.app_name);
    metadata = std::move(other759.metadata);
    __isset = std::move(other759.__isset);
    return *this;
}
void ingestion_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "ingestion_request(";
    out << "app_name=" << to_string(app_name);
    out << ", "
        << "metadata=" << to_string(metadata);
    out << ")";
}

ingestion_response::~ingestion_response() throw() {}

void ingestion_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void ingestion_response::__set_rocksdb_error(const int32_t val) { this->rocksdb_error = val; }

uint32_t ingestion_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->rocksdb_error);
                this->__isset.rocksdb_error = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t ingestion_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("ingestion_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("rocksdb_error", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->rocksdb_error);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(ingestion_response &a, ingestion_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.rocksdb_error, b.rocksdb_error);
    swap(a.__isset, b.__isset);
}

ingestion_response::ingestion_response(const ingestion_response &other760)
{
    err = other760.err;
    rocksdb_error = other760.rocksdb_error;
    __isset = other760.__isset;
}
ingestion_response::ingestion_response(ingestion_response &&other761)
{
    err = std::move(other761.err);
    rocksdb_error = std::move(other761.rocksdb_error);
    __isset = std::move(other761.__isset);
}
ingestion_response &ingestion_response::operator=(const ingestion_response &other762)
{
    err = other762.err;
    rocksdb_error = other762.rocksdb_error;
    __isset = other762.__isset;
    return *this;
}
ingestion_response &ingestion_response::operator=(ingestion_response &&other763)
{
    err = std::move(other763.err);
    rocksdb_error = std::move(other763.rocksdb_error);
    __isset = std::move(other763.__isset);
    return *this;
}
void ingestion_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "ingestion_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "rocksdb_error=" << to_string(rocksdb_error);
    out << ")";
}

control_bulk_load_request::~control_bulk_load_request() throw() {}

void control_bulk_load_request::__set_app_name(const std::string &val) { this->app_name = val; }

void control_bulk_load_request::__set_type(const bulk_load_control_type::type val)
{
    this->type = val;
}

uint32_t control_bulk_load_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast764;
                xfer += iprot->readI32(ecast764);
                this->type = (bulk_load_control_type::type)ecast764;
                this->__isset.type = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t control_bulk_load_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("control_bulk_load_request");

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(control_bulk_load_request &a, control_bulk_load_request &b)
{
    using ::std::swap;
    swap(a.app_name, b.app_name);
    swap(a.type, b.type);
    swap(a.__isset, b.__isset);
}

control_bulk_load_request::control_bulk_load_request(const control_bulk_load_request &other765)
{
    app_name = other765.app_name;
    type = other765.type;
    __isset = other765.__isset;
}
control_bulk_load_request::control_bulk_load_request(control_bulk_load_request &&other766)
{
    app_name = std::move(other766.app_name);
    type = std::move(other766.type);
    __isset = std::move(other766.__isset);
}
control_bulk_load_request &control_bulk_load_request::
operator=(const control_bulk_load_request &other767)
{
    app_name = other767.app_name;
    type = other767.type;
    __isset = other767.__isset;
    return *this;
}
control_bulk_load_request &control_bulk_load_request::
operator=(control_bulk_load_request &&other768)
{
    app_name = std::move(other768.app_name);
    type = std::move(other768.type);
    __isset = std::move(other768.__isset);
    return *this;
}
void control_bulk_load_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "control_bulk_load_request(";
    out << "app_name=" << to_string(app_name);
    out << ", "
        << "type=" << to_string(type);
    out << ")";
}

control_bulk_load_response::~control_bulk_load_response() throw() {}

void control_bulk_load_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void control_bulk_load_response::__set_hint_msg(const std::string &val)
{
    this->hint_msg = val;
    __isset.hint_msg = true;
}

uint32_t control_bulk_load_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->hint_msg);
                this->__isset.hint_msg = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t control_bulk_load_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("control_bulk_load_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.hint_msg) {
        xfer += oprot->writeFieldBegin("hint_msg", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->hint_msg);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(control_bulk_load_response &a, control_bulk_load_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.hint_msg, b.hint_msg);
    swap(a.__isset, b.__isset);
}

control_bulk_load_response::control_bulk_load_response(const control_bulk_load_response &other769)
{
    err = other769.err;
    hint_msg = other769.hint_msg;
    __isset = other769.__isset;
}
control_bulk_load_response::control_bulk_load_response(control_bulk_load_response &&other770)
{
    err = std::move(other770.err);
    hint_msg = std::move(other770.hint_msg);
    __isset = std::move(other770.__isset);
}
control_bulk_load_response &control_bulk_load_response::
operator=(const control_bulk_load_response &other771)
{
    err = other771.err;
    hint_msg = other771.hint_msg;
    __isset = other771.__isset;
    return *this;
}
control_bulk_load_response &control_bulk_load_response::
operator=(control_bulk_load_response &&other772)
{
    err = std::move(other772.err);
    hint_msg = std::move(other772.hint_msg);
    __isset = std::move(other772.__isset);
    return *this;
}
void control_bulk_load_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "control_bulk_load_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "hint_msg=";
    (__isset.hint_msg ? (out << to_string(hint_msg)) : (out << "<null>"));
    out << ")";
}

query_bulk_load_request::~query_bulk_load_request() throw() {}

void query_bulk_load_request::__set_app_name(const std::string &val) { this->app_name = val; }

uint32_t query_bulk_load_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t query_bulk_load_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("query_bulk_load_request");

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(query_bulk_load_request &a, query_bulk_load_request &b)
{
    using ::std::swap;
    swap(a.app_name, b.app_name);
    swap(a.__isset, b.__isset);
}

query_bulk_load_request::query_bulk_load_request(const query_bulk_load_request &other773)
{
    app_name = other773.app_name;
    __isset = other773.__isset;
}
query_bulk_load_request::query_bulk_load_request(query_bulk_load_request &&other774)
{
    app_name = std::move(other774.app_name);
    __isset = std::move(other774.__isset);
}
query_bulk_load_request &query_bulk_load_request::operator=(const query_bulk_load_request &other775)
{
    app_name = other775.app_name;
    __isset = other775.__isset;
    return *this;
}
query_bulk_load_request &query_bulk_load_request::operator=(query_bulk_load_request &&other776)
{
    app_name = std::move(other776.app_name);
    __isset = std::move(other776.__isset);
    return *this;
}
void query_bulk_load_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "query_bulk_load_request(";
    out << "app_name=" << to_string(app_name);
    out << ")";
}

query_bulk_load_response::~query_bulk_load_response() throw() {}

void query_bulk_load_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void query_bulk_load_response::__set_app_name(const std::string &val) { this->app_name = val; }

void query_bulk_load_response::__set_app_status(const bulk_load_status::type val)
{
    this->app_status = val;
}

void query_bulk_load_response::__set_partitions_status(
    const std::vector<bulk_load_status::type> &val)
{
    this->partitions_status = val;
}

void query_bulk_load_response::__set_max_replica_count(const int32_t val)
{
    this->max_replica_count = val;
}

void query_bulk_load_response::__set_bulk_load_states(
    const std::vector<std::map<::dsn::rpc_address, partition_bulk_load_state>> &val)
{
    this->bulk_load_states = val;
}

void query_bulk_load_response::__set_hint_msg(const std::string &val)
{
    this->hint_msg = val;
    __isset.hint_msg = true;
}

uint32_t query_bulk_load_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->app_name);
                this->__isset.app_name = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast777;
                xfer += iprot->readI32(ecast777);
                this->app_status = (bulk_load_status::type)ecast777;
                this->__isset.app_status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->partitions_status.clear();
                    uint32_t _size778;
                    ::apache::thrift::protocol::TType _etype781;
                    xfer += iprot->readListBegin(_etype781, _size778);
                    this->partitions_status.resize(_size778);
                    uint32_t _i782;
                    for (_i782 = 0; _i782 < _size778; ++_i782) {
                        int32_t ecast783;
                        xfer += iprot->readI32(ecast783);
                        this->partitions_status[_i782] = (bulk_load_status::type)ecast783;
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.partitions_status = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->max_replica_count);
                this->__isset.max_replica_count = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->bulk_load_states.clear();
                    uint32_t _size784;
                    ::apache::thrift::protocol::TType _etype787;
                    xfer += iprot->readListBegin(_etype787, _size784);
                    this->bulk_load_states.resize(_size784);
                    uint32_t _i788;
                    for (_i788 = 0; _i788 < _size784; ++_i788) {
                        {
                            this->bulk_load_states[_i788].clear();
                            uint32_t _size789;
                            ::apache::thrift::protocol::TType _ktype790;
                            ::apache::thrift::protocol::TType _vtype791;
                            xfer += iprot->readMapBegin(_ktype790, _vtype791, _size789);
                            uint32_t _i793;
                            for (_i793 = 0; _i793 < _size789; ++_i793) {
                                ::dsn::rpc_address _key794;
                                xfer += _key794.read(iprot);
                                partition_bulk_load_state &_val795 =
                                    this->bulk_load_states[_i788][_key794];
                                xfer += _val795.read(iprot);
                            }
                            xfer += iprot->readMapEnd();
                        }
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.bulk_load_states = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 7:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->hint_msg);
                this->__isset.hint_msg = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t query_bulk_load_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("query_bulk_load_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->app_name);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("app_status", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->app_status);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("partitions_status", ::apache::thrift::protocol::T_LIST, 4);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32,
                                      static_cast<uint32_t>(this->partitions_status.size()));
        std::vector<bulk_load_status::type>::const_iterator _iter796;
        for (_iter796 = this->partitions_status.begin(); _iter796 != this->partitions_status.end();
             ++_iter796) {
            xfer += oprot->writeI32((int32_t)(*_iter796));
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("max_replica_count", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->max_replica_count);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("bulk_load_states", ::apache::thrift::protocol::T_LIST, 6);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP,
                                      static_cast<uint32_t>(this->bulk_load_states.size()));
        std::vector<std::map<::dsn::rpc_address, partition_bulk_load_state>>::const_iterator
            _iter797;
        for (_iter797 = this->bulk_load_states.begin(); _iter797 != this->bulk_load_states.end();
             ++_iter797) {
            {
                xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT,
                                             ::apache::thrift::protocol::T_STRUCT,
                                             static_cast<uint32_t>((*_iter797).size()));
                std::map<::dsn::rpc_address, partition_bulk_load_state>::const_iterator _iter798;
                for (_iter798 = (*_iter797).begin(); _iter798 != (*_iter797).end(); ++_iter798) {
                    xfer += _iter798->first.write(oprot);
                    xfer += _iter798->second.write(oprot);
                }
                xfer += oprot->writeMapEnd();
            }
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    if (this->__isset.hint_msg) {
        xfer += oprot->writeFieldBegin("hint_msg", ::apache::thrift::protocol::T_STRING, 7);
        xfer += oprot->writeString(this->hint_msg);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(query_bulk_load_response &a, query_bulk_load_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.app_name, b.app_name);
    swap(a.app_status, b.app_status);
    swap(a.partitions_status, b.partitions_status);
    swap(a.max_replica_count, b.max_replica_count);
    swap(a.bulk_load_states, b.bulk_load_states);
    swap(a.hint_msg, b.hint_msg);
    swap(a.__isset, b.__isset);
}

query_bulk_load_response::query_bulk_load_response(const query_bulk_load_response &other799)
{
    err = other799.err;
    app_name = other799.app_name;
    app_status = other799.app_status;
    partitions_status = other799.partitions_status;
    max_replica_count = other799.max_replica_count;
    bulk_load_states = other799.bulk_load_states;
    hint_msg = other799.hint_msg;
    __isset = other799.__isset;
}
query_bulk_load_response::query_bulk_load_response(query_bulk_load_response &&other800)
{
    err = std::move(other800.err);
    app_name = std::move(other800.app_name);
    app_status = std::move(other800.app_status);
    partitions_status = std::move(other800.partitions_status);
    max_replica_count = std::move(other800.max_replica_count);
    bulk_load_states = std::move(other800.bulk_load_states);
    hint_msg = std::move(other800.hint_msg);
    __isset = std::move(other800.__isset);
}
query_bulk_load_response &query_bulk_load_response::
operator=(const query_bulk_load_response &other801)
{
    err = other801.err;
    app_name = other801.app_name;
    app_status = other801.app_status;
    partitions_status = other801.partitions_status;
    max_replica_count = other801.max_replica_count;
    bulk_load_states = other801.bulk_load_states;
    hint_msg = other801.hint_msg;
    __isset = other801.__isset;
    return *this;
}
query_bulk_load_response &query_bulk_load_response::operator=(query_bulk_load_response &&other802)
{
    err = std::move(other802.err);
    app_name = std::move(other802.app_name);
    app_status = std::move(other802.app_status);
    partitions_status = std::move(other802.partitions_status);
    max_replica_count = std::move(other802.max_replica_count);
    bulk_load_states = std::move(other802.bulk_load_states);
    hint_msg = std::move(other802.hint_msg);
    __isset = std::move(other802.__isset);
    return *this;
}
void query_bulk_load_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "query_bulk_load_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "app_name=" << to_string(app_name);
    out << ", "
        << "app_status=" << to_string(app_status);
    out << ", "
        << "partitions_status=" << to_string(partitions_status);
    out << ", "
        << "max_replica_count=" << to_string(max_replica_count);
    out << ", "
        << "bulk_load_states=" << to_string(bulk_load_states);
    out << ", "
        << "hint_msg=";
    (__isset.hint_msg ? (out << to_string(hint_msg)) : (out << "<null>"));
    out << ")";
}

detect_hotkey_request::~detect_hotkey_request() throw() {}

void detect_hotkey_request::__set_type(const hotkey_type::type val) { this->type = val; }

void detect_hotkey_request::__set_action(const detect_action::type val) { this->action = val; }

void detect_hotkey_request::__set_pid(const ::dsn::gpid &val) { this->pid = val; }

uint32_t detect_hotkey_request::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast803;
                xfer += iprot->readI32(ecast803);
                this->type = (hotkey_type::type)ecast803;
                this->__isset.type = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                int32_t ecast804;
                xfer += iprot->readI32(ecast804);
                this->action = (detect_action::type)ecast804;
                this->__isset.action = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->pid.read(iprot);
                this->__isset.pid = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t detect_hotkey_request::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("detect_hotkey_request");

    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("action", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->action);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->pid.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(detect_hotkey_request &a, detect_hotkey_request &b)
{
    using ::std::swap;
    swap(a.type, b.type);
    swap(a.action, b.action);
    swap(a.pid, b.pid);
    swap(a.__isset, b.__isset);
}

detect_hotkey_request::detect_hotkey_request(const detect_hotkey_request &other805)
{
    type = other805.type;
    action = other805.action;
    pid = other805.pid;
    __isset = other805.__isset;
}
detect_hotkey_request::detect_hotkey_request(detect_hotkey_request &&other806)
{
    type = std::move(other806.type);
    action = std::move(other806.action);
    pid = std::move(other806.pid);
    __isset = std::move(other806.__isset);
}
detect_hotkey_request &detect_hotkey_request::operator=(const detect_hotkey_request &other807)
{
    type = other807.type;
    action = other807.action;
    pid = other807.pid;
    __isset = other807.__isset;
    return *this;
}
detect_hotkey_request &detect_hotkey_request::operator=(detect_hotkey_request &&other808)
{
    type = std::move(other808.type);
    action = std::move(other808.action);
    pid = std::move(other808.pid);
    __isset = std::move(other808.__isset);
    return *this;
}
void detect_hotkey_request::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "detect_hotkey_request(";
    out << "type=" << to_string(type);
    out << ", "
        << "action=" << to_string(action);
    out << ", "
        << "pid=" << to_string(pid);
    out << ")";
}

detect_hotkey_response::~detect_hotkey_response() throw() {}

void detect_hotkey_response::__set_err(const ::dsn::error_code &val) { this->err = val; }

void detect_hotkey_response::__set_err_hint(const std::string &val)
{
    this->err_hint = val;
    __isset.err_hint = true;
}

void detect_hotkey_response::__set_hotkey_result(const std::string &val)
{
    this->hotkey_result = val;
    __isset.hotkey_result = true;
}

uint32_t detect_hotkey_response::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                xfer += this->err.read(iprot);
                this->__isset.err = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->err_hint);
                this->__isset.err_hint = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->hotkey_result);
                this->__isset.hotkey_result = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t detect_hotkey_response::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("detect_hotkey_response");

    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.err_hint) {
        xfer += oprot->writeFieldBegin("err_hint", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->err_hint);
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.hotkey_result) {
        xfer += oprot->writeFieldBegin("hotkey_result", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->hotkey_result);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(detect_hotkey_response &a, detect_hotkey_response &b)
{
    using ::std::swap;
    swap(a.err, b.err);
    swap(a.err_hint, b.err_hint);
    swap(a.hotkey_result, b.hotkey_result);
    swap(a.__isset, b.__isset);
}

detect_hotkey_response::detect_hotkey_response(const detect_hotkey_response &other809)
{
    err = other809.err;
    err_hint = other809.err_hint;
    hotkey_result = other809.hotkey_result;
    __isset = other809.__isset;
}
detect_hotkey_response::detect_hotkey_response(detect_hotkey_response &&other810)
{
    err = std::move(other810.err);
    err_hint = std::move(other810.err_hint);
    hotkey_result = std::move(other810.hotkey_result);
    __isset = std::move(other810.__isset);
}
detect_hotkey_response &detect_hotkey_response::operator=(const detect_hotkey_response &other811)
{
    err = other811.err;
    err_hint = other811.err_hint;
    hotkey_result = other811.hotkey_result;
    __isset = other811.__isset;
    return *this;
}
detect_hotkey_response &detect_hotkey_response::operator=(detect_hotkey_response &&other812)
{
    err = std::move(other812.err);
    err_hint = std::move(other812.err_hint);
    hotkey_result = std::move(other812.hotkey_result);
    __isset = std::move(other812.__isset);
    return *this;
}
void detect_hotkey_response::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "detect_hotkey_response(";
    out << "err=" << to_string(err);
    out << ", "
        << "err_hint=";
    (__isset.err_hint ? (out << to_string(err_hint)) : (out << "<null>"));
    out << ", "
        << "hotkey_result=";
    (__isset.hotkey_result ? (out << to_string(hotkey_result)) : (out << "<null>"));
    out << ")";
}
}
} // namespace
